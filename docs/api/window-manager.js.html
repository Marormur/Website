<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>JSDoc: Source: window-manager.js</title>

        <script src="scripts/prettify/prettify.js"></script>
        <script src="scripts/prettify/lang-css.js"></script>
        <!--[if lt IE 9]>
            <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
        <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css" />
        <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css" />
    </head>

    <body>
        <div id="main">
            <h1 class="page-title">Source: window-manager.js</h1>

            <section>
                <article>
                    <pre class="prettyprint source linenums"><code>/**
 * WindowManager - Central registry for windows/modals with z-index management and program metadata.
 *
 * Responsibilities:
 * - Register window configs (persistent/transient)
 * - Track dialog instances and z-index ordering
 * - Provide program info via i18n keys
 *
 * Usage:
 *   WindowManager.register({ id: 'finder-modal', type: 'persistent', programKey: 'programs.finder' })
 *   WindowManager.open('finder-modal')
 *
 * Notes: This is legacy JS; types are documented via JSDoc for editor hints.
 */
console.log('WindowManager loaded');

/**
 * WindowManager - Zentrale Verwaltung für alle Fenster/Modals
 *
 * Vorteile:
 * - Neue Fenster können sich selbst registrieren
 * - Alle Fenster-Metadaten an einem Ort
 * - Keine hart-kodierten Arrays mehr
 * - Einfache Erweiterbarkeit für neue Features
 */
(function () {
    'use strict';

    const windowRegistry = new Map();
    const baseZIndex = 1000;
    let topZIndex = 1000;

    // Window-Konfiguration
    /**
     * @typedef {Object} WindowConfigOptions
     * @property {string} id
     * @property {('persistent'|'transient')} [type]
     * @property {string} [programKey]
     * @property {string} [icon]
     * @property {string|null} [closeButtonId]
     * @property {Object} [metadata]
     */
    class WindowConfig {
        constructor(options) {
            this.id = options.id;
            this.type = options.type || 'persistent'; // 'persistent' oder 'transient'
            this.programKey = options.programKey || 'programs.default';
            this.icon = options.icon || './img/sucher.png';
            this.closeButtonId = options.closeButtonId || null;
            this.dialogInstance = null;
            this.metadata = options.metadata || {};
        }

        isTransient() {
            return this.type === 'transient';
        }

        getProgramInfo() {
            const i18n = window.appI18n;
            const translate = i18n?.translate || ((key) => key);

            const aboutFields = ['name', 'tagline', 'version', 'copyright'];
            const info = {
                modalId: this.id,
                programLabel: translate(`${this.programKey}.label`),
                infoLabel: translate(`${this.programKey}.infoLabel`),
                fallbackInfoModalId:
                    this.metadata.fallbackInfoModalId || 'program-info-modal',
                icon: this.icon,
                about: {},
            };

            aboutFields.forEach((field) => {
                info.about[field] = translate(
                    `${this.programKey}.about.${field}`,
                );
            });

            return info;
        }
    }

    const WindowManager = {
        /**
         * Registriert ein neues Fenster im System
         * @param {WindowConfigOptions} config
         * @returns {WindowConfig}
         */
        register(config) {
            const windowConfig = new WindowConfig(config);
            windowRegistry.set(config.id, windowConfig);
            return windowConfig;
        },

        /**
         * Registriert mehrere Fenster auf einmal
         * @param {WindowConfigOptions[]} configs
         */
        registerAll(configs) {
            configs.forEach((config) => this.register(config));
        },

        /**
         * Gibt die Konfiguration eines Fensters zurück
         * @param {string} windowId
         * @returns {WindowConfig|null}
         */
        getConfig(windowId) {
            return windowRegistry.get(windowId) || null;
        },

        /**
         * Gibt alle registrierten Fenster-IDs zurück
         * @returns {string[]}
         */
        getAllWindowIds() {
            return Array.from(windowRegistry.keys());
        },

        /**
         * Gibt alle persistenten Fenster zurück
         * @returns {string[]}
         */
        getPersistentWindowIds() {
            return this.getAllWindowIds().filter((id) => {
                const config = this.getConfig(id);
                return config &amp;&amp; !config.isTransient();
            });
        },

        /**
         * Gibt alle transienten Fenster zurück
         * @returns {string[]}
         */
        getTransientWindowIds() {
            return this.getAllWindowIds().filter((id) => {
                const config = this.getConfig(id);
                return config &amp;&amp; config.isTransient();
            });
        },

        /**
         * Setzt die Dialog-Instanz für ein Fenster
         * @param {string} windowId
         * @param {any} instance
         */
        setDialogInstance(windowId, instance) {
            const config = this.getConfig(windowId);
            if (config) {
                config.dialogInstance = instance;
            }
        },

        /**
         * Gibt die Dialog-Instanz eines Fensters zurück
         */
        getDialogInstance(windowId) {
            const config = this.getConfig(windowId);
            return config?.dialogInstance || null;
        },

        /**
         * Gibt alle Dialog-Instanzen zurück
         */
        getAllDialogInstances() {
            const dialogs = {};
            windowRegistry.forEach((config, id) => {
                if (config.dialogInstance) {
                    dialogs[id] = config.dialogInstance;
                }
            });
            return dialogs;
        },

        /**
         * Gibt das oberste sichtbare Fenster zurück
         */
        getTopWindow() {
            let topModal = null;
            let highestZ = 0;

            this.getAllWindowIds().forEach((id) => {
                const modal = document.getElementById(id);
                if (modal &amp;&amp; !modal.classList.contains('hidden')) {
                    const zIndex =
                        parseInt(getComputedStyle(modal).zIndex, 10) || 0;
                    if (zIndex > highestZ) {
                        highestZ = zIndex;
                        topModal = modal;
                    }
                }
            });

            return topModal;
        },

        /**
         * Bringt ein Fenster in den Vordergrund
         */
        bringToFront(windowId) {
            const instance = this.getDialogInstance(windowId);
            if (instance &amp;&amp; typeof instance.bringToFront === 'function') {
                instance.bringToFront();
            } else {
                console.warn(`Keine Dialog-Instanz für ${windowId} gefunden.`);
            }
        },

        /**
         * Öffnet ein Fenster
         */
        open(windowId) {
            // Run per-window init handler once if provided
            const config = this.getConfig(windowId);
            if (
                config &amp;&amp;
                config.metadata &amp;&amp;
                typeof config.metadata.initHandler === 'function'
            ) {
                try {
                    if (!config.metadata.__initialized) {
                        config.metadata.initHandler();
                        config.metadata.__initialized = true;
                    }
                } catch (e) {
                    console.warn(`Init handler for ${windowId} threw:`, e);
                }
            }

            const instance = this.getDialogInstance(windowId);
            if (instance &amp;&amp; typeof instance.open === 'function') {
                instance.open();
            } else {
                const modal = document.getElementById(windowId);
                if (modal) {
                    modal.classList.remove('hidden');
                    this.bringToFront(windowId);
                }
            }
        },

        /**
         * Schließt ein Fenster
         */
        close(windowId) {
            const instance = this.getDialogInstance(windowId);
            if (instance &amp;&amp; typeof instance.close === 'function') {
                instance.close();
            } else {
                const modal = document.getElementById(windowId);
                if (modal) {
                    modal.classList.add('hidden');
                }
            }
        },

        /**
         * Z-Index Management
         */
        getNextZIndex() {
            topZIndex++;
            return topZIndex;
        },

        syncZIndexWithDOM() {
            let maxZ = baseZIndex;

            this.getAllWindowIds().forEach((id) => {
                const modal = document.getElementById(id);
                if (!modal) return;

                const modalZ = parseInt(
                    window.getComputedStyle(modal).zIndex,
                    10,
                );
                if (!Number.isNaN(modalZ)) {
                    maxZ = Math.max(maxZ, modalZ);
                }

                const windowEl = this.getDialogWindowElement(modal);
                if (windowEl) {
                    const contentZ = parseInt(
                        window.getComputedStyle(windowEl).zIndex,
                        10,
                    );
                    if (!Number.isNaN(contentZ)) {
                        maxZ = Math.max(maxZ, contentZ);
                    }
                }
            });

            topZIndex = maxZ;
            return maxZ;
        },

        getDialogWindowElement(modal) {
            if (!modal) return null;
            return modal.querySelector('.autopointer') || modal;
        },

        /**
         * Gibt Program-Info für ein Fenster zurück
         */
        getProgramInfo(windowId) {
            const config = this.getConfig(windowId);
            if (config) {
                return config.getProgramInfo();
            }

            // Fallback für nicht-registrierte Fenster
            return this.getDefaultProgramInfo();
        },

        getDefaultProgramInfo() {
            const i18n = window.appI18n;
            const translate = i18n?.translate || ((key) => key);
            const programKey = 'programs.default';

            return {
                modalId: null,
                programLabel: translate(`${programKey}.label`),
                infoLabel: translate(`${programKey}.infoLabel`),
                fallbackInfoModalId: 'program-info-modal',
                icon: './img/sucher.png',
                about: {
                    name: translate(`${programKey}.about.name`),
                    tagline: translate(`${programKey}.about.tagline`),
                    version: translate(`${programKey}.about.version`),
                    copyright: translate(`${programKey}.about.copyright`),
                },
            };
        },

        // Expose internal state für Migration
        get topZIndex() {
            return topZIndex;
        },

        set topZIndex(value) {
            topZIndex = value;
        },

        get baseZIndex() {
            return baseZIndex;
        },
    };

    // Globaler Export
    window.WindowManager = WindowManager;

    // Legacy-Kompatibilität
    Object.defineProperty(window, 'topZIndex', {
        get: () => WindowManager.topZIndex,
        set: (value) => {
            WindowManager.topZIndex = value;
        },
    });
})();
</code></pre>
                </article>
            </section>
        </div>

        <nav>
            <h2><a href="index.html">Home</a></h2>
            <h3>Modules</h3>
            <ul>
                <li><a href="module-InstanceManager.html">InstanceManager</a></li>
            </ul>
            <h3>Classes</h3>
            <ul>
                <li><a href="BaseWindowInstance.html">BaseWindowInstance</a></li>
                <li><a href="KeyboardShortcutManager.html">KeyboardShortcutManager</a></li>
                <li><a href="MultiInstanceIntegration.html">MultiInstanceIntegration</a></li>
                <li><a href="SessionManager.html">SessionManager</a></li>
                <li><a href="TerminalInstance.html">TerminalInstance</a></li>
                <li><a href="TextEditorInstance.html">TextEditorInstance</a></li>
                <li><a href="WindowTabManager.html">WindowTabManager</a></li>
                <li><a href="module-InstanceManager-InstanceManager.html">InstanceManager</a></li>
            </ul>
            <h3>Global</h3>
            <ul>
                <li><a href="global.html#ensureSvgNamespace">ensureSvgNamespace</a></li>
                <li><a href="global.html#getDockReservedBottom">getDockReservedBottom</a></li>
                <li><a href="global.html#getMenuIconSvg">getMenuIconSvg</a></li>
                <li><a href="global.html#getThemePreference">getThemePreference</a></li>
                <li><a href="global.html#initDockMagnification">initDockMagnification</a></li>
                <li><a href="global.html#renderIconIntoElement">renderIconIntoElement</a></li>
                <li><a href="global.html#setThemePreference">setThemePreference</a></li>
                <li>
                    <a href="global.html#updateThemeFromPreference">updateThemeFromPreference</a>
                </li>
            </ul>
        </nav>

        <br class="clear" />

        <footer>
            Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on
            Sat Oct 25 2025 16:35:41 GMT+0200 (Central European Summer Time)
        </footer>

        <script>
            prettyPrint();
        </script>
        <script src="scripts/linenumber.js"></script>
    </body>
</html>

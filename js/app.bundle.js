'use strict';
var App = (() => {
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __esm = (fn, res) =>
        function __init() {
            return (fn && (res = (0, fn[__getOwnPropNames(fn)[0]])((fn = 0))), res);
        };
    var __commonJS = (cb, mod) =>
        function __require() {
            return (
                mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod),
                mod.exports
            );
        };
    var __export = (target, all) => {
        for (var name in all) __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
        if ((from && typeof from === 'object') || typeof from === 'function') {
            for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                    __defProp(to, key, {
                        get: () => from[key],
                        enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
                    });
        }
        return to;
    };
    var __toESM = (mod, isNodeMode, target) => (
        (target = mod != null ? __create(__getProtoOf(mod)) : {}),
        __copyProps(
            // If the importer is in node compatibility mode or this is not an ESM
            // file that has been converted to a CommonJS file using a Babel-
            // compatible transform (i.e. "__esModule" has not been set), then set
            // "default" to the CommonJS "module.exports" for node compatibility.
            isNodeMode || !mod || !mod.__esModule
                ? __defProp(target, 'default', { value: mod, enumerable: true })
                : target,
            mod
        )
    );

    // src/ts/i18n/de.ts
    var de;
    var init_de = __esm({
        'src/ts/i18n/de.ts'() {
            'use strict';
            de = {
                context: {
                    menuLabel: 'Kontextmen\xFC',
                    open: '\xD6ffnen',
                    openFinder: 'Sucher \xF6ffnen',
                    openTextEditor: 'Texteditor \xF6ffnen',
                    openProjects: 'Projekte \xF6ffnen',
                    openSettings: 'Systemeinstellungen \u2026',
                    toggleDarkMode: 'Dark Mode umschalten',
                    about: '\xDCber Marvin',
                    image: {
                        openInTab: 'Bild in neuem Tab \xF6ffnen',
                        save: 'Bild sichern \u2026',
                    },
                    finder: {
                        openItem: '\xD6ffnen',
                        getInfo: 'Informationen',
                        refresh: 'Aktualisieren',
                        newFolder: 'Neuer Ordner',
                        viewList: 'Als Liste',
                        viewGrid: 'Als Raster',
                        sortByName: 'Nach Name sortieren',
                        sortByDate: 'Nach Datum sortieren',
                        sortBySize: 'Nach Gr\xF6\xDFe sortieren',
                    },
                },
                common: {
                    close: 'Schlie\xDFen',
                    system: 'System',
                    german: 'Deutsch',
                    english: 'Englisch',
                },
                header: {
                    profile: {
                        about: '\xDCber Marvin',
                        resetLayout: 'Fenster zur\xFCcksetzen',
                        settings: 'Systemeinstellungen',
                        linkedin: 'LinkedIn',
                    },
                    program: {
                        close: 'Programm schlie\xDFen',
                    },
                },
                desktop: {
                    finder: 'Sucher',
                    projects: 'Projekte',
                    github: 'GitHub Projekte',
                    text: 'Texteditor',
                    image: 'Bildbetrachter',
                    photos: 'Fotos',
                    settings: 'Systemeinstellungen',
                    about: '\xDCber Marvin',
                    launchpad: 'Launchpad',
                    terminal: 'Terminal',
                },
                dock: {
                    finder: 'Sucher',
                    projects: 'GitHub Projekte',
                    text: 'Texteditor',
                    image: 'Bildbetrachter',
                    settings: 'Systemeinstellungen',
                    launchpad: 'Apps',
                    terminal: 'Terminal',
                },
                menubar: {
                    appleMenu: {
                        label: 'Apple-Men\xFC',
                    },
                    applicationMenus: 'Anwendungsmen\xFCs',
                    controlCenter: {
                        label: 'Kontrollzentrum',
                        quickActions: 'Schnellaktionen',
                        quickActionsAria: 'Schnellaktionen',
                        brightness: 'Helligkeit',
                        volume: 'Lautst\xE4rke',
                    },
                    toggles: {
                        wifi: 'WLAN',
                        wifiStatus: 'WLAN-Status',
                        bluetooth: 'Bluetooth',
                        bluetoothStatus: 'Bluetooth-Status',
                        focus: 'Fokus',
                        darkMode: 'Dark Mode',
                    },
                    wifi: {
                        preferredNetworks: 'Bevorzugte Netzwerke',
                    },
                    bluetooth: {
                        devices: 'Ger\xE4te',
                        airpods: 'Marvins AirPods Pro',
                        keyboard: 'Magic Keyboard',
                        speaker: 'HomeSpeaker',
                    },
                    sound: {
                        label: 'Ton',
                        outputDevices: 'Ausgabeger\xE4te',
                        devices: {
                            speakers: 'MacBook Lautsprecher',
                            airpods: 'Marvins AirPods Pro',
                            display: 'Samsung Monitor',
                        },
                    },
                    networks: {
                        home: 'HomeLAN',
                        office: 'Office',
                        hotspot: 'Marvin iPhone',
                    },
                    state: {
                        on: 'Ein',
                        off: 'Aus',
                        active: 'Aktiv',
                        connected: 'Verbunden',
                        ready: 'Bereit',
                        notConnected: 'Nicht verbunden',
                        hotspot: 'Pers\xF6nlicher Hotspot',
                        automatic: 'Automatisch',
                    },
                    actions: {
                        networkSettings: 'Netzwerkeinstellungen \u2026',
                        bluetoothSettings: 'Bluetooth-Einstellungen \u2026',
                        soundSettings: 'Ton-Einstellungen \u2026',
                        spotlight: 'Spotlight',
                        siri: 'Siri',
                    },
                    battery: {
                        label: 'Batteriestatus',
                        fullLabel: 'Batterie vollst\xE4ndig geladen',
                    },
                },
                modals: {
                    projects: {
                        title: 'Projekte',
                        repositories: 'Repositories',
                        placeholder: 'W\xE4hle ein Repository aus, um dessen Dateien zu sehen.',
                    },
                    about: {
                        title: '\xDCber Marvin',
                        birth: 'M\xE4rz 1999',
                        locationLabel: 'Wohnort',
                        locationValue: 'Deutschland',
                        jobLabel: 'Beruf',
                        jobValue: 'Softwareentwickler',
                        employerLabel: 'Arbeitgeber',
                        employerValue: 'WinWorker',
                        moreButton: 'Mehr Infos \u2026',
                        copyright: '\xA9 2025 Marvin T. \u2014 Alle Rechte vorbehalten.',
                    },
                    settings: {
                        title: 'Systemeinstellungen',
                    },
                    text: {
                        title: 'Texteditor',
                    },
                    image: {
                        title: 'Bildbetrachter',
                        placeholder:
                            '\xD6ffne eine Bilddatei aus dem Sucher, um die Vorschau zu sehen.',
                    },
                    finder: {
                        title: 'Sucher',
                    },
                    programInfo: {
                        title: '\xDCber dieses Programm',
                    },
                    launchpad: {
                        title: 'Launchpad',
                        searchPlaceholder: 'Programme suchen',
                    },
                    terminal: {
                        title: 'Terminal',
                    },
                },
                photos: {
                    title: 'Fotos',
                    badge: 'PICSUM CLOUD',
                    sidebar: {
                        library: 'Bibliothek',
                        filters: 'Filter',
                        refresh: 'Neu laden',
                        sourceNote:
                            'Quelle: Lorem Picsum \u2013 zuf\xE4llige kuratierte Fotokollektionen.',
                        items: {
                            all: 'Alle Fotos',
                            favorites: 'Favoriten',
                            landscape: 'Querformat',
                            portrait: 'Hochformat',
                            square: 'Quadratisch',
                        },
                    },
                    segments: {
                        moments: 'Momente',
                        collections: 'Sammlungen',
                        years: 'Jahre',
                    },
                    search: {
                        placeholder: 'Nach Autor suchen',
                        clear: 'Suche l\xF6schen',
                    },
                    status: {
                        countPlaceholder: '\u2013 Fotos',
                        loading: 'Lade Fotos\u2026',
                        count: '{count} {label} \u2022 {segment}',
                    },
                    errors: {
                        heading: 'Fehler beim Laden',
                        description:
                            'Bitte \xFCberpr\xFCfe deine Verbindung und versuche es erneut.',
                        detailImage: 'Das Foto konnte nicht geladen werden.',
                    },
                    buttons: {
                        retry: 'Erneut versuchen',
                    },
                    empty: {
                        title: 'Keine Fotos gefunden',
                        description: 'Passe Suche oder Filter an, um weitere Ergebnisse zu sehen.',
                    },
                    placeholder: 'W\xE4hle ein Foto aus, um Details zu sehen.',
                    detail: {
                        titleFallback: 'Foto',
                        favoriteAdd: 'Zu Favoriten',
                        favoriteRemove: 'Favorit entfernen',
                        favoriteUnavailable: 'Nicht verf\xFCgbar',
                        download: 'Herunterladen',
                        open: 'Auf Lorem Picsum ansehen',
                        loader: 'Foto wird geladen\u2026',
                        prev: 'Vorheriges Foto',
                        next: 'N\xE4chstes Foto',
                        imageAlt: 'Ausgew\xE4hltes Foto',
                        unknownPhoto: 'Unbekanntes Foto',
                        unknownPhotographer: 'Unbekannter Fotograf',
                        externalLabel: 'Externes Foto',
                        dimensions: 'Aufl\xF6sung: {width} \xD7 {height}px',
                        downloadFilename: 'foto-{id}.jpg',
                        externalCounter: 'Externes Bild',
                        counter: '{index} von {total}',
                        externalFile: 'Externe Datei',
                    },
                    orientations: {
                        landscape: 'Querformat',
                        portrait: 'Portr\xE4t',
                        square: 'Quadrat',
                    },
                    collections: {
                        landscape: 'Horizonte',
                        portrait: 'Portr\xE4ts',
                        square: 'Quadrate',
                    },
                    labels: {
                        photoSingular: 'Foto',
                        photoPlural: 'Fotos',
                    },
                    gallery: {
                        alt: 'Foto von {author}',
                    },
                },
                finder: {
                    toolbar: {
                        back: 'Zur\xFCck',
                        forward: 'Vorw\xE4rts',
                        listView: 'Listenansicht',
                        gridView: 'Rasteransicht',
                        search: 'Suchen',
                    },
                    sidebar: {
                        favorites: 'Favoriten',
                        home: 'Home',
                        computer: 'Computer',
                        recent: 'Zuletzt verwendet',
                        locations: 'Orte',
                        github: 'GitHub Projekte',
                        starred: 'Markiert',
                    },
                    back: 'Zur\xFCck',
                    imageViewer: 'Bildbetrachter',
                    textEditor: 'Texteditor',
                    loadingFiles: 'Dateien werden geladen \u2026',
                    filesLoadError:
                        'Dateien konnten nicht geladen werden. Bitte versuche es sp\xE4ter erneut.',
                    emptyDirectory: 'Keine Dateien in diesem Verzeichnis.',
                    noRepositories: 'Keine \xF6ffentlichen Repositories gefunden.',
                    repositoriesError:
                        'Repos konnten nicht geladen werden. Bitte versuche es sp\xE4ter erneut.',
                    repoDescriptionMissing: 'Keine Beschreibung verf\xFCgbar.',
                    repoUnnamed: 'Unbenanntes Repository',
                    loadingImage: '{name} wird geladen \u2026',
                    imageLoadError: 'Bild konnte nicht geladen werden.',
                    imageLoadErrorRetry:
                        'Das Bild konnte nicht geladen werden. Bitte versuche es sp\xE4ter erneut.',
                    fileLoadError: 'Die Datei konnte nicht geladen werden.',
                    rateLimit: 'GitHub Rate Limit erreicht. Bitte versuche es sp\xE4ter erneut.',
                    pathNotFound: 'Der ausgew\xE4hlte Pfad ist nicht mehr verf\xFCgbar.',
                },
                programs: {
                    default: {
                        label: 'Sucher',
                        infoLabel: '\xDCber Sucher',
                        about: {
                            name: 'Sucher',
                            tagline: 'Dein pers\xF6nlicher Dateimanager.',
                            version: 'Version 1.0',
                            copyright: '\xA9 Marvin Temmen. Alle Rechte vorbehalten.',
                        },
                    },
                    finder: {
                        label: 'Sucher',
                        infoLabel: '\xDCber Sucher',
                        about: {
                            name: 'Sucher',
                            tagline: 'Der innovative Desktop-Dateimanager.',
                            version: 'Version 2.0',
                            copyright: '\xA9 Marvin Temmen. Alle Rechte vorbehalten.',
                        },
                    },
                    projects: {
                        label: 'GitHub Projekte',
                        infoLabel: '\xDCber GitHub Projekte',
                        about: {
                            name: 'GitHub Projekte',
                            tagline: 'Durchsuche deine GitHub-Repositories.',
                            version: 'Version 1.0',
                            copyright: '\xA9 Marvin Temmen. Alle Rechte vorbehalten.',
                        },
                    },
                    settings: {
                        label: 'Systemeinstellungen',
                        infoLabel: '\xDCber Systemeinstellungen',
                        about: {
                            name: 'Systemeinstellungen',
                            tagline: 'Konfiguriere Erscheinungsbild, Accounts und mehr.',
                            version: 'Version 1.0',
                            copyright: '\xA9 Marvin Temmen. Alle Rechte vorbehalten.',
                        },
                    },
                    text: {
                        label: 'Texteditor',
                        infoLabel: '\xDCber Texteditor',
                        about: {
                            name: 'Texteditor',
                            tagline: 'Leichtgewichtiger Editor f\xFCr deine Notizen.',
                            version: 'Version 1.0',
                            copyright: '\xA9 Marvin Temmen. Alle Rechte vorbehalten.',
                        },
                    },
                    image: {
                        label: 'Bildanzeige',
                        infoLabel: '\xDCber Bildanzeige',
                        about: {
                            name: 'Bildanzeige',
                            tagline: 'Betrachte Screenshots und Fotos mit Vorschau.',
                            version: 'Version 1.0',
                            copyright: '\xA9 Marvin Temmen. Alle Rechte vorbehalten.',
                        },
                    },
                    photos: {
                        label: 'Fotos',
                        infoLabel: '\xDCber Fotos',
                        about: {
                            name: 'Fotos',
                            tagline: 'Deine Bilder auf einen Klick.',
                            version: 'Version 1.0',
                            copyright: '\xA9 Marvin Temmen. Alle Rechte vorbehalten.',
                        },
                    },
                    about: {
                        label: '\xDCber Marvin',
                        infoLabel: '\xDCber dieses Fenster',
                        about: {
                            name: '\xDCber Marvin',
                            tagline: 'Erfahre mehr \xFCber Marvin Temmen.',
                            version: 'Version 1.0',
                            copyright: '\xA9 Marvin Temmen. Alle Rechte vorbehalten.',
                        },
                    },
                    launchpad: {
                        label: 'Launchpad',
                        infoLabel: '\xDCber Launchpad',
                        about: {
                            name: 'Launchpad',
                            tagline: 'Starte alle deine Programme.',
                            version: 'Version 1.0',
                            copyright: '\xA9 Marvin Temmen. Alle Rechte vorbehalten.',
                        },
                    },
                    terminal: {
                        label: 'Terminal',
                        infoLabel: '\xDCber Terminal',
                        about: {
                            name: 'Terminal',
                            tagline: 'Kommandozeilenschnittstelle f\xFCr das Portfolio.',
                            version: 'Version 1.0',
                            copyright: '\xA9 Marvin Temmen. Alle Rechte vorbehalten.',
                        },
                    },
                    preview: {
                        label: 'Vorschau',
                        infoLabel: 'Bildvorschau',
                        about: {
                            name: 'Vorschau',
                            tagline: 'Schnelle Bildanzeige',
                            version: '1.0',
                            copyright: '\xA9 2025 Marormur',
                        },
                    },
                },
                textEditor: {
                    title: 'Texteditor',
                    documentTitle: 'Texteditor',
                    documentTitleWithFile: 'Texteditor \u2013 {fileName}',
                    toolbar: {
                        bold: 'Fett',
                        italic: 'Kursiv',
                        underline: 'Unterstrichen',
                        strikeThrough: 'Durchgestrichen',
                        heading1: '\xDCberschrift 1',
                        heading2: '\xDCberschrift 2',
                        heading3: '\xDCberschrift 3',
                        unorderedList: 'Aufz\xE4hlungsliste',
                        orderedList: 'Nummerierte Liste',
                        alignLeft: 'Linksb\xFCndig',
                        alignCenter: 'Zentriert',
                        alignRight: 'Rechtsb\xFCndig',
                        insertLink: 'Link einf\xFCgen',
                        findReplace: 'Suchen & Ersetzen',
                        undo: 'R\xFCckg\xE4ngig',
                        redo: 'Wiederholen',
                        clear: 'Neu',
                        open: '\xD6ffnen',
                        save: 'Speichern',
                    },
                    findReplace: {
                        find: 'Suchen...',
                        replace: 'Ersetzen...',
                        next: 'Weiter',
                        replaceOne: 'Ersetzen',
                        replaceAll: 'Alle ersetzen',
                        close: 'Schlie\xDFen',
                        noMatch: 'Keine \xDCbereinstimmung gefunden',
                        replacedCount: '{count} Vorkommen ersetzt',
                    },
                    status: {
                        loading: 'Lade Datei \u2026',
                        loadingWithLabel: '{label} (l\xE4dt \u2026)',
                        loadError: 'Datei konnte nicht geladen werden.',
                        rateLimit:
                            'GitHub Rate Limit erreicht. Bitte versuche es sp\xE4ter erneut.',
                        wordCount: 'W\xF6rter: {words} | Zeichen: {chars}',
                        position: 'Zeile {line}, Spalte {col}',
                    },
                },
                menu: {
                    sections: {
                        file: 'Ablage',
                        edit: 'Bearbeiten',
                        view: 'Darstellung',
                        window: 'Fenster',
                        help: 'Hilfe',
                    },
                    finder: {
                        newWindow: 'Neues Sucher-Fenster',
                        reload: 'Sucher neu laden',
                        close: 'Fenster schlie\xDFen',
                        help: 'Sucher-Hilfe anzeigen',
                    },
                    settings: {
                        close: 'Fenster schlie\xDFen',
                        help: 'Einstellungs-Hilfe anzeigen',
                    },
                    text: {
                        newFile: 'Neu',
                        open: '\xD6ffnen \u2026',
                        save: 'Speichern',
                        undo: 'R\xFCckg\xE4ngig',
                        redo: 'Wiederholen',
                        cut: 'Ausschneiden',
                        copy: 'Kopieren',
                        paste: 'Einf\xFCgen',
                        selectAll: 'Alles ausw\xE4hlen',
                        toggleWrap: 'Zeilenumbruch umschalten',
                        help: 'Texteditor-Hilfe anzeigen',
                    },
                    image: {
                        openInTab: 'Bild in neuem Tab \xF6ffnen',
                        saveImage: 'Bild sichern \u2026',
                        close: 'Fenster schlie\xDFen',
                        help: 'Bildbetrachter-Hilfe anzeigen',
                    },
                    terminal: {
                        newWindow: 'Neues Terminal-Fenster',
                        clear: 'Terminal l\xF6schen',
                        close: 'Fenster schlie\xDFen',
                        help: 'Terminal-Hilfe anzeigen',
                        newTab: 'Neuer Tab',
                        duplicateTab: 'Tab duplizieren',
                        closeTab: 'Tab schlie\xDFen',
                        closeWindow: 'Terminal-Fenster schlie\xDFen',
                        copy: 'Kopieren',
                        paste: 'Einf\xFCgen',
                        selectAll: 'Alles ausw\xE4hlen',
                    },
                    about: {
                        close: 'Fenster schlie\xDFen',
                        help: '\xDCber Marvin',
                    },
                    programInfo: {
                        close: 'Fenster schlie\xDFen',
                    },
                    window: {
                        minimize: 'Minimieren',
                        zoom: 'Zoomen',
                        bringToFront: 'Alle nach vorne bringen',
                        close: 'Fenster schlie\xDFen',
                        closeAll: 'Alle schlie\xDFen',
                        newInstance: 'Neue Instanz',
                        newFinder: 'Neuer Sucher',
                        newTerminal: 'Neues Terminal',
                        newEditor: 'Neuer Editor',
                        closeAllConfirm: 'Alle {count} {type}-Instanzen schlie\xDFen?',
                    },
                    session: {
                        export: 'Session exportieren \u2026',
                        import: 'Session importieren \u2026',
                        exportSuccess: 'Session erfolgreich exportiert',
                        importSuccess: 'Session erfolgreich importiert',
                        importError: 'Session konnte nicht importiert werden',
                        noSession: 'Keine Session zum Exportieren vorhanden',
                    },
                    help: {
                        showHelp: 'Programmhilfe anzeigen',
                    },
                },
                settingsPage: {
                    title: 'Einstellungen',
                    nav: {
                        general: '\u{1F464} Allgemein',
                        display: '\u{1F5A5}\uFE0F Darstellung',
                        language: '\u{1F310} Sprache',
                    },
                    general: {
                        title: 'Allgemein',
                        name: 'Marvin Temmen',
                        birth: 'M\xE4rz 1999',
                        locationLabel: 'Wohnort',
                        locationValue: 'Deutschland',
                        jobLabel: 'Beruf',
                        jobValue: 'Softwareentwickler',
                        employerLabel: 'Arbeitgeber',
                        employerValue: 'WinWorker',
                        copyright: '\xA9 2025 Marvin T. \u2014 Alle Rechte vorbehalten.',
                    },
                    display: {
                        title: 'Darstellungsoptionen',
                        description:
                            'Passe an, wie der Desktop mit hellem und dunklem Design umgeht.',
                        legend: 'Darkmode',
                        options: {
                            system: {
                                label: 'System',
                                description: 'Folgt den aktuellen Systemeinstellungen.',
                            },
                            light: {
                                label: 'Hell',
                                description: 'Bleibt immer im hellen Erscheinungsbild.',
                            },
                            dark: {
                                label: 'Dunkel',
                                description: 'Bleibt immer im dunklen Erscheinungsbild.',
                            },
                        },
                    },
                    language: {
                        title: 'Sprache',
                        description:
                            'W\xE4hle, in welcher Sprache die Oberfl\xE4che angezeigt wird.',
                        legend: 'Bevorzugte Sprache',
                        options: {
                            system: {
                                label: 'System',
                                description: 'Verwendet automatisch die Sprache deines Systems.',
                            },
                            de: {
                                label: 'Deutsch',
                                description: 'Zeigt Inhalte immer auf Deutsch.',
                            },
                            en: {
                                label: 'Englisch',
                                description: 'Zeigt Inhalte immer auf Englisch.',
                            },
                        },
                    },
                },
                projectsPage: {
                    title: 'Meine GitHub Projekte',
                    empty: 'Keine \xF6ffentlichen Repositories gefunden.',
                    repoUnnamed: 'Unbenanntes Repository',
                    noDescription: 'Keine Beschreibung verf\xFCgbar.',
                    error: 'Repos konnten nicht geladen werden. Bitte versuche es sp\xE4ter erneut.',
                },
                preview: {
                    noImage: 'Kein Bild ausgew\xE4hlt',
                    zoomIn: 'Vergr\xF6\xDFern',
                    zoomOut: 'Verkleinern',
                    next: 'N\xE4chstes Bild',
                    prev: 'Vorheriges Bild',
                    dragDrop: 'Bild hierher ziehen',
                    contextMenu: 'Kontextmen\xFC',
                },
            };
        },
    });

    // src/ts/i18n/en.ts
    var en;
    var init_en = __esm({
        'src/ts/i18n/en.ts'() {
            'use strict';
            en = {
                context: {
                    menuLabel: 'Context menu',
                    open: 'Open',
                    openFinder: 'Open Finder',
                    openTextEditor: 'Open Text editor',
                    openProjects: 'Open Projects',
                    openSettings: 'System settings\u2026',
                    toggleDarkMode: 'Toggle dark mode',
                    about: 'About Marvin',
                    image: {
                        openInTab: 'Open image in new tab',
                        save: 'Save image\u2026',
                    },
                    finder: {
                        openItem: 'Open',
                        getInfo: 'Get Info',
                        refresh: 'Refresh',
                        newFolder: 'New Folder',
                        viewList: 'View as List',
                        viewGrid: 'View as Grid',
                        sortByName: 'Sort by Name',
                        sortByDate: 'Sort by Date',
                        sortBySize: 'Sort by Size',
                    },
                },
                common: {
                    close: 'Close',
                    system: 'System',
                    german: 'German',
                    english: 'English',
                },
                header: {
                    profile: {
                        about: 'About Marvin',
                        resetLayout: 'Reset windows',
                        settings: 'System settings',
                        linkedin: 'LinkedIn',
                    },
                    program: {
                        close: 'Close program',
                    },
                },
                desktop: {
                    finder: 'Finder',
                    projects: 'Projects',
                    github: 'GitHub Projects',
                    text: 'Text editor',
                    image: 'Image viewer',
                    photos: 'Photos',
                    settings: 'System settings',
                    about: 'About Marvin',
                    launchpad: 'Launchpad',
                    terminal: 'Terminal',
                },
                dock: {
                    finder: 'Finder',
                    projects: 'GitHub Projects',
                    text: 'Text editor',
                    image: 'Image viewer',
                    settings: 'System settings',
                    launchpad: 'Apps',
                    terminal: 'Terminal',
                },
                menubar: {
                    appleMenu: {
                        label: 'Apple menu',
                    },
                    applicationMenus: 'Application menus',
                    controlCenter: {
                        label: 'Control Center',
                        quickActions: 'Quick Actions',
                        quickActionsAria: 'Quick Actions',
                        brightness: 'Brightness',
                        volume: 'Volume',
                    },
                    toggles: {
                        wifi: 'Wi-Fi',
                        wifiStatus: 'Wi-Fi status',
                        bluetooth: 'Bluetooth',
                        bluetoothStatus: 'Bluetooth status',
                        focus: 'Focus mode',
                        darkMode: 'Dark mode',
                    },
                    wifi: {
                        preferredNetworks: 'Preferred networks',
                    },
                    bluetooth: {
                        devices: 'Devices',
                        airpods: "Marvin's AirPods Pro",
                        keyboard: 'Magic Keyboard',
                        speaker: 'HomeSpeaker',
                    },
                    sound: {
                        label: 'Sound',
                        outputDevices: 'Output devices',
                        devices: {
                            speakers: 'MacBook speakers',
                            airpods: "Marvin's AirPods Pro",
                            display: 'External display',
                        },
                    },
                    networks: {
                        home: 'HomeLAN',
                        office: 'Office',
                        hotspot: "Marvin's iPhone",
                    },
                    state: {
                        on: 'On',
                        off: 'Off',
                        active: 'Active',
                        connected: 'Connected',
                        ready: 'Ready',
                        notConnected: 'Not connected',
                        hotspot: 'Personal hotspot',
                        automatic: 'Automatic',
                    },
                    actions: {
                        networkSettings: 'Network settings\u2026',
                        bluetoothSettings: 'Bluetooth settings\u2026',
                        soundSettings: 'Sound settings\u2026',
                        spotlight: 'Spotlight',
                        siri: 'Siri',
                    },
                    battery: {
                        label: 'Battery status',
                        fullLabel: 'Battery fully charged',
                    },
                },
                modals: {
                    projects: {
                        title: 'Projects',
                        repositories: 'Repositories',
                        placeholder: 'Select a repository to browse its files.',
                    },
                    about: {
                        title: 'About Marvin',
                        birth: 'March 1999',
                        locationLabel: 'Location',
                        locationValue: 'Germany',
                        jobLabel: 'Occupation',
                        jobValue: 'Software engineer',
                        employerLabel: 'Employer',
                        employerValue: 'WinWorker',
                        moreButton: 'More details\u2026',
                        copyright: '\xA9 2025 Marvin T. \u2014 All rights reserved.',
                    },
                    settings: {
                        title: 'System settings',
                    },
                    text: {
                        title: 'Text editor',
                    },
                    image: {
                        title: 'Image viewer',
                        placeholder: 'Open an image file from Finder to preview it.',
                    },
                    finder: {
                        title: 'Finder',
                    },
                    photos: {
                        title: 'Photos',
                        badge: 'PICSUM CLOUD',
                        sidebar: {
                            library: 'Library',
                            filters: 'Filters',
                            refresh: 'Reload',
                            sourceNote:
                                'Source: Lorem Picsum \u2014 curated random photo collections.',
                            items: {
                                all: 'All Photos',
                                favorites: 'Favorites',
                                landscape: 'Landscape',
                                portrait: 'Portrait',
                                square: 'Square',
                            },
                        },
                        segments: {
                            moments: 'Moments',
                            collections: 'Collections',
                            years: 'Years',
                        },
                        search: {
                            placeholder: 'Search by author',
                            clear: 'Clear search',
                        },
                        status: {
                            countPlaceholder: '\u2013 Photos',
                            loading: 'Loading photos\u2026',
                            count: '{count} {label} \u2022 {segment}',
                        },
                        errors: {
                            heading: 'Loading error',
                            description: 'Please check your connection and try again.',
                            detailImage: 'The photo could not be loaded.',
                        },
                        buttons: {
                            retry: 'Try again',
                        },
                        empty: {
                            title: 'No photos found',
                            description: 'Adjust search or filters to see more results.',
                        },
                        placeholder: 'Select a photo to view details.',
                        detail: {
                            titleFallback: 'Photo',
                            favoriteAdd: 'Add to favorites',
                            favoriteRemove: 'Remove favorite',
                            favoriteUnavailable: 'Unavailable',
                            download: 'Download',
                            open: 'View on Lorem Picsum',
                            loader: 'Loading photo\u2026',
                            prev: 'Previous photo',
                            next: 'Next photo',
                            imageAlt: 'Selected photo',
                            unknownPhoto: 'Unknown photo',
                            unknownPhotographer: 'Unknown photographer',
                            externalLabel: 'External photo',
                            dimensions: 'Resolution: {width} \xD7 {height}px',
                            downloadFilename: 'photo-{id}.jpg',
                            externalCounter: 'External image',
                            counter: '{index} of {total}',
                            externalFile: 'External file',
                        },
                        orientations: {
                            landscape: 'Landscape',
                            portrait: 'Portrait',
                            square: 'Square',
                        },
                        collections: {
                            landscape: 'Landscapes',
                            portrait: 'Portraits',
                            square: 'Squares',
                        },
                        labels: {
                            photoSingular: 'Photo',
                            photoPlural: 'Photos',
                        },
                        gallery: {
                            alt: 'Photo by {author}',
                        },
                    },
                    programInfo: {
                        title: 'About this app',
                    },
                    launchpad: {
                        title: 'Launchpad',
                        searchPlaceholder: 'Search apps',
                    },
                    terminal: {
                        title: 'Terminal',
                    },
                },
                programs: {
                    default: {
                        label: 'Finder',
                        infoLabel: 'About Finder',
                        about: {
                            name: 'Finder',
                            tagline: 'Your personal file manager.',
                            version: 'Version 1.0',
                            copyright: '\xA9 Marvin Temmen. All rights reserved.',
                        },
                    },
                    finder: {
                        label: 'Finder',
                        infoLabel: 'About Finder',
                        about: {
                            name: 'Finder',
                            tagline: 'The innovative desktop file manager.',
                            version: 'Version 2.0',
                            copyright: '\xA9 Marvin Temmen. All rights reserved.',
                        },
                    },
                    projects: {
                        label: 'GitHub Projects',
                        infoLabel: 'About GitHub Projects',
                        about: {
                            name: 'GitHub Projects',
                            tagline: 'Browse your GitHub repositories.',
                            version: 'Version 1.0',
                            copyright: '\xA9 Marvin Temmen. All rights reserved.',
                        },
                    },
                    settings: {
                        label: 'System settings',
                        infoLabel: 'About System settings',
                        about: {
                            name: 'System settings',
                            tagline: 'Configure appearance, accounts, and more.',
                            version: 'Version 1.0',
                            copyright: '\xA9 Marvin Temmen. All rights reserved.',
                        },
                    },
                    text: {
                        label: 'Text editor',
                        infoLabel: 'About Text editor',
                        about: {
                            name: 'Text editor',
                            tagline: 'Lightweight editor for your notes.',
                            version: 'Version 1.0',
                            copyright: '\xA9 Marvin Temmen. All rights reserved.',
                        },
                    },
                    image: {
                        label: 'Image viewer',
                        infoLabel: 'About Image viewer',
                        about: {
                            name: 'Image viewer',
                            tagline: 'Preview screenshots and photos with ease.',
                            version: 'Version 1.0',
                            copyright: '\xA9 Marvin Temmen. All rights reserved.',
                        },
                    },
                    photos: {
                        label: 'Photos',
                        infoLabel: 'About Photos',
                        about: {
                            name: 'Photos',
                            tagline: 'Your images at a click.',
                            version: 'Version 1.0',
                            copyright: '\xA9 Marvin Temmen. All rights reserved.',
                        },
                    },
                    about: {
                        label: 'About Marvin',
                        infoLabel: 'About this window',
                        about: {
                            name: 'About Marvin',
                            tagline: 'Learn more about Marvin Temmen.',
                            version: 'Version 1.0',
                            copyright: '\xA9 Marvin Temmen. All rights reserved.',
                        },
                    },
                    launchpad: {
                        label: 'Launchpad',
                        infoLabel: 'About Launchpad',
                        about: {
                            name: 'Launchpad',
                            tagline: 'Launch all your apps.',
                            version: 'Version 1.0',
                            copyright: '\xA9 Marvin Temmen. All rights reserved.',
                        },
                    },
                    terminal: {
                        label: 'Terminal',
                        infoLabel: 'About Terminal',
                        about: {
                            name: 'Terminal',
                            tagline: 'Command-line interface for the portfolio.',
                            version: 'Version 1.0',
                            copyright: '\xA9 Marvin Temmen. All rights reserved.',
                        },
                    },
                    preview: {
                        label: 'Preview',
                        infoLabel: 'Image Preview',
                        about: {
                            name: 'Preview',
                            tagline: 'Quick image viewer',
                            version: '1.0',
                            copyright: '\xA9 2025 Marormur',
                        },
                    },
                },
                finder: {
                    toolbar: {
                        back: 'Back',
                        forward: 'Forward',
                        listView: 'List view',
                        gridView: 'Grid view',
                        search: 'Search',
                    },
                    sidebar: {
                        favorites: 'Favorites',
                        home: 'Home',
                        computer: 'Computer',
                        recent: 'Recent',
                        locations: 'Locations',
                        github: 'GitHub Projects',
                        starred: 'Starred',
                    },
                    back: 'Back',
                    imageViewer: 'Image viewer',
                    textEditor: 'Text editor',
                    loadingFiles: 'Loading files\u2026',
                    filesLoadError: 'Files could not be loaded. Please try again later.',
                    emptyDirectory: 'No files found in this directory.',
                    noRepositories: 'No public repositories found.',
                    repositoriesError: 'Repositories could not be loaded. Please try again later.',
                    repoDescriptionMissing: 'No description available.',
                    repoUnnamed: 'Untitled repository',
                    loadingImage: 'Loading {name}\u2026',
                    imageLoadError: 'Could not load the image.',
                    imageLoadErrorRetry: 'The image could not be loaded. Please try again later.',
                    fileLoadError: 'The file could not be loaded. Please try again later.',
                    rateLimit: 'GitHub rate limit reached. Please try again later.',
                    pathNotFound: 'The selected path is no longer available.',
                },
                textEditor: {
                    title: 'Text editor',
                    documentTitle: 'Text editor',
                    documentTitleWithFile: 'Text editor \u2013 {fileName}',
                    toolbar: {
                        bold: 'Bold',
                        italic: 'Italic',
                        underline: 'Underline',
                        strikeThrough: 'Strikethrough',
                        heading1: 'Heading 1',
                        heading2: 'Heading 2',
                        heading3: 'Heading 3',
                        unorderedList: 'Bullet list',
                        orderedList: 'Numbered list',
                        alignLeft: 'Align left',
                        alignCenter: 'Center',
                        alignRight: 'Align right',
                        insertLink: 'Insert link',
                        findReplace: 'Find & Replace',
                        undo: 'Undo',
                        redo: 'Redo',
                        clear: 'New',
                        open: 'Open',
                        save: 'Save',
                    },
                    findReplace: {
                        find: 'Find...',
                        replace: 'Replace...',
                        next: 'Next',
                        replaceOne: 'Replace',
                        replaceAll: 'Replace all',
                        close: 'Close',
                        noMatch: 'No match found',
                        replacedCount: 'Replaced {count} occurrence(s)',
                    },
                    status: {
                        loading: 'Loading file\u2026',
                        loadingWithLabel: '{label} (loading\u2026)',
                        loadError: 'The file could not be loaded.',
                        rateLimit: 'GitHub rate limit was reached. Please try again later.',
                        wordCount: 'Words: {words} | Characters: {chars}',
                        position: 'Line {line}, Col {col}',
                    },
                },
                menu: {
                    sections: {
                        file: 'File',
                        edit: 'Edit',
                        view: 'View',
                        window: 'Window',
                        help: 'Help',
                    },
                    finder: {
                        newWindow: 'Create Finder Window',
                        reload: 'Reload Finder',
                        close: 'Close window',
                        help: 'Show Finder help',
                    },
                    settings: {
                        close: 'Close window',
                        help: 'Show settings help',
                    },
                    text: {
                        newFile: 'New',
                        open: 'Open\u2026',
                        save: 'Save',
                        undo: 'Undo',
                        redo: 'Redo',
                        cut: 'Cut',
                        copy: 'Copy',
                        paste: 'Paste',
                        selectAll: 'Select all',
                        toggleWrap: 'Toggle line wrap',
                        help: 'Show text editor help',
                    },
                    image: {
                        openInTab: 'Open image in new tab',
                        saveImage: 'Save image\u2026',
                        close: 'Close window',
                        help: 'Show image viewer help',
                    },
                    terminal: {
                        newWindow: 'New Terminal window',
                        clear: 'Clear Terminal',
                        close: 'Close window',
                        help: 'Show Terminal help',
                        newTab: 'New Tab',
                        duplicateTab: 'Duplicate Tab',
                        closeTab: 'Close Tab',
                        closeWindow: 'Close Terminal window',
                        copy: 'Copy',
                        paste: 'Paste',
                        selectAll: 'Select all',
                    },
                    about: {
                        close: 'Close window',
                        help: 'About Marvin',
                    },
                    programInfo: {
                        close: 'Close window',
                    },
                    window: {
                        minimize: 'Minimize',
                        zoom: 'Zoom',
                        bringToFront: 'Bring all to front',
                        close: 'Close window',
                        closeAll: 'Close All',
                        newInstance: 'New Instance',
                        newFinder: 'New Finder',
                        newTerminal: 'New Terminal',
                        newEditor: 'New Editor',
                        closeAllConfirm: 'Close all {count} {type} instances?',
                    },
                    session: {
                        export: 'Export Session\u2026',
                        import: 'Import Session\u2026',
                        exportSuccess: 'Session successfully exported',
                        importSuccess: 'Session successfully imported',
                        importError: 'Failed to import session',
                        noSession: 'No session available to export',
                    },
                    help: {
                        showHelp: 'Show app help',
                    },
                },
                settingsPage: {
                    title: 'Settings',
                    nav: {
                        general: '\u{1F464} General',
                        display: '\u{1F5A5}\uFE0F Appearance',
                        language: '\u{1F310} Language',
                    },
                    general: {
                        title: 'General',
                        name: 'Marvin Temmen',
                        birth: 'March 1999',
                        locationLabel: 'Location',
                        locationValue: 'Germany',
                        jobLabel: 'Occupation',
                        jobValue: 'Software engineer',
                        employerLabel: 'Employer',
                        employerValue: 'WinWorker',
                        copyright: '\xA9 2025 Marvin T. \u2014 All rights reserved.',
                    },
                    display: {
                        title: 'Appearance options',
                        description: 'Adjust how the desktop handles light and dark mode.',
                        legend: 'Dark mode',
                        options: {
                            system: {
                                label: 'System',
                                description: 'Follows the current system setting.',
                            },
                            light: {
                                label: 'Light',
                                description: 'Always stays in light appearance.',
                            },
                            dark: {
                                label: 'Dark',
                                description: 'Always stays in dark appearance.',
                            },
                        },
                    },
                    language: {
                        title: 'Language',
                        description: 'Choose which language the interface uses.',
                        legend: 'Preferred language',
                        options: {
                            system: {
                                label: 'System',
                                description: 'Automatically uses your system language.',
                            },
                            de: {
                                label: 'German',
                                description: 'Always display content in German.',
                            },
                            en: {
                                label: 'English',
                                description: 'Always display content in English.',
                            },
                        },
                    },
                },
                projectsPage: {
                    title: 'My GitHub projects',
                    empty: 'No public repositories found.',
                    repoUnnamed: 'Untitled repository',
                    noDescription: 'No description available.',
                    error: 'Repositories could not be loaded. Please try again later.',
                },
                preview: {
                    noImage: 'No image selected',
                    zoomIn: 'Zoom in',
                    zoomOut: 'Zoom out',
                    next: 'Next image',
                    prev: 'Previous image',
                    dragDrop: 'Drag image here',
                    contextMenu: 'Context menu',
                },
            };
        },
    });

    // src/ts/services/i18n.ts
    function normalizeLanguage(input) {
        if (!input) return null;
        const value = String(input).trim().toLowerCase();
        if (!value) return null;
        const base = value.split(/[-_]/)[0] || '';
        return SUPPORTED_LANGUAGES.includes(base) ? base : null;
    }
    function parsePreference(value) {
        if (value === null || value === void 0) return 'system';
        const normalized = String(value).trim();
        return LANGUAGE_OPTIONS.includes(normalized) ? normalized : 'system';
    }
    function getBrowserLanguages() {
        const langs = [];
        if (Array.isArray(navigator.languages)) {
            langs.push(...navigator.languages);
        }
        if (navigator.language) {
            langs.push(navigator.language);
        }
        const navWithUserLang = navigator;
        if (navWithUserLang.userLanguage) {
            langs.push(navWithUserLang.userLanguage);
        }
        return langs.length ? langs : ['en'];
    }
    function detectSystemLanguage() {
        const candidates = getBrowserLanguages();
        for (const candidate of candidates) {
            const normalized = normalizeLanguage(candidate);
            if (normalized) {
                return normalized;
            }
        }
        return FALLBACK_LANGUAGE;
    }
    function resolveActiveLanguage(pref) {
        if (pref === 'system') {
            return detectSystemLanguage();
        }
        return SUPPORTED_LANGUAGES.includes(pref) ? pref : FALLBACK_LANGUAGE;
    }
    function setDocumentLanguage(lang) {
        if (typeof document !== 'undefined' && document.documentElement) {
            document.documentElement.lang = lang;
        }
    }
    function formatTemplate(template, params) {
        if (typeof template !== 'string') {
            return template;
        }
        if (!params || typeof params !== 'object') {
            return template;
        }
        return template.replace(/\{([^}]+)\}/g, (match, token) => {
            const key = token.trim();
            return Object.prototype.hasOwnProperty.call(params, key) ? String(params[key]) : match;
        });
    }
    function resolveKey(lang, key) {
        const segments = key.split('.');
        let current = translations[lang];
        for (const segment of segments) {
            if (!current || typeof current !== 'object' || !(segment in current)) {
                return void 0;
            }
            current = current[segment];
        }
        return current;
    }
    function translate(key, params = {}, options = {}) {
        if (!key) return '';
        const lang = options.language || activeLanguage;
        let value = resolveKey(lang, key);
        if (value === void 0 && lang !== FALLBACK_LANGUAGE) {
            value = resolveKey(FALLBACK_LANGUAGE, key);
        }
        if (value === void 0) {
            return options.fallback !== void 0 ? options.fallback : key;
        }
        if (typeof value === 'string') {
            return formatTemplate(value, params);
        }
        return String(value);
    }
    function parseParams(element) {
        const paramsAttr = element.getAttribute('data-i18n-params');
        if (!paramsAttr) {
            return void 0;
        }
        try {
            return JSON.parse(paramsAttr);
        } catch (err) {
            console.warn('Could not parse data-i18n-params:', err);
            return void 0;
        }
    }
    function translateElement(element) {
        if (!(element instanceof Element)) {
            return;
        }
        const params = parseParams(element) || {};
        const textKey = element.getAttribute('data-i18n');
        if (textKey) {
            element.textContent = translate(textKey, params);
        }
        const htmlKey = element.getAttribute('data-i18n-html');
        if (htmlKey) {
            element.innerHTML = translate(htmlKey, params);
        }
        Array.from(element.attributes).forEach(attr => {
            if (!attr.name.startsWith('data-i18n-')) return;
            if (attr.name === 'data-i18n' || attr.name === 'data-i18n-html') return;
            const targetAttr = attr.name.substring('data-i18n-'.length);
            if (!targetAttr) return;
            element.setAttribute(targetAttr, translate(attr.value, params));
        });
    }
    function applyTranslations(root = document) {
        if (!root) return;
        const base = root === document ? document.documentElement : root;
        if (!base || !(base instanceof Element)) return;
        translateElement(base);
        const elements = base.querySelectorAll('*');
        elements.forEach(translateElement);
    }
    function dispatchLanguageEvent() {
        if (typeof window === 'undefined') return;
        const event = new CustomEvent('languagePreferenceChange', {
            detail: {
                preference: languagePreference,
                language: activeLanguage,
            },
        });
        window.dispatchEvent(event);
    }
    function refreshActiveLanguage(emitEvent = true) {
        const nextLanguage = resolveActiveLanguage(languagePreference);
        const languageChanged = nextLanguage !== activeLanguage;
        activeLanguage = nextLanguage;
        setDocumentLanguage(activeLanguage);
        applyTranslations(document);
        if (emitEvent || languageChanged) {
            dispatchLanguageEvent();
        }
    }
    function setLanguagePreference(pref) {
        const normalized = parsePreference(pref);
        if (normalized === languagePreference) {
            refreshActiveLanguage(true);
            return activeLanguage;
        }
        languagePreference = normalized;
        if (typeof localStorage !== 'undefined') {
            if (normalized === 'system') {
                localStorage.setItem(LANGUAGE_PREFERENCE_KEY, 'system');
            } else {
                localStorage.setItem(LANGUAGE_PREFERENCE_KEY, normalized);
            }
        }
        refreshActiveLanguage(true);
        return activeLanguage;
    }
    function getLanguagePreference() {
        return languagePreference;
    }
    function getActiveLanguage() {
        return activeLanguage;
    }
    var LANGUAGE_PREFERENCE_KEY,
        SUPPORTED_LANGUAGES,
        LANGUAGE_OPTIONS,
        FALLBACK_LANGUAGE,
        translations,
        languagePreference,
        activeLanguage,
        appI18n;
    var init_i18n = __esm({
        'src/ts/services/i18n.ts'() {
            'use strict';
            init_de();
            init_en();
            LANGUAGE_PREFERENCE_KEY = 'languagePreference';
            SUPPORTED_LANGUAGES = ['de', 'en'];
            LANGUAGE_OPTIONS = ['system', ...SUPPORTED_LANGUAGES];
            FALLBACK_LANGUAGE = 'en';
            translations = {
                de,
                en,
            };
            languagePreference = parsePreference(
                typeof localStorage !== 'undefined'
                    ? localStorage.getItem(LANGUAGE_PREFERENCE_KEY)
                    : null
            );
            activeLanguage = resolveActiveLanguage(languagePreference);
            if (typeof window !== 'undefined') {
                window.addEventListener('languagechange', () => {
                    if (languagePreference === 'system') {
                        refreshActiveLanguage(true);
                    }
                });
                window.addEventListener('storage', event => {
                    if (event.key !== LANGUAGE_PREFERENCE_KEY) {
                        return;
                    }
                    const newPreference = parsePreference(event.newValue);
                    languagePreference = newPreference;
                    refreshActiveLanguage(true);
                });
            }
            if (typeof document !== 'undefined') {
                setDocumentLanguage(activeLanguage);
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () =>
                        applyTranslations(document)
                    );
                } else {
                    applyTranslations(document);
                }
            }
            appI18n = {
                translate,
                applyTranslations,
                setLanguagePreference,
                getLanguagePreference,
                getActiveLanguage,
                translations,
                supportedLanguages: SUPPORTED_LANGUAGES,
                languageOptions: LANGUAGE_OPTIONS,
            };
            if (typeof window !== 'undefined') {
                window.appI18n = appI18n;
            }
        },
    });

    // src/ts/ui/dom-utils.ts
    var dom_utils_exports = {};
    __export(dom_utils_exports, {
        getById: () => getById,
        hide: () => hide,
        hideAll: () => hideAll,
        isVisible: () => isVisible,
        query: () => query,
        queryAll: () => queryAll,
        setVisibility: () => setVisibility,
        show: () => show,
        showAll: () => showAll,
        toggle: () => toggle,
    });
    function show(element) {
        if (!element) return;
        element.classList.remove('hidden');
    }
    function hide(element) {
        if (!element) return;
        element.classList.add('hidden');
    }
    function toggle(element, visible) {
        if (!element) return;
        if (visible === void 0) {
            element.classList.toggle('hidden');
        } else {
            element.classList.toggle('hidden', !visible);
        }
    }
    function isVisible(element) {
        if (!element) return false;
        return !element.classList.contains('hidden');
    }
    function setVisibility(element, visible) {
        if (!element) return;
        element.classList.toggle('hidden', !visible);
    }
    function showAll(elements) {
        elements.forEach(show);
    }
    function hideAll(elements) {
        elements.forEach(hide);
    }
    function getById(id) {
        return document.getElementById(id);
    }
    function query(selector, parent = document) {
        return parent.querySelector(selector);
    }
    function queryAll(selector, parent = document) {
        return parent.querySelectorAll(selector);
    }
    var init_dom_utils = __esm({
        'src/ts/ui/dom-utils.ts'() {
            'use strict';
            if (typeof window !== 'undefined') {
                window.DOMUtils = {
                    show,
                    hide,
                    toggle,
                    isVisible,
                    setVisibility,
                    showAll,
                    hideAll,
                    getById,
                    query,
                    queryAll,
                };
            }
            console.log('\u2705 DOMUtils loaded');
        },
    });

    // src/ts/core/constants.ts
    var THEME_PREFERENCE_KEY,
        VALID_THEME_PREFERENCES,
        FINDER_STATE_STORAGE_KEY,
        OPEN_WINDOWS_KEY,
        WINDOW_POSITIONS_KEY,
        MODAL_IDS,
        TRANSIENT_MODAL_IDS,
        BASE_Z_INDEX,
        MENUBAR_Z_INDEX,
        DOCK_Z_INDEX,
        MIN_WINDOW_WIDTH,
        MIN_WINDOW_HEIGHT,
        DEFAULT_WINDOW_WIDTH,
        DEFAULT_WINDOW_HEIGHT,
        DOCK_MIN_HEIGHT,
        DOCK_MAX_HEIGHT,
        DOCK_MAGNIFICATION_SCALE,
        DOCK_MAGNIFICATION_RANGE,
        DESKTOP_ICON_SIZE,
        DESKTOP_ICON_SPACING,
        RUBBERBAND_MIN_DISTANCE,
        WINDOW_ANIMATION_DURATION,
        DOCK_ANIMATION_DURATION,
        MENU_ANIMATION_DURATION,
        GITHUB_CACHE_DURATION,
        GITHUB_API_BASE,
        SNAP_THRESHOLD,
        SNAP_SIDES,
        APP_CONSTANTS;
    var init_constants = __esm({
        'src/ts/core/constants.ts'() {
            'use strict';
            THEME_PREFERENCE_KEY = 'themePreference';
            VALID_THEME_PREFERENCES = ['system', 'light', 'dark'];
            FINDER_STATE_STORAGE_KEY = 'finderState';
            OPEN_WINDOWS_KEY = 'openWindows';
            WINDOW_POSITIONS_KEY = 'windowPositions';
            MODAL_IDS = [
                'projects-modal',
                'about-modal',
                'settings-modal',
                'text-modal',
                'terminal-modal',
                'image-modal',
                'program-info-modal',
            ];
            TRANSIENT_MODAL_IDS = /* @__PURE__ */ new Set(['program-info-modal']);
            BASE_Z_INDEX = 1e3;
            MENUBAR_Z_INDEX = 1e4;
            DOCK_Z_INDEX = 1e4;
            MIN_WINDOW_WIDTH = 240;
            MIN_WINDOW_HEIGHT = 160;
            DEFAULT_WINDOW_WIDTH = 600;
            DEFAULT_WINDOW_HEIGHT = 400;
            DOCK_MIN_HEIGHT = 48;
            DOCK_MAX_HEIGHT = 96;
            DOCK_MAGNIFICATION_SCALE = 1.5;
            DOCK_MAGNIFICATION_RANGE = 100;
            DESKTOP_ICON_SIZE = 64;
            DESKTOP_ICON_SPACING = 24;
            RUBBERBAND_MIN_DISTANCE = 10;
            WINDOW_ANIMATION_DURATION = 200;
            DOCK_ANIMATION_DURATION = 150;
            MENU_ANIMATION_DURATION = 100;
            GITHUB_CACHE_DURATION = 5 * 60 * 1e3;
            GITHUB_API_BASE = 'https://api.github.com';
            SNAP_THRESHOLD = 100;
            SNAP_SIDES = ['left', 'right'];
            APP_CONSTANTS = {
                THEME_PREFERENCE_KEY,
                VALID_THEME_PREFERENCES,
                FINDER_STATE_STORAGE_KEY,
                OPEN_WINDOWS_KEY,
                WINDOW_POSITIONS_KEY,
                MODAL_IDS,
                TRANSIENT_MODAL_IDS,
                BASE_Z_INDEX,
                MENUBAR_Z_INDEX,
                DOCK_Z_INDEX,
                MIN_WINDOW_WIDTH,
                MIN_WINDOW_HEIGHT,
                DEFAULT_WINDOW_WIDTH,
                DEFAULT_WINDOW_HEIGHT,
                DOCK_MIN_HEIGHT,
                DOCK_MAX_HEIGHT,
                DOCK_MAGNIFICATION_SCALE,
                DOCK_MAGNIFICATION_RANGE,
                DESKTOP_ICON_SIZE,
                DESKTOP_ICON_SPACING,
                RUBBERBAND_MIN_DISTANCE,
                WINDOW_ANIMATION_DURATION,
                DOCK_ANIMATION_DURATION,
                MENU_ANIMATION_DURATION,
                GITHUB_CACHE_DURATION,
                GITHUB_API_BASE,
                SNAP_THRESHOLD,
                SNAP_SIDES,
            };
            if (typeof window !== 'undefined') {
                window.APP_CONSTANTS = APP_CONSTANTS;
            }
        },
    });

    // src/ts/core/logger.ts
    var LOG_LEVELS, LOG_COLORS, Logger, logger, logger_default;
    var init_logger = __esm({
        'src/ts/core/logger.ts'() {
            'use strict';
            LOG_LEVELS = {
                ERROR: 0,
                WARN: 1,
                INFO: 2,
                DEBUG: 3,
                TRACE: 4,
            };
            LOG_COLORS = {
                ERROR: '#ff0000',
                WARN: '#ff9800',
                INFO: '#2196f3',
                DEBUG: '#9c27b0',
                TRACE: '#607d8b',
            };
            Logger = class {
                constructor() {
                    this.level = this.isDevelopment() ? LOG_LEVELS.TRACE : LOG_LEVELS.WARN;
                    this.enabledCategories = /* @__PURE__ */ new Set(['*']);
                    this.format = 'compact';
                }
                isDevelopment() {
                    try {
                        return (
                            location.hostname === 'localhost' ||
                            location.hostname === '127.0.0.1' ||
                            location.port !== ''
                        );
                    } catch {
                        return false;
                    }
                }
                setLevel(level) {
                    var _a;
                    if (typeof level === 'string') {
                        this.level =
                            (_a = LOG_LEVELS[level.toUpperCase()]) != null ? _a : LOG_LEVELS.INFO;
                    } else {
                        this.level = level;
                    }
                }
                enableCategory(category) {
                    if (category === '*') {
                        this.enabledCategories.clear();
                        this.enabledCategories.add('*');
                    } else {
                        this.enabledCategories.add(category);
                    }
                }
                disableCategory(category) {
                    this.enabledCategories.delete(category);
                }
                isCategoryEnabled(category) {
                    return this.enabledCategories.has('*') || this.enabledCategories.has(category);
                }
                _log(level, category, message, ...args) {
                    if (LOG_LEVELS[level] > this.level) return;
                    if (!this.isCategoryEnabled(category)) return;
                    const color = LOG_COLORS[level];
                    const timestamp = /* @__PURE__ */ new Date().toLocaleTimeString();
                    if (this.format === 'detailed') {
                        console.log(
                            `%c[${timestamp}] [${level}] [${category}]`,
                            `color: ${color}; font-weight: bold`,
                            message,
                            ...args
                        );
                    } else {
                        console.log(`%c[${category}]`, `color: ${color}`, message, ...args);
                    }
                }
                error(category, message, ...args) {
                    this._log('ERROR', category, message, ...args);
                }
                warn(category, message, ...args) {
                    this._log('WARN', category, message, ...args);
                }
                info(category, message, ...args) {
                    this._log('INFO', category, message, ...args);
                }
                debug(category, message, ...args) {
                    this._log('DEBUG', category, message, ...args);
                }
                trace(category, message, ...args) {
                    this._log('TRACE', category, message, ...args);
                }
                group(category, title) {
                    if (!this.isCategoryEnabled(category)) return;
                    console.group(title != null ? title : category);
                }
                groupEnd() {
                    console.groupEnd();
                }
                time(label) {
                    console.time(label);
                }
                timeEnd(label) {
                    console.timeEnd(label);
                }
            };
            logger = new Logger();
            logger_default = logger;
            if (typeof window !== 'undefined') {
                window.Logger = logger;
            }
            if (typeof module !== 'undefined' && module.exports) {
                module.exports = logger;
            }
        },
    });

    // src/ts/services/storage-utils.ts
    function getString(key) {
        try {
            return localStorage.getItem(key);
        } catch {
            return null;
        }
    }
    function setString(key, value) {
        try {
            localStorage.setItem(key, value);
        } catch (err) {
            console.warn(`[storage-utils] setString failed for key="${key}":`, err);
        }
    }
    function remove(key) {
        try {
            localStorage.removeItem(key);
        } catch (err) {
            console.warn(`[storage-utils] remove failed for key="${key}":`, err);
        }
    }
    function getJSON(key, fallback) {
        try {
            const raw = localStorage.getItem(key);
            if (!raw) return fallback;
            return JSON.parse(raw);
        } catch (err) {
            console.warn(`[storage-utils] getJSON failed for key="${key}":`, err);
            return fallback;
        }
    }
    function setJSON(key, value) {
        try {
            localStorage.setItem(key, JSON.stringify(value));
        } catch (err) {
            console.warn(`[storage-utils] setJSON failed for key="${key}":`, err);
        }
    }
    var init_storage_utils = __esm({
        'src/ts/services/storage-utils.ts'() {
            'use strict';
        },
    });

    // src/ts/core/error-handler.ts
    var init_error_handler = __esm({
        'src/ts/core/error-handler.ts'() {
            'use strict';
            init_storage_utils();
            console.log('ErrorHandler loaded');
            (() => {
                'use strict';
                const STORAGE_KEY = 'app.errorLogs';
                const MAX_LOGS = 100;
                function nowISO() {
                    try {
                        return /* @__PURE__ */ new Date().toISOString();
                    } catch (_e) {
                        void _e;
                        return String(Date.now());
                    }
                }
                function safeStringify(obj) {
                    try {
                        return JSON.stringify(obj);
                    } catch (_e) {
                        void _e;
                        return String(obj);
                    }
                }
                function readLogs() {
                    try {
                        return getJSON(STORAGE_KEY, []);
                    } catch (_e) {
                        void _e;
                        return [];
                    }
                }
                function writeLogs(logs) {
                    try {
                        setJSON(STORAGE_KEY, logs.slice(-MAX_LOGS));
                    } catch (_e) {
                        void _e;
                    }
                }
                function toPlainError(err) {
                    if (!err) return { name: 'Error', message: 'Unknown error' };
                    const error = err;
                    const plain = {
                        name: error.name || 'Error',
                        message: error.message || String(err),
                        stack: error.stack,
                    };
                    return plain;
                }
                const ErrorHandler = {
                    enabled: true,
                    enable() {
                        if (this.enabled) return;
                        this.enabled = true;
                    },
                    disable() {
                        if (!this.enabled) return;
                        this.enabled = false;
                    },
                    getLogs() {
                        return readLogs();
                    },
                    clearLogs() {
                        writeLogs([]);
                    },
                    exportLogs() {
                        try {
                            const logs = readLogs();
                            const blob = new Blob([safeStringify(logs)], {
                                type: 'application/json',
                            });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `error-logs-${Date.now()}.json`;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                        } catch (_e) {
                            void _e;
                            const logger2 = window.Logger || console;
                            logger2.error('ErrorHandler', 'Failed to export logs');
                        }
                    },
                    _record(entry) {
                        const logs = readLogs();
                        logs.push(entry);
                        writeLogs(logs);
                    },
                };
                function handleWindowError(message, source, lineno, colno, error) {
                    if (!ErrorHandler.enabled) return false;
                    const plain = toPlainError(error || { message });
                    const entry = {
                        type: 'error',
                        time: nowISO(),
                        message: String(message),
                        source: String(source || ''),
                        line: lineno || null,
                        column: colno || null,
                        error: plain,
                    };
                    const logger2 = window.Logger || console;
                    logger2.error('ErrorHandler', 'Unhandled error', entry);
                    ErrorHandler._record(entry);
                    return false;
                }
                function handleUnhandledRejection(event) {
                    if (!ErrorHandler.enabled) return;
                    const reason = event == null ? void 0 : event.reason;
                    const plain = toPlainError(
                        reason instanceof Error ? reason : { message: safeStringify(reason) }
                    );
                    const entry = {
                        type: 'unhandledrejection',
                        time: nowISO(),
                        reason: safeStringify(reason),
                        error: plain,
                    };
                    const logger2 = window.Logger || console;
                    logger2.error('ErrorHandler', 'Unhandled promise rejection', entry);
                    ErrorHandler._record(entry);
                }
                ErrorHandler.enabled = true;
                window.addEventListener('error', function (e) {
                    if (e == null ? void 0 : e.error) {
                        handleWindowError(e.message, e.filename, e.lineno, e.colno, e.error);
                    }
                });
                window.onerror = handleWindowError;
                window.addEventListener('unhandledrejection', handleUnhandledRejection);
                if (typeof window !== 'undefined') {
                    window.ErrorHandler = ErrorHandler;
                }
            })();
        },
    });

    // src/ts/core/perf-monitor.ts
    var init_perf_monitor = __esm({
        'src/ts/core/perf-monitor.ts'() {
            'use strict';
            init_storage_utils();
            console.log('PerfMonitor loaded');
            (() => {
                'use strict';
                const STORAGE_KEY = 'app.perfMonitor.enabled';
                function isEnabledByDefault() {
                    try {
                        const isDev =
                            location.hostname === 'localhost' ||
                            location.hostname === '127.0.0.1' ||
                            location.port !== '';
                        const flag = localStorage.getItem(STORAGE_KEY);
                        if (flag === 'true') return true;
                        if (flag === 'false') return false;
                        return isDev;
                    } catch (_e) {
                        void _e;
                        return false;
                    }
                }
                const PerfMonitor = {
                    enabled: isEnabledByDefault(),
                    marks: /* @__PURE__ */ new Set(),
                    enable() {
                        this.enabled = true;
                        try {
                            setString(STORAGE_KEY, 'true');
                        } catch (_e) {
                            void _e;
                        }
                        const logger2 = window.Logger || console;
                        logger2.info('PerfMonitor', 'Enabled');
                    },
                    disable() {
                        this.enabled = false;
                        try {
                            setString(STORAGE_KEY, 'false');
                        } catch (_e) {
                            void _e;
                        }
                        const logger2 = window.Logger || console;
                        logger2.info('PerfMonitor', 'Disabled');
                    },
                    toggle() {
                        if (this.enabled) {
                            this.disable();
                        } else {
                            this.enable();
                        }
                    },
                    mark(name) {
                        if (!this.enabled || !name) return;
                        try {
                            performance.mark(name);
                            this.marks.add(name);
                        } catch (_e) {
                            void _e;
                        }
                    },
                    measure(name, startMark, endMark) {
                        if (!this.enabled || !name) return null;
                        try {
                            if (startMark && endMark) {
                                performance.measure(name, startMark, endMark);
                            } else if (startMark) {
                                performance.measure(name, startMark);
                            } else {
                                performance.measure(name);
                            }
                            const entries = performance.getEntriesByName(name, 'measure');
                            const lastEntry = entries[entries.length - 1];
                            return lastEntry ? lastEntry : null;
                        } catch (_e) {
                            void _e;
                            return null;
                        }
                    },
                    report(options) {
                        if (!this.enabled) return [];
                        const { clear = false, topN = 10 } = options || {};
                        const measures = performance
                            .getEntriesByType('measure')
                            .slice()
                            .sort((a, b) => b.duration - a.duration)
                            .slice(0, topN);
                        if (measures.length) {
                            const logger2 = window.Logger || console;
                            logger2.group('PerfMonitor report');
                            for (const m of measures) {
                                logger2.info(
                                    'PerfMonitor',
                                    `${m.name}: ${m.duration.toFixed(2)}ms`
                                );
                            }
                            logger2.groupEnd();
                        }
                        if (clear) {
                            performance.clearMeasures();
                            try {
                                for (const m of this.marks) performance.clearMarks(m);
                            } catch (_e) {
                                void _e;
                            }
                            this.marks.clear();
                        }
                        return measures;
                    },
                };
                if (PerfMonitor.enabled) {
                    try {
                        PerfMonitor.mark('app:js-start');
                        if (
                            document.readyState === 'complete' ||
                            document.readyState === 'interactive'
                        ) {
                            PerfMonitor.mark('app:dom-ready');
                        } else {
                            document.addEventListener(
                                'DOMContentLoaded',
                                () => PerfMonitor.mark('app:dom-ready'),
                                { once: true }
                            );
                        }
                        window.addEventListener(
                            'load',
                            () => {
                                PerfMonitor.mark('app:window-load');
                                PerfMonitor.measure(
                                    'app:domready->load',
                                    'app:dom-ready',
                                    'app:window-load'
                                );
                                PerfMonitor.measure(
                                    'app:start->load',
                                    'app:js-start',
                                    'app:window-load'
                                );
                                PerfMonitor.report({ topN: 5 });
                            },
                            { once: true }
                        );
                    } catch (_e) {
                        void _e;
                    }
                }
                if (typeof window !== 'undefined') {
                    window.PerfMonitor = PerfMonitor;
                }
            })();
        },
    });

    // src/ts/core/api.ts
    var require_api = __commonJS({
        'src/ts/core/api.ts'() {
            'use strict';
            console.log('API loaded');
            (function () {
                'use strict';
                function getWindowProp(propName) {
                    return window[propName];
                }
                function callWindowMethod(objName, methodName, ...args) {
                    const obj = getWindowProp(objName);
                    if (obj && typeof obj[methodName] === 'function') {
                        return obj[methodName](...args);
                    }
                    return void 0;
                }
                function createModuleProxy(moduleName, methods) {
                    const proxy = {};
                    methods.forEach(method => {
                        proxy[method] = function (...args) {
                            const module3 = getWindowProp(moduleName);
                            if (module3 && typeof module3[method] === 'function') {
                                return module3[method](...args);
                            }
                            console.warn(`${moduleName}.${method} ist nicht verf\xFCgbar`);
                            return void 0;
                        };
                    });
                    return proxy;
                }
                const API2 = {
                    error: createModuleProxy('ErrorHandler', [
                        'enable',
                        'disable',
                        'getLogs',
                        'clearLogs',
                        'exportLogs',
                    ]),
                    performance: createModuleProxy('PerfMonitor', [
                        'enable',
                        'disable',
                        'toggle',
                        'mark',
                        'measure',
                        'report',
                    ]),
                    theme: createModuleProxy('ThemeSystem', [
                        'setThemePreference',
                        'getThemePreference',
                        'applyTheme',
                        'initTheme',
                    ]),
                    icon: createModuleProxy('IconSystem', [
                        'ensureSvgNamespace',
                        'getMenuIconSvg',
                        'renderIconIntoElement',
                    ]),
                    dock: createModuleProxy('DockSystem', [
                        'getDockReservedBottom',
                        'initDockMagnification',
                        'updateDockIndicators',
                    ]),
                    menu: createModuleProxy('MenuSystem', [
                        'renderApplicationMenu',
                        'handleMenuActionActivation',
                        'registerMenuAction',
                        'hideMenuDropdowns',
                        'toggleMenuDropdown',
                        'isAnyDropdownOpen',
                    ]),
                    desktop: createModuleProxy('DesktopSystem', [
                        'initDesktop',
                        'openDesktopItemById',
                    ]),
                    system: createModuleProxy('SystemUI', [
                        'initSystemStatusControls',
                        'updateAllSystemStatusUI',
                        'handleSystemToggle',
                        'setConnectedNetwork',
                        'setBluetoothDevice',
                        'setAudioDevice',
                    ]),
                    storage: createModuleProxy('StorageSystem', [
                        'readFinderState',
                        'writeFinderState',
                        'clearFinderState',
                        'saveOpenModals',
                        'restoreOpenModals',
                        'saveWindowPositions',
                        'restoreWindowPositions',
                        'resetWindowLayout',
                        'getDialogWindowElement',
                    ]),
                    finder: createModuleProxy('FinderSystem', [
                        'init',
                        'openFinder',
                        'closeFinder',
                    ]),
                    textEditor: {
                        init: container => callWindowMethod('TextEditorSystem', 'init', container),
                        loadRemoteFile: payload =>
                            callWindowMethod('TextEditorSystem', 'loadRemoteFile', payload),
                        showLoading: payload =>
                            callWindowMethod('TextEditorSystem', 'showLoading', payload),
                        showLoadError: payload =>
                            callWindowMethod('TextEditorSystem', 'showLoadError', payload),
                        clearEditor: () => callWindowMethod('TextEditorSystem', 'clearEditor'),
                        saveFile: () => callWindowMethod('TextEditorSystem', 'saveFile'),
                        openFile: () => callWindowMethod('TextEditorSystem', 'openFile'),
                        handleMenuAction: action =>
                            callWindowMethod('TextEditorSystem', 'handleMenuAction', action),
                    },
                    settings: {
                        init: container => callWindowMethod('SettingsSystem', 'init', container),
                        showSection: section =>
                            callWindowMethod('SettingsSystem', 'showSection', section),
                        syncThemePreference: () =>
                            callWindowMethod('SettingsSystem', 'syncThemePreference'),
                        syncLanguagePreference: () =>
                            callWindowMethod('SettingsSystem', 'syncLanguagePreference'),
                    },
                    window: {
                        register: config => callWindowMethod('WindowManager', 'register', config),
                        registerAll: configs =>
                            callWindowMethod('WindowManager', 'registerAll', configs),
                        getConfig: id => callWindowMethod('WindowManager', 'getConfig', id),
                        open: id => callWindowMethod('WindowManager', 'open', id),
                        close: id => callWindowMethod('WindowManager', 'close', id),
                        bringToFront: id => callWindowMethod('WindowManager', 'bringToFront', id),
                        getTopWindow: () => callWindowMethod('WindowManager', 'getTopWindow'),
                        getProgramInfo: id =>
                            callWindowMethod('WindowManager', 'getProgramInfo', id),
                        getAllWindowIds: () =>
                            callWindowMethod('WindowManager', 'getAllWindowIds') || [],
                        getPersistentWindowIds: () =>
                            callWindowMethod('WindowManager', 'getPersistentWindowIds') || [],
                        getDialogInstance: id =>
                            callWindowMethod('WindowManager', 'getDialogInstance', id),
                        syncZIndexWithDOM: () =>
                            callWindowMethod('WindowManager', 'syncZIndexWithDOM'),
                    },
                    action: {
                        register: (name, handler) =>
                            callWindowMethod('ActionBus', 'register', name, handler),
                        registerAll: actions =>
                            callWindowMethod('ActionBus', 'registerAll', actions),
                        execute: (name, params, element) =>
                            callWindowMethod('ActionBus', 'execute', name, params, element),
                    },
                    i18n: {
                        translate: (key, fallback) => {
                            const appI18n2 = getWindowProp('appI18n');
                            if (appI18n2 && typeof appI18n2['translate'] === 'function') {
                                const result = appI18n2['translate'](key);
                                return result === key && fallback ? fallback : result;
                            }
                            return fallback || key;
                        },
                        setLanguagePreference: lang =>
                            callWindowMethod('appI18n', 'setLanguagePreference', lang),
                        getLanguagePreference: () =>
                            callWindowMethod('appI18n', 'getLanguagePreference') || 'system',
                        getActiveLanguage: () =>
                            callWindowMethod('appI18n', 'getActiveLanguage') || 'en',
                        applyTranslations: () => callWindowMethod('appI18n', 'applyTranslations'),
                    },
                    session: createModuleProxy('SessionManager', [
                        'init',
                        'saveAll',
                        'saveInstanceType',
                        'restoreSession',
                        'clear',
                        'setDebounceDelay',
                        'getDebounceDelay',
                        'getStats',
                    ]),
                    helpers: {
                        getMenuBarBottom: () => {
                            const header = document.querySelector('body > header');
                            if (!header) return 0;
                            return header.getBoundingClientRect().bottom;
                        },
                        clampWindowToMenuBar: target => {
                            const fn = getWindowProp('clampWindowToMenuBar');
                            if (typeof fn === 'function') {
                                return fn(target);
                            }
                            return void 0;
                        },
                        computeSnapMetrics: side => {
                            const fn = getWindowProp('computeSnapMetrics');
                            if (typeof fn === 'function') {
                                return fn(side);
                            }
                            return void 0;
                        },
                        showSnapPreview: side => {
                            const fn = getWindowProp('showSnapPreview');
                            if (typeof fn === 'function') {
                                fn(side);
                            }
                        },
                        hideSnapPreview: () => {
                            const fn = getWindowProp('hideSnapPreview');
                            if (typeof fn === 'function') {
                                fn();
                            }
                        },
                    },
                };
                window.API = API2;
                const createLegacyWrapper = apiPath => {
                    return function (...args) {
                        const parts = apiPath.split('.');
                        let fn = API2;
                        for (const part of parts) {
                            fn = fn[part];
                            if (!fn) {
                                console.warn(`Legacy wrapper: ${apiPath} nicht gefunden`);
                                return void 0;
                            }
                        }
                        if (typeof fn === 'function') {
                            return fn(...args);
                        }
                        return fn;
                    };
                };
                const w = window;
                w.setThemePreference = createLegacyWrapper('theme.setThemePreference');
                w.getThemePreference = createLegacyWrapper('theme.getThemePreference');
                w.ensureSvgNamespace = createLegacyWrapper('icon.ensureSvgNamespace');
                w.getMenuIconSvg = createLegacyWrapper('icon.getMenuIconSvg');
                w.renderIconIntoElement = createLegacyWrapper('icon.renderIconIntoElement');
                w.getDockReservedBottom = createLegacyWrapper('dock.getDockReservedBottom');
                w.initDockMagnification = createLegacyWrapper('dock.initDockMagnification');
                w.renderApplicationMenu = createLegacyWrapper('menu.renderApplicationMenu');
                w.handleMenuActionActivation = createLegacyWrapper(
                    'menu.handleMenuActionActivation'
                );
                w.initDesktop = createLegacyWrapper('desktop.initDesktop');
                w.openDesktopItemById = createLegacyWrapper('desktop.openDesktopItemById');
                w.initSystemStatusControls = createLegacyWrapper('system.initSystemStatusControls');
                w.updateAllSystemStatusUI = createLegacyWrapper('system.updateAllSystemStatusUI');
                w.handleSystemToggle = createLegacyWrapper('system.handleSystemToggle');
                w.setConnectedNetwork = createLegacyWrapper('system.setConnectedNetwork');
                w.setBluetoothDevice = createLegacyWrapper('system.setBluetoothDevice');
                w.setAudioDevice = createLegacyWrapper('system.setAudioDevice');
                w.readFinderState = createLegacyWrapper('storage.readFinderState');
                w.writeFinderState = createLegacyWrapper('storage.writeFinderState');
                w.clearFinderState = createLegacyWrapper('storage.clearFinderState');
                w.saveOpenModals = createLegacyWrapper('storage.saveOpenModals');
                w.restoreOpenModals = createLegacyWrapper('storage.restoreOpenModals');
                w.saveWindowPositions = createLegacyWrapper('storage.saveWindowPositions');
                w.restoreWindowPositions = createLegacyWrapper('storage.restoreWindowPositions');
                w.resetWindowLayout = createLegacyWrapper('storage.resetWindowLayout');
            })();
        },
    });

    // src/ts/windows/z-index-manager.ts
    function clamp(z) {
        return Math.min(z, MAX_WINDOW_Z_INDEX);
    }
    function applyZIndex(windowId, zIndex, modal, windowEl) {
        var _a, _b;
        const targets = [];
        if (modal) targets.push(modal);
        if (windowEl && windowEl !== modal) targets.push(windowEl);
        const element = modal || document.getElementById(windowId);
        if (element && !targets.includes(element)) targets.push(element);
        const autoPointer =
            (_a = element == null ? void 0 : element.querySelector) == null
                ? void 0
                : _a.call(element, '.autopointer');
        if (autoPointer && !targets.includes(autoPointer)) targets.push(autoPointer);
        const contentEl =
            (_b = element == null ? void 0 : element.querySelector) == null
                ? void 0
                : _b.call(element, '.window-container');
        if (contentEl && !targets.includes(contentEl)) targets.push(contentEl);
        targets.forEach(target => {
            if (!target) return;
            target.style.zIndex = zIndex.toString();
        });
    }
    function pruneHiddenOrMissing(stack) {
        for (let i = stack.length - 1; i >= 0; i -= 1) {
            const id = stack[i];
            if (!id) {
                stack.splice(i, 1);
                continue;
            }
            const el = document.getElementById(id);
            if (!el || el.classList.contains('hidden')) {
                stack.splice(i, 1);
            }
        }
        return stack;
    }
    function findTopVisibleModal() {
        let top = null;
        let highest = 0;
        document.querySelectorAll('.modal:not(.hidden)').forEach(modal => {
            const z = parseInt(getComputedStyle(modal).zIndex, 10) || 0;
            if (z > highest) {
                highest = z;
                top = modal;
            }
        });
        return top;
    }
    function getState(existing) {
        var _a;
        const windowStack =
            ((_a = existing == null ? void 0 : existing.getWindowStack) == null
                ? void 0
                : _a.call(existing)) || [];
        const externalTopZ = BASE_Z_INDEX2;
        return { windowStack: [...windowStack], externalTopZ };
    }
    function getZIndexManager() {
        var _a, _b;
        const win = window;
        const existing = win.__zIndexManager;
        const initialTopZ =
            (_b =
                (_a = existing == null ? void 0 : existing.getTopZIndex) == null
                    ? void 0
                    : _a.call(existing)) != null
                ? _b
                : BASE_Z_INDEX2;
        const topZStore = {
            value: clamp(initialTopZ),
        };
        const setTopZStore = v => {
            topZStore.value = clamp(v);
            win.__topZIndexRaw = topZStore.value;
        };
        const getTopZStore = () => topZStore.value;
        if (existing && typeof existing.bringToFront === 'function') {
            if (typeof existing.getTopWindowElement !== 'function') {
                existing.getTopWindowElement = () => {
                    var _a2;
                    const topId =
                        ((_a2 = existing.getTopWindowId) == null ? void 0 : _a2.call(existing)) ||
                        null;
                    return topId ? document.getElementById(topId) : findTopVisibleModal();
                };
            }
            if (typeof existing.getTopWindowId !== 'function') {
                existing.getTopWindowId = () => {
                    var _a2, _b2;
                    const stack =
                        ((_a2 = existing.getWindowStack) == null ? void 0 : _a2.call(existing)) ||
                        [];
                    const pruned = pruneHiddenOrMissing([...stack]);
                    if (pruned.length > 0)
                        return (_b2 = pruned[pruned.length - 1]) != null ? _b2 : null;
                    const fallback = findTopVisibleModal();
                    return fallback ? fallback.id : null;
                };
            }
            if (typeof existing.getTopZIndex !== 'function') {
                existing.getTopZIndex = () => getTopZStore();
            }
            if (typeof existing.bumpZIndex !== 'function') {
                existing.bumpZIndex = () => {
                    setTopZStore((getTopZStore() || BASE_Z_INDEX2) + 1);
                    return getTopZStore();
                };
            }
            if (typeof existing.ensureTopZIndex !== 'function') {
                existing.ensureTopZIndex = z => {
                    setTopZStore(Math.max(getTopZStore(), z));
                    return getTopZStore();
                };
            }
            if (typeof existing.syncFromDOM !== 'function') {
                existing.syncFromDOM = () => {
                    var _a2, _b2;
                    return (_b2 =
                        (_a2 = existing.getTopZIndex) == null ? void 0 : _a2.call(existing)) != null
                        ? _b2
                        : BASE_Z_INDEX2;
                };
            }
            win.__zIndexManager = existing;
            return win.__zIndexManager;
        }
        const state = getState(existing);
        const assignZIndices = () => {
            state.windowStack.forEach((id, index) => {
                const zIndex = clamp(BASE_Z_INDEX2 + index);
                applyZIndex(id, zIndex);
            });
            const stackTopNext = BASE_Z_INDEX2 + state.windowStack.length;
            setTopZStore(Math.max(stackTopNext, state.externalTopZ));
        };
        const manager = {
            bringToFront(windowId, modal, windowEl) {
                const currentIndex = state.windowStack.indexOf(windowId);
                if (currentIndex !== -1) {
                    state.windowStack.splice(currentIndex, 1);
                }
                state.windowStack.push(windowId);
                assignZIndices();
                const assigned = clamp(BASE_Z_INDEX2 + state.windowStack.length - 1);
                applyZIndex(windowId, assigned, modal, windowEl);
                return manager.getTopZIndex();
            },
            removeWindow(windowId) {
                const idx = state.windowStack.indexOf(windowId);
                if (idx !== -1) {
                    state.windowStack.splice(idx, 1);
                    assignZIndices();
                }
            },
            getWindowStack() {
                return [...state.windowStack];
            },
            restoreWindowStack(savedStack) {
                state.windowStack.length = 0;
                savedStack.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) state.windowStack.push(id);
                });
                assignZIndices();
            },
            reset() {
                state.windowStack.length = 0;
                state.externalTopZ = BASE_Z_INDEX2;
                setTopZStore(BASE_Z_INDEX2);
            },
            getTopWindowId() {
                var _a2;
                pruneHiddenOrMissing(state.windowStack);
                if (state.windowStack.length > 0)
                    return (_a2 = state.windowStack[state.windowStack.length - 1]) != null
                        ? _a2
                        : null;
                const fallback = findTopVisibleModal();
                return fallback ? fallback.id : null;
            },
            getTopWindowElement() {
                const topId = manager.getTopWindowId();
                if (topId) return document.getElementById(topId);
                return findTopVisibleModal();
            },
            getTopZIndex() {
                const stackNext = BASE_Z_INDEX2 + state.windowStack.length;
                const value = clamp(Math.max(stackNext, state.externalTopZ));
                setTopZStore(value);
                return value;
            },
            bumpZIndex() {
                const nextFromStack = BASE_Z_INDEX2 + state.windowStack.length + 1;
                state.externalTopZ = clamp(Math.max(state.externalTopZ + 1, nextFromStack));
                setTopZStore(state.externalTopZ);
                return state.externalTopZ;
            },
            ensureTopZIndex(z) {
                state.externalTopZ = clamp(Math.max(state.externalTopZ, z));
                const nextFromStack = BASE_Z_INDEX2 + state.windowStack.length;
                setTopZStore(Math.max(nextFromStack, state.externalTopZ));
                return getTopZStore();
            },
            syncFromDOM() {
                let maxZ = BASE_Z_INDEX2;
                document.querySelectorAll('.modal').forEach(modal => {
                    const modalZ = parseInt(window.getComputedStyle(modal).zIndex, 10);
                    if (!Number.isNaN(modalZ)) maxZ = Math.max(maxZ, modalZ);
                    const winEl = modal.querySelector('.autopointer');
                    if (winEl) {
                        const winZ = parseInt(window.getComputedStyle(winEl).zIndex, 10);
                        if (!Number.isNaN(winZ)) maxZ = Math.max(maxZ, winZ);
                    }
                });
                state.externalTopZ = clamp(Math.max(state.externalTopZ, maxZ));
                return manager.getTopZIndex();
            },
        };
        win.__zIndexManager = manager;
        assignZIndices();
        return manager;
    }
    var BASE_Z_INDEX2, MAX_WINDOW_Z_INDEX;
    var init_z_index_manager = __esm({
        'src/ts/windows/z-index-manager.ts'() {
            'use strict';
            BASE_Z_INDEX2 = 1e3;
            MAX_WINDOW_Z_INDEX = 2147483500;
        },
    });

    // src/ts/windows/window-manager.ts
    var require_window_manager = __commonJS({
        'src/ts/windows/window-manager.ts'() {
            'use strict';
            init_z_index_manager();
            (() => {
                'use strict';
                class WindowConfig {
                    constructor(options) {
                        var _a;
                        this.id = options.id;
                        this.type = options.type || 'persistent';
                        this.programKey = options.programKey || 'programs.default';
                        this.icon = options.icon || './img/sucher.png';
                        this.closeButtonId = (_a = options.closeButtonId) != null ? _a : null;
                        this.dialogInstance = null;
                        this.metadata = options.metadata || {};
                    }
                    isTransient() {
                        return this.type === 'transient';
                    }
                    getProgramInfo() {
                        const w = window;
                        const i18n = w['appI18n'] || void 0;
                        const translate2 = (i18n == null ? void 0 : i18n.translate) || (key => key);
                        const aboutFields = ['name', 'tagline', 'version', 'copyright'];
                        const info = {
                            modalId: this.id,
                            programLabel: translate2(`${this.programKey}.label`),
                            infoLabel: translate2(`${this.programKey}.infoLabel`),
                            fallbackInfoModalId:
                                this.metadata.fallbackInfoModalId || 'program-info-modal',
                            icon: this.icon,
                            about: {},
                        };
                        aboutFields.forEach(field => {
                            info.about[field] = translate2(`${this.programKey}.about.${field}`);
                        });
                        return info;
                    }
                }
                const windowRegistry = /* @__PURE__ */ new Map();
                const zIndexManager = getZIndexManager();
                const WindowManager = {
                    /**
                     * Get current top z-index for synchronization
                     */
                    getTopZIndex() {
                        return zIndexManager.getTopZIndex();
                    },
                    /**
                     * Update top z-index from external source (e.g., WindowRegistry)
                     */
                    updateTopZIndex(newZIndex) {
                        zIndexManager.ensureTopZIndex(newZIndex);
                    },
                    register(config) {
                        const windowConfig = new WindowConfig(config);
                        windowRegistry.set(config.id, windowConfig);
                        return windowConfig;
                    },
                    registerAll(configs) {
                        configs.forEach(c => this.register(c));
                    },
                    getConfig(windowId) {
                        return windowRegistry.get(windowId) || null;
                    },
                    getAllWindowIds() {
                        return Array.from(windowRegistry.keys());
                    },
                    getPersistentWindowIds() {
                        return this.getAllWindowIds().filter(id => {
                            const config = this.getConfig(id);
                            return !!config && !config.isTransient();
                        });
                    },
                    getTransientWindowIds() {
                        return this.getAllWindowIds().filter(id => {
                            const config = this.getConfig(id);
                            return !!config && config.isTransient();
                        });
                    },
                    setDialogInstance(windowId, instance) {
                        const config = this.getConfig(windowId);
                        if (config) {
                            config.dialogInstance = instance;
                        }
                    },
                    getDialogInstance(windowId) {
                        const config = this.getConfig(windowId);
                        return (config && config.dialogInstance) || null;
                    },
                    getAllDialogInstances() {
                        const dialogs = {};
                        windowRegistry.forEach((config, id) => {
                            if (config.dialogInstance) {
                                dialogs[id] = config.dialogInstance;
                            }
                        });
                        return dialogs;
                    },
                    getTopWindow() {
                        return zIndexManager.getTopWindowElement();
                    },
                    bringToFront(windowId) {
                        const instance = this.getDialogInstance(windowId);
                        if (instance && typeof instance.bringToFront === 'function') {
                            instance.bringToFront();
                            return;
                        }
                        const modal = document.getElementById(windowId);
                        if (!modal) {
                            console.warn(`Keine Dialog-Instanz f\xFCr ${windowId} gefunden.`);
                            return;
                        }
                        const windowEl = this.getDialogWindowElement(modal);
                        zIndexManager.bringToFront(windowId, modal, windowEl);
                    },
                    open(windowId) {
                        const config = this.getConfig(windowId);
                        const g = window;
                        const allowInitDuringRestore = !!(
                            (config == null ? void 0 : config.metadata) &&
                            config.metadata.runInitDuringRestore
                        );
                        if (
                            config &&
                            config.metadata &&
                            typeof config.metadata.initHandler === 'function' &&
                            (!g.__SESSION_RESTORE_IN_PROGRESS || allowInitDuringRestore)
                        ) {
                            try {
                                const md = config.metadata;
                                if (typeof md.initHandler === 'function') md.initHandler();
                            } catch (e) {
                                console.warn(`Init handler for ${windowId} threw:`, e);
                            }
                        }
                        const instance = this.getDialogInstance(windowId);
                        if (instance && typeof instance.open === 'function') {
                            instance.open();
                        } else {
                            const modal = document.getElementById(windowId);
                            if (modal) {
                                const domUtils = window.DOMUtils;
                                if (domUtils && typeof domUtils.show === 'function') {
                                    domUtils.show(modal);
                                } else {
                                    modal.classList.remove('hidden');
                                }
                                this.bringToFront(windowId);
                            }
                        }
                    },
                    close(windowId) {
                        const instance = this.getDialogInstance(windowId);
                        if (instance && typeof instance.close === 'function') {
                            instance.close();
                        } else {
                            const modal = document.getElementById(windowId);
                            if (modal) {
                                const domUtils = window.DOMUtils;
                                if (domUtils && typeof domUtils.hide === 'function') {
                                    domUtils.hide(modal);
                                } else {
                                    modal.classList.add('hidden');
                                }
                            }
                        }
                    },
                    getNextZIndex() {
                        return zIndexManager.bumpZIndex();
                    },
                    syncZIndexWithDOM() {
                        return zIndexManager.syncFromDOM();
                    },
                    getDialogWindowElement(modal) {
                        if (!modal) return null;
                        return modal.querySelector('.autopointer') || modal;
                    },
                    getProgramInfo(windowId) {
                        const config = this.getConfig(windowId);
                        if (config) return config.getProgramInfo();
                        return this.getDefaultProgramInfo();
                    },
                    getDefaultProgramInfo() {
                        const w = window;
                        const i18n = w['appI18n'] || void 0;
                        const translate2 = (i18n == null ? void 0 : i18n.translate) || (key => key);
                        const programKey = 'programs.default';
                        return {
                            modalId: null,
                            programLabel: translate2(`${programKey}.label`),
                            infoLabel: translate2(`${programKey}.infoLabel`),
                            fallbackInfoModalId: 'program-info-modal',
                            icon: './img/sucher.png',
                            about: {
                                name: translate2(`${programKey}.about.name`),
                                tagline: translate2(`${programKey}.about.tagline`),
                                version: translate2(`${programKey}.about.version`),
                                copyright: translate2(`${programKey}.about.copyright`),
                            },
                        };
                    },
                    get topZIndex() {
                        return zIndexManager.getTopZIndex();
                    },
                    set topZIndex(value) {
                        zIndexManager.ensureTopZIndex(value);
                    },
                    get baseZIndex() {
                        return BASE_Z_INDEX2;
                    },
                };
                window.WindowManager = WindowManager;
                Object.defineProperty(window, 'topZIndex', {
                    get: () => WindowManager.topZIndex,
                    set: value => {
                        WindowManager.topZIndex = value;
                    },
                });
            })();
        },
    });

    // src/ts/ui/actions/helpers.ts
    function extractParams(dataset) {
        const params = {};
        for (const key in dataset) {
            if (key === 'action' || key === 'actionHover') continue;
            params[key] = dataset[key];
        }
        return params;
    }
    function safeExecute(label, fn) {
        try {
            fn();
        } catch (error) {
            console.warn(`${label} failed:`, error);
        }
    }
    function getGlobal(path) {
        const parts = path.split('.').filter(Boolean);
        let current = window;
        for (const p of parts) {
            if (current && typeof current === 'object' && p in current) {
                current = current[p];
            } else {
                return void 0;
            }
        }
        return current;
    }
    var init_helpers = __esm({
        'src/ts/ui/actions/helpers.ts'() {
            'use strict';
        },
    });

    // src/ts/ui/actions/finder.ts
    function getFinderActions() {
        return {
            'finder:navigateUp': () => {
                var _a;
                const finder = getGlobal('FinderSystem');
                (_a = finder == null ? void 0 : finder.navigateUp) == null
                    ? void 0
                    : _a.call(finder);
            },
            'finder:goRoot': () => {
                var _a, _b, _c;
                const finder = getGlobal('FinderSystem');
                const view =
                    (_b =
                        (_a = finder == null ? void 0 : finder.getState) == null
                            ? void 0
                            : _a.call(finder)) == null
                        ? void 0
                        : _b.currentView;
                (_c = finder == null ? void 0 : finder.navigateTo) == null
                    ? void 0
                    : _c.call(finder, [], view);
            },
            'finder:switchView': params => {
                var _a;
                const view = params['finderView'] || params.view;
                if (!view) {
                    console.warn('finder:switchView: missing finderView');
                    return;
                }
                const finder = getGlobal('FinderSystem');
                (_a = finder == null ? void 0 : finder.navigateTo) == null
                    ? void 0
                    : _a.call(finder, [], view);
            },
            'finder:setViewMode': params => {
                var _a;
                const mode = params['viewMode'] || params['mode'];
                if (!mode) {
                    console.warn('finder:setViewMode: missing viewMode');
                    return;
                }
                const finder = getGlobal('FinderSystem');
                (_a = finder == null ? void 0 : finder.setViewMode) == null
                    ? void 0
                    : _a.call(finder, mode);
            },
            'finder:setSortBy': params => {
                var _a;
                const field = params['sortBy'] || params['field'];
                if (!field) {
                    console.warn('finder:setSortBy: missing sortBy');
                    return;
                }
                const finder = getGlobal('FinderSystem');
                (_a = finder == null ? void 0 : finder.setSortBy) == null
                    ? void 0
                    : _a.call(finder, field);
            },
            'finder:navigateToPath': params => {
                var _a;
                const raw = params.path || '';
                const parts = typeof raw === 'string' && raw.length ? raw.split('/') : [];
                const finder = getGlobal('FinderSystem');
                (_a = finder == null ? void 0 : finder.navigateTo) == null
                    ? void 0
                    : _a.call(finder, parts);
            },
            'finder:openItem': params => {
                var _a;
                const name = params['itemName'] || params['name'];
                const type = params['itemType'] || params['type'];
                if (!name || !type) {
                    console.warn('finder:openItem: missing name/type');
                    return;
                }
                const finder = getGlobal('FinderSystem');
                (_a = finder == null ? void 0 : finder.openItem) == null
                    ? void 0
                    : _a.call(finder, name, type);
            },
        };
    }
    var init_finder = __esm({
        'src/ts/ui/actions/finder.ts'() {
            'use strict';
            init_helpers();
        },
    });

    // src/ts/ui/actions/preview.ts
    function getPreviewActions() {
        return {
            openWithPreview: params => {
                safeExecute('openWithPreview', () => {
                    var _a, _b, _c;
                    const single = params['url'] || params['src'] || params['imageUrl'];
                    const csv = params['urls'] || params['images'];
                    const idx = parseInt(params['index'] || '0', 10) || 0;
                    const path = params['path'] || params['imagePath'];
                    const preview = getGlobal('PreviewInstanceManager');
                    const finder = getGlobal('FinderSystem');
                    if (single) {
                        const list = [single];
                        (_a = preview == null ? void 0 : preview.openImages) == null
                            ? void 0
                            : _a.call(preview, list, 0, path);
                        return;
                    }
                    if (csv) {
                        const list = csv
                            .split(',')
                            .map(s => s.trim())
                            .filter(Boolean);
                        if (list.length) {
                            (_b = preview == null ? void 0 : preview.openImages) == null
                                ? void 0
                                : _b.call(
                                      preview,
                                      list,
                                      Math.max(0, Math.min(idx, list.length - 1)),
                                      path
                                  );
                        }
                        return;
                    }
                    const itemName = params['itemName'] || params['name'];
                    if (itemName) {
                        (_c = finder == null ? void 0 : finder.openItem) == null
                            ? void 0
                            : _c.call(finder, itemName, 'file');
                    }
                });
            },
        };
    }
    var init_preview = __esm({
        'src/ts/ui/actions/preview.ts'() {
            'use strict';
            init_helpers();
        },
    });

    // src/ts/ui/actions/session.ts
    function getSessionActions() {
        return {
            'session:export': () => {
                var _a, _b;
                const W = getGlobal('');
                const translate2 =
                    ((_a = W == null ? void 0 : W.appI18n) == null ? void 0 : _a.translate) ||
                    (k => k);
                if (
                    !((_b = W == null ? void 0 : W.SessionManager) == null
                        ? void 0
                        : _b.exportSession)
                ) {
                    console.error('SessionManager not available');
                    return;
                }
                const json = W.SessionManager.exportSession();
                if (!json) {
                    alert(translate2('menu.session.noSession'));
                    return;
                }
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `session-${/* @__PURE__ */ new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                console.log('Session exported successfully');
            },
            'session:import': () => {
                var _a, _b;
                const W = getGlobal('');
                const translate2 =
                    ((_a = W == null ? void 0 : W.appI18n) == null ? void 0 : _a.translate) ||
                    (k => k);
                if (
                    !((_b = W == null ? void 0 : W.SessionManager) == null
                        ? void 0
                        : _b.importSession)
                ) {
                    console.error('SessionManager not available');
                    return;
                }
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'application/json,.json';
                input.onchange = e => {
                    var _a2;
                    const file = (_a2 = e.target.files) == null ? void 0 : _a2[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = event => {
                        var _a3, _b2, _c;
                        const json = (_a3 = event.target) == null ? void 0 : _a3.result;
                        if (typeof json !== 'string') {
                            alert(translate2('menu.session.importError'));
                            return;
                        }
                        const success =
                            (_c = (_b2 = W.SessionManager) == null ? void 0 : _b2.importSession) ==
                            null
                                ? void 0
                                : _c.call(_b2, json);
                        if (success) {
                            console.log('Session imported successfully');
                        } else {
                            alert(translate2('menu.session.importError'));
                        }
                    };
                    reader.onerror = () => {
                        alert(translate2('menu.session.importError'));
                    };
                    reader.readAsText(file);
                };
                input.click();
            },
        };
    }
    var init_session = __esm({
        'src/ts/ui/actions/session.ts'() {
            'use strict';
            init_helpers();
        },
    });

    // src/ts/ui/desktop.ts
    var desktop_exports = {};
    __export(desktop_exports, {
        DESKTOP_SHORTCUTS: () => DESKTOP_SHORTCUTS,
        handleDesktopShortcutClick: () => handleDesktopShortcutClick,
        initDesktop: () => initDesktop,
        renderDesktopShortcuts: () => renderDesktopShortcuts,
    });
    function renderDesktopShortcuts(container) {
        container.innerHTML = '';
        DESKTOP_SHORTCUTS.forEach(shortcut => {
            const el = document.createElement('button');
            el.className = 'desktop-icon-button';
            el.setAttribute('data-action', 'openDesktopItem');
            el.setAttribute('data-item-id', shortcut.id);
            el.setAttribute(
                'aria-label',
                translate(shortcut.labelKey, {}, { fallback: shortcut.fallbackLabel })
            );
            const graphicDiv = document.createElement('div');
            graphicDiv.className = 'desktop-icon-graphic';
            if (shortcut.icon) {
                const img = document.createElement('img');
                img.src = shortcut.icon;
                img.alt = translate(shortcut.labelKey, {}, { fallback: shortcut.fallbackLabel });
                graphicDiv.appendChild(img);
            } else if (shortcut.emoji) {
                graphicDiv.textContent = shortcut.emoji;
            }
            el.appendChild(graphicDiv);
            const label = document.createElement('span');
            label.className = 'desktop-icon-label';
            label.textContent = translate(
                shortcut.labelKey,
                {},
                { fallback: shortcut.fallbackLabel }
            );
            el.appendChild(label);
            container.appendChild(el);
        });
    }
    function handleDesktopShortcutClick(id) {
        const shortcut = DESKTOP_SHORTCUTS.find(s => s.id === id);
        if (shortcut && shortcut.onOpen) {
            shortcut.onOpen();
        }
    }
    function initDesktop() {
        const container = document.getElementById('desktop-icons');
        if (container) {
            renderDesktopShortcuts(container);
        }
    }
    var API, DESKTOP_SHORTCUTS;
    var init_desktop = __esm({
        'src/ts/ui/desktop.ts'() {
            'use strict';
            init_i18n();
            API = window.API;
            DESKTOP_SHORTCUTS = [
                {
                    id: 'projects',
                    emoji: '\u{1F4C1}',
                    labelKey: 'desktop.projects',
                    fallbackLabel: 'Projekte',
                    onOpen: () => {
                        var _a, _b;
                        const W = window;
                        if ((_a = W.FinderWindow) == null ? void 0 : _a.focusOrCreate) {
                            W.FinderWindow.focusOrCreate();
                        }
                        const w = window;
                        if ((_b = w.FinderSystem) == null ? void 0 : _b.navigateTo) {
                            w.FinderSystem.navigateTo('projects');
                        }
                    },
                },
                // {
                //     id: 'settings',
                //     emoji: '',
                //     labelKey: 'desktop.settings',
                //     fallbackLabel: 'Einstellungen',
                //     onOpen: () => API?.window.open('settings-modal'),
                // },
            ];
            if (typeof window !== 'undefined') {
                window.DesktopSystem = {
                    initDesktop,
                };
            }
        },
    });

    // src/ts/ui/actions/windows.ts
    function getWindowActions() {
        return {
            closeWindow: params => {
                var _a, _b, _c, _d;
                const windowId = params.windowId;
                if (!windowId) {
                    console.warn('closeWindow: missing windowId');
                    return;
                }
                const wm = getGlobal('WindowManager');
                (_a = wm == null ? void 0 : wm.close) == null ? void 0 : _a.call(wm, windowId);
                const g = getGlobal('');
                (_b = g == null ? void 0 : g.saveOpenModals) == null ? void 0 : _b.call(g);
                (_c = g == null ? void 0 : g.updateDockIndicators) == null ? void 0 : _c.call(g);
                (_d = g == null ? void 0 : g.updateProgramLabelByTopModal) == null
                    ? void 0
                    : _d.call(g);
            },
            openWindow: params => {
                var _a, _b, _c, _d;
                const windowId = params.windowId;
                const launchpadModal = document.getElementById('launchpad-modal');
                if (launchpadModal && !launchpadModal.classList.contains('hidden')) {
                    const dialogs = getGlobal('dialogs');
                    (_b =
                        (_a = dialogs == null ? void 0 : dialogs['launchpad-modal']) == null
                            ? void 0
                            : _a.close) == null
                        ? void 0
                        : _b.call(_a);
                }
                if (!windowId) {
                    const finder = getGlobal('FinderWindow');
                    if (finder == null ? void 0 : finder.focusOrCreate) {
                        finder.focusOrCreate();
                        return;
                    }
                    console.warn(
                        '[ActionBus] openWindow called without windowId and FinderWindow not available'
                    );
                    return;
                }
                if (windowId === 'finder-modal') {
                    safeExecute('[ActionBus] openWindow finder-modal', () => {
                        const finder = getGlobal('FinderWindow');
                        if (finder == null ? void 0 : finder.focusOrCreate) {
                            finder.focusOrCreate();
                            return;
                        }
                        console.warn(
                            '[ActionBus] FinderWindow not available; falling back to WindowManager.open("finder-modal")'
                        );
                    });
                }
                if (windowId === 'terminal-modal') {
                    safeExecute('[ActionBus] openWindow terminal-modal', () => {
                        const terminal = getGlobal('TerminalWindow');
                        if (terminal == null ? void 0 : terminal.focusOrCreate) {
                            terminal.focusOrCreate();
                            return;
                        }
                        console.warn(
                            '[ActionBus] TerminalWindow not available; falling back to WindowManager.open("terminal-modal")'
                        );
                    });
                }
                const wm = getGlobal('WindowManager');
                (_c = wm == null ? void 0 : wm.open) == null ? void 0 : _c.call(wm, windowId);
                const g = getGlobal('');
                (_d = g == null ? void 0 : g.updateProgramLabelByTopModal) == null
                    ? void 0
                    : _d.call(g);
            },
            closeTopWindow: () => {
                var _a, _b, _c, _d, _e, _f, _g, _h;
                const g = getGlobal('');
                (_a = g == null ? void 0 : g.hideMenuDropdowns) == null ? void 0 : _a.call(g);
                const maybeTop =
                    (_c =
                        (_b = g == null ? void 0 : g.WindowManager) == null
                            ? void 0
                            : _b.getTopWindow) == null
                        ? void 0
                        : _c.call(_b);
                let topId = null;
                if (typeof maybeTop === 'string') {
                    topId = maybeTop;
                } else if (maybeTop && typeof maybeTop === 'object') {
                    const obj = maybeTop;
                    if (typeof obj.id === 'string') topId = obj.id;
                }
                if (!topId) return;
                (_e = (_d = g == null ? void 0 : g.WindowManager) == null ? void 0 : _d.close) ==
                null
                    ? void 0
                    : _e.call(_d, topId);
                (_f = g == null ? void 0 : g.saveOpenModals) == null ? void 0 : _f.call(g);
                (_g = g == null ? void 0 : g.updateDockIndicators) == null ? void 0 : _g.call(g);
                (_h = g == null ? void 0 : g.updateProgramLabelByTopModal) == null
                    ? void 0
                    : _h.call(g);
            },
            resetWindowLayout: () => {
                var _a, _b;
                const g = getGlobal('');
                (_a = g == null ? void 0 : g.hideMenuDropdowns) == null ? void 0 : _a.call(g);
                (_b = g == null ? void 0 : g.resetWindowLayout) == null ? void 0 : _b.call(g);
            },
            openProgramInfo: () => {
                var _a, _b;
                const g = getGlobal('');
                (_a = g == null ? void 0 : g.hideMenuDropdowns) == null ? void 0 : _a.call(g);
                (_b = g == null ? void 0 : g.openProgramInfoDialog) == null
                    ? void 0
                    : _b.call(g, null);
            },
            openAbout: () => {
                var _a, _b, _c, _d, _e;
                const g = getGlobal('');
                (_a = g == null ? void 0 : g.hideMenuDropdowns) == null ? void 0 : _a.call(g);
                (_d =
                    (_c =
                        (_b = g == null ? void 0 : g.dialogs) == null
                            ? void 0
                            : _b['about-modal']) == null
                        ? void 0
                        : _c.open) == null
                    ? void 0
                    : _d.call(_c);
                (_e = g == null ? void 0 : g.updateProgramLabelByTopModal) == null
                    ? void 0
                    : _e.call(g);
            },
            openSettings: () => {
                var _a, _b, _c, _d, _e;
                const g = getGlobal('');
                (_a = g == null ? void 0 : g.hideMenuDropdowns) == null ? void 0 : _a.call(g);
                (_d =
                    (_c =
                        (_b = g == null ? void 0 : g.dialogs) == null
                            ? void 0
                            : _b['settings-modal']) == null
                        ? void 0
                        : _c.open) == null
                    ? void 0
                    : _d.call(_c);
                (_e = g == null ? void 0 : g.updateProgramLabelByTopModal) == null
                    ? void 0
                    : _e.call(g);
            },
            openDesktopItem: params => {
                const itemId = params.itemId;
                if (!itemId) {
                    console.warn('openDesktopItem: missing itemId');
                    return;
                }
                Promise.resolve()
                    .then(() => (init_desktop(), desktop_exports))
                    .then(({ DESKTOP_SHORTCUTS: DESKTOP_SHORTCUTS2 }) => {
                        const shortcut = DESKTOP_SHORTCUTS2.find(s => s.id === itemId);
                        if (shortcut == null ? void 0 : shortcut.onOpen) {
                            shortcut.onOpen();
                        } else {
                            console.warn(`openDesktopItem: no shortcut found for id "${itemId}"`);
                        }
                    });
            },
        };
    }
    var init_windows = __esm({
        'src/ts/ui/actions/windows.ts'() {
            'use strict';
            init_helpers();
        },
    });

    // src/ts/ui/action-bus.ts
    var require_action_bus = __commonJS({
        'src/ts/ui/action-bus.ts'() {
            'use strict';
            init_helpers();
            init_finder();
            init_preview();
            init_session();
            init_windows();
            console.log('ActionBus loaded');
            (function () {
                'use strict';
                const actionHandlers = /* @__PURE__ */ new Map();
                const eventDelegates = [];
                const ActionBus = {
                    register(actionName, handler) {
                        if (!actionName || typeof handler !== 'function') {
                            console.error('Invalid action registration:', actionName);
                            return;
                        }
                        actionHandlers.set(actionName, handler);
                    },
                    registerAll(actions) {
                        Object.entries(actions).forEach(([name, handler]) => {
                            this.register(name, handler);
                        });
                    },
                    execute(actionName, params = {}, element = null) {
                        const handler = actionHandlers.get(actionName);
                        if (!handler) {
                            console.warn(`No handler registered for action: ${actionName}`);
                            return;
                        }
                        try {
                            handler(params, element);
                        } catch (error) {
                            console.error(`Error executing action ${actionName}:`, error);
                        }
                    },
                    init() {
                        this.delegateEvent('click', '[data-action]', (element, event) => {
                            const actionName = element.getAttribute('data-action');
                            const params = extractParams(element.dataset);
                            if (element.tagName === 'BUTTON' || element.tagName === 'A') {
                                event.preventDefault();
                            }
                            event.stopPropagation();
                            this.execute(actionName, params, element);
                        });
                        this.delegateEvent(
                            'dblclick',
                            '[data-action-dblclick]',
                            (element, event) => {
                                const actionName = element.getAttribute('data-action-dblclick');
                                const params = extractParams(element.dataset);
                                if (element.tagName === 'BUTTON' || element.tagName === 'A') {
                                    event.preventDefault();
                                }
                                event.stopPropagation();
                                this.execute(actionName, params, element);
                            }
                        );
                        this.delegateEvent('mouseenter', '[data-action-hover]', element => {
                            const actionName = element.getAttribute('data-action-hover');
                            const params = extractParams(element.dataset);
                            this.execute(actionName, params, element);
                        });
                        console.log('ActionBus initialized');
                    },
                    delegateEvent(eventType, selector, handler) {
                        const delegate = event => {
                            const target = event.target;
                            if (!(target instanceof Element)) return;
                            const element = target.closest(selector);
                            if (element) {
                                handler(element, event);
                            }
                        };
                        document.addEventListener(eventType, delegate);
                        eventDelegates.push({ eventType, delegate });
                    },
                    extractParams(element) {
                        return extractParams(element.dataset);
                    },
                    destroy() {
                        eventDelegates.forEach(({ eventType, delegate }) => {
                            document.removeEventListener(eventType, delegate);
                        });
                        eventDelegates.length = 0;
                        actionHandlers.clear();
                    },
                };
                ActionBus.registerAll({
                    ...getPreviewActions(),
                    ...getWindowActions(),
                    ...getFinderActions(),
                    ...getSessionActions(),
                });
                window.ActionBus = ActionBus;
            })();
        },
    });

    // src/ts/ui/dialog-utils.ts
    function getModalIds() {
        const win = window;
        if (win.WindowManager && typeof win.WindowManager.getAllWindowIds === 'function') {
            return win.WindowManager.getAllWindowIds();
        }
        const w = window;
        const appConstants = w.APP_CONSTANTS;
        return (appConstants == null ? void 0 : appConstants.MODAL_IDS) || [];
    }
    function syncTopZIndexWithDOM() {
        const win = window;
        if (win.WindowManager && typeof win.WindowManager.syncZIndexWithDOM === 'function') {
            win.WindowManager.syncZIndexWithDOM();
            return;
        }
        let maxZ = 1e3;
        const modalIds = getModalIds();
        modalIds.forEach(id => {
            const modal = document.getElementById(id);
            if (!modal) return;
            const modalZ = parseInt(window.getComputedStyle(modal).zIndex, 10);
            if (!Number.isNaN(modalZ)) {
                maxZ = Math.max(maxZ, modalZ);
            }
        });
        const w = window;
        if (w.topZIndex !== void 0) {
            w.topZIndex = maxZ;
        }
    }
    function bringDialogToFront(dialogId) {
        var _a, _b, _c;
        if ((_a = window.dialogs) == null ? void 0 : _a[dialogId]) {
            (_c = (_b = window.dialogs[dialogId]).bringToFront) == null ? void 0 : _c.call(_b);
        } else {
            console.error('Kein Dialog mit der ID ' + dialogId + ' gefunden.');
        }
    }
    function bringAllWindowsToFront() {
        const modalIds = getModalIds();
        if (!window.dialogs || !modalIds || !Array.isArray(modalIds)) return;
        modalIds.forEach(id => {
            var _a;
            const dialog = (_a = window.dialogs) == null ? void 0 : _a[id];
            if (
                dialog &&
                dialog.modal &&
                !dialog.modal.classList.contains('hidden') &&
                typeof dialog.bringToFront === 'function'
            ) {
                dialog.bringToFront();
            }
        });
    }
    var init_dialog_utils = __esm({
        'src/ts/ui/dialog-utils.ts'() {
            'use strict';
            (() => {
                if (typeof window.syncTopZIndexWithDOM !== 'function') {
                    window.syncTopZIndexWithDOM = syncTopZIndexWithDOM;
                }
                if (typeof window.bringDialogToFront !== 'function') {
                    window.bringDialogToFront = bringDialogToFront;
                }
                if (typeof window.bringAllWindowsToFront !== 'function') {
                    window.bringAllWindowsToFront = bringAllWindowsToFront;
                }
            })();
        },
    });

    // src/ts/ui/snap-utils.ts
    var require_snap_utils = __commonJS({
        'src/ts/ui/snap-utils.ts'() {
            'use strict';
            (function () {
                'use strict';
                function getMenuBarBottom() {
                    const header = document.querySelector('body > header');
                    if (!header) {
                        return 0;
                    }
                    const rect = header.getBoundingClientRect();
                    return rect.bottom;
                }
                function clampWindowToMenuBar(target) {
                    if (!target) return;
                    const minTop = getMenuBarBottom();
                    if (minTop <= 0) return;
                    const computed = window.getComputedStyle(target);
                    if (computed.position === 'static') {
                        target.style.position = 'fixed';
                    }
                    const currentTop = parseFloat(target.style.top);
                    const numericTop = Number.isNaN(currentTop)
                        ? parseFloat(computed.top)
                        : currentTop;
                    if (!Number.isNaN(numericTop) && numericTop < minTop) {
                        target.style.top = `${minTop}px`;
                    } else if (Number.isNaN(numericTop)) {
                        const rect = target.getBoundingClientRect();
                        if (rect.top < minTop) {
                            if (!target.style.left) {
                                target.style.left = `${rect.left}px`;
                            }
                            target.style.top = `${minTop}px`;
                        }
                    }
                }
                function computeSnapMetrics(side) {
                    if (side !== 'left' && side !== 'right') return null;
                    const minTop = Math.round(getMenuBarBottom());
                    const viewportWidth = Math.max(window.innerWidth || 0, 0);
                    const viewportHeight = Math.max(window.innerHeight || 0, 0);
                    if (viewportWidth <= 0 || viewportHeight <= 0) return null;
                    const minWidth = Math.min(320, viewportWidth);
                    const halfWidth = Math.round(viewportWidth / 2);
                    const width = Math.max(Math.min(halfWidth, viewportWidth), minWidth);
                    const left = side === 'left' ? 0 : Math.max(0, viewportWidth - width);
                    const top = minTop;
                    const getDockReservedBottom2 = window.getDockReservedBottom;
                    const dockReserve =
                        typeof getDockReservedBottom2 === 'function' ? getDockReservedBottom2() : 0;
                    const height = Math.max(0, viewportHeight - top - dockReserve);
                    return { left, top, width, height };
                }
                let snapPreviewElement = null;
                function ensureSnapPreviewElement() {
                    if (snapPreviewElement && snapPreviewElement.isConnected) {
                        return snapPreviewElement;
                    }
                    if (!document || !document.body) {
                        return null;
                    }
                    snapPreviewElement = document.getElementById('snap-preview-overlay');
                    if (!snapPreviewElement) {
                        snapPreviewElement = document.createElement('div');
                        snapPreviewElement.id = 'snap-preview-overlay';
                        snapPreviewElement.setAttribute('aria-hidden', 'true');
                        document.body.appendChild(snapPreviewElement);
                    }
                    return snapPreviewElement;
                }
                function showSnapPreview(side) {
                    const metrics = computeSnapMetrics(side);
                    if (!metrics) {
                        hideSnapPreview();
                        return;
                    }
                    const el = ensureSnapPreviewElement();
                    if (!el) return;
                    el.style.left = `${metrics.left}px`;
                    el.style.top = `${metrics.top}px`;
                    el.style.width = `${metrics.width}px`;
                    el.style.height = `${metrics.height}px`;
                    el.setAttribute('data-side', side);
                    el.classList.add('snap-preview-visible');
                }
                function hideSnapPreview() {
                    if (!snapPreviewElement || !snapPreviewElement.isConnected) {
                        return;
                    }
                    snapPreviewElement.classList.remove('snap-preview-visible');
                    snapPreviewElement.removeAttribute('data-side');
                }
                const g = window;
                if (typeof g.getMenuBarBottom !== 'function') {
                    g.getMenuBarBottom = getMenuBarBottom;
                }
                if (typeof g.clampWindowToMenuBar !== 'function') {
                    g.clampWindowToMenuBar = clampWindowToMenuBar;
                }
                if (typeof g.computeSnapMetrics !== 'function') {
                    g.computeSnapMetrics = computeSnapMetrics;
                }
                if (typeof g.showSnapPreview !== 'function') {
                    g.showSnapPreview = showSnapPreview;
                }
                if (typeof g.hideSnapPreview !== 'function') {
                    g.hideSnapPreview = hideSnapPreview;
                }
            })();
        },
    });

    // src/ts/services/program-actions.ts
    var require_program_actions = __commonJS({
        'src/ts/services/program-actions.ts'() {
            'use strict';
            (function () {
                'use strict';
                const gw = window;
                function getTextEditorIframe() {
                    const dialogs = gw.dialogs;
                    const dialog = dialogs ? dialogs['text-modal'] : null;
                    if (!dialog || !dialog.modal) return null;
                    return dialog.modal.querySelector('iframe');
                }
                function postToTextEditor(message, attempt = 0) {
                    if (!message || typeof message !== 'object') return;
                    const legacy = gw.postToTextEditor;
                    if (typeof legacy === 'function') {
                        legacy(message);
                        return;
                    }
                    const iframe = getTextEditorIframe();
                    if (iframe && iframe.contentWindow) {
                        let targetOrigin = '*';
                        if (
                            window.location &&
                            typeof window.location.origin === 'string' &&
                            window.location.origin !== 'null'
                        ) {
                            targetOrigin = window.location.origin;
                        }
                        iframe.contentWindow.postMessage(message, targetOrigin);
                        return;
                    }
                    if (attempt < 10) {
                        setTimeout(() => postToTextEditor(message, attempt + 1), 120);
                    } else {
                        console.warn(
                            'Texteditor iframe nicht verf\xFCgbar, Nachricht verworfen.',
                            message
                        );
                    }
                }
                function sendTextEditorMenuAction2(command) {
                    if (!command) return;
                    postToTextEditor({ type: 'textEditor:menuAction', command });
                }
                function getImageViewerState() {
                    const viewer = document.getElementById('image-viewer');
                    if (!viewer) return { hasImage: false, src: '' };
                    const hidden = viewer.classList.contains('hidden');
                    const src = viewer.getAttribute('src') || viewer.src || '';
                    const hasImage = Boolean(src && src.trim() && !hidden);
                    return { hasImage, src };
                }
                function openActiveImageInNewTab() {
                    const state = getImageViewerState();
                    if (!state.hasImage || !state.src) return;
                    window.open(state.src, '_blank', 'noopener');
                }
                function downloadActiveImage() {
                    const state = getImageViewerState();
                    if (!state.hasImage || !state.src) return;
                    const link = document.createElement('a');
                    link.href = state.src;
                    let fileName = 'bild';
                    try {
                        const url = new URL(state.src, window.location.href);
                        fileName = url.pathname.split('/').pop() || fileName;
                    } catch {
                        fileName = 'bild';
                    }
                    link.download = fileName || 'bild';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }
                if (typeof gw.getImageViewerState !== 'function')
                    gw.getImageViewerState = getImageViewerState;
                if (typeof gw.openActiveImageInNewTab !== 'function')
                    gw.openActiveImageInNewTab = openActiveImageInNewTab;
                if (typeof gw.downloadActiveImage !== 'function')
                    gw.downloadActiveImage = downloadActiveImage;
                if (typeof gw.sendTextEditorMenuAction !== 'function')
                    gw.sendTextEditorMenuAction = sendTextEditorMenuAction2;
            })();
        },
    });

    // src/ts/services/program-menu-sync.ts
    var require_program_menu_sync = __commonJS({
        'src/ts/services/program-menu-sync.ts'() {
            'use strict';
            (function () {
                'use strict';
                function resolveProgramInfo(modalId) {
                    const wm = window.WindowManager;
                    if (wm && typeof wm.getProgramInfo === 'function') {
                        return wm.getProgramInfo(modalId);
                    }
                    const translate2 = window.translate;
                    const t2 = (k, fb) => (translate2 ? translate2(k, fb) : fb || k);
                    return {
                        modalId: modalId || null,
                        programLabel: t2('programs.default.label'),
                        infoLabel: t2('programs.default.infoLabel'),
                        fallbackInfoModalId: 'program-info-modal',
                        icon: './img/sucher.png',
                        about: {},
                    };
                }
                function updateProgramLabel(newLabel) {
                    const programLabel = document.getElementById('program-label');
                    if (programLabel) programLabel.textContent = newLabel;
                }
                function getTopModal() {
                    const wm = window.WindowManager;
                    if (wm && typeof wm.getTopWindow === 'function') {
                        return wm.getTopWindow();
                    }
                    let top = null;
                    let highest = 0;
                    document.querySelectorAll('.modal:not(.hidden)').forEach(modal => {
                        const z = parseInt(getComputedStyle(modal).zIndex, 10) || 0;
                        if (z > highest) {
                            highest = z;
                            top = modal;
                        }
                    });
                    return top;
                }
                function updateProgramInfoMenu(info) {
                    const infoLink = document.getElementById('about-program');
                    if (!infoLink) return;
                    const fallbackInfo = resolveProgramInfo(null);
                    infoLink.textContent = info.infoLabel || fallbackInfo.infoLabel;
                    const el = infoLink;
                    if (info.fallbackInfoModalId) {
                        el.dataset.fallbackInfoModalId = info.fallbackInfoModalId;
                    } else if (el.dataset) {
                        delete el.dataset.fallbackInfoModalId;
                    }
                }
                function renderProgramInfo(info) {
                    const modal = document.getElementById('program-info-modal');
                    if (!modal) return;
                    modal.dataset.infoTarget = info.modalId || '';
                    const fallbackInfo = resolveProgramInfo(null);
                    const about = info.about || fallbackInfo.about || {};
                    const iconEl = modal.querySelector('#program-info-icon');
                    if (iconEl) {
                        if (info.icon) {
                            iconEl.src = info.icon;
                            iconEl.alt = about.name || info.programLabel || 'Programm';
                            iconEl.classList.remove('hidden');
                        } else {
                            iconEl.classList.add('hidden');
                        }
                    }
                    const nameEl = modal.querySelector('#program-info-name');
                    if (nameEl) {
                        nameEl.textContent =
                            about.name || info.programLabel || fallbackInfo.programLabel;
                    }
                    const taglineEl = modal.querySelector('#program-info-tagline');
                    if (taglineEl) {
                        const tagline = about.tagline || '';
                        taglineEl.textContent = tagline;
                        taglineEl.classList.toggle('hidden', !tagline);
                    }
                    const versionEl = modal.querySelector('#program-info-version');
                    if (versionEl) {
                        const version = about.version || '';
                        versionEl.textContent = version;
                        versionEl.classList.toggle('hidden', !version);
                    }
                    const copyrightEl = modal.querySelector('#program-info-copyright');
                    if (copyrightEl) {
                        const copyright = about.copyright || '';
                        copyrightEl.textContent = copyright;
                        copyrightEl.classList.toggle('hidden', !copyright);
                    }
                }
                function renderApplicationMenu2(modalId) {
                    const MenuSystem = window.MenuSystem;
                    if (MenuSystem && typeof MenuSystem.renderApplicationMenu === 'function') {
                        MenuSystem.renderApplicationMenu(modalId);
                    }
                }
                function getProgramInfo(modalId) {
                    return resolveProgramInfo(modalId);
                }
                function openProgramInfoDialog(event, infoOverride) {
                    var _a, _b;
                    if (event) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                    const hideMenus = window.hideMenuDropdowns;
                    if (hideMenus) hideMenus();
                    const info = infoOverride || currentProgramInfo || getProgramInfo(null);
                    currentProgramInfo = info;
                    const infoEvent = new CustomEvent('programInfoRequested', {
                        detail: { modalId: info.modalId, info },
                        cancelable: true,
                    });
                    const dispatchResult = window.dispatchEvent(infoEvent);
                    if (!dispatchResult) return;
                    const fallbackId = info.fallbackInfoModalId;
                    if (!fallbackId) return;
                    if (fallbackId === 'program-info-modal') {
                        renderProgramInfo(info);
                    }
                    const dialogs = window.dialogs;
                    const dialogInstance = dialogs && dialogs[fallbackId];
                    if (dialogInstance && typeof dialogInstance.open === 'function') {
                        dialogInstance.open();
                    } else {
                        const modalElement = document.getElementById(fallbackId);
                        if (modalElement) {
                            modalElement.classList.remove('hidden');
                            const bringToFront =
                                (_b = (_a = window.dialogs) == null ? void 0 : _a[fallbackId]) ==
                                null
                                    ? void 0
                                    : _b.bringToFront;
                            if (bringToFront) bringToFront();
                            updateProgramLabelByTopModal();
                        }
                    }
                }
                function openProgramInfoFromMenu(targetModalId) {
                    const info = resolveProgramInfo(targetModalId || null);
                    openProgramInfoDialog(null, info);
                }
                let currentProgramInfo = resolveProgramInfo(null);
                function updateProgramLabelByTopModal() {
                    const topModal = getTopModal();
                    const wm = window.WindowManager;
                    if (topModal && wm) {
                        const config = wm.getConfig(topModal.id);
                        if (config && config.metadata && config.metadata.skipMenubarUpdate) {
                            const all = Array.from(
                                document.querySelectorAll('.modal:not(.hidden)')
                            );
                            const sorted = all.sort(
                                (a, b) =>
                                    (parseInt(getComputedStyle(b).zIndex, 10) || 0) -
                                    (parseInt(getComputedStyle(a).zIndex, 10) || 0)
                            );
                            let next = null;
                            for (const m of sorted) {
                                const mc = wm.getConfig(m.id);
                                if (!mc || !mc.metadata || !mc.metadata.skipMenubarUpdate) {
                                    next = m;
                                    break;
                                }
                            }
                            if (next) {
                                const info2 = getProgramInfo(next.id);
                                currentProgramInfo = info2;
                                updateProgramLabel(info2.programLabel);
                                updateProgramInfoMenu(info2);
                                renderApplicationMenu2(next.id);
                                return info2;
                            }
                        }
                    }
                    let info;
                    if (
                        topModal &&
                        topModal.id === 'program-info-modal' &&
                        currentProgramInfo &&
                        currentProgramInfo.modalId
                    ) {
                        info = resolveProgramInfo(currentProgramInfo.modalId);
                        currentProgramInfo = info;
                    } else {
                        info = getProgramInfo(topModal ? topModal.id : null);
                        currentProgramInfo = info;
                    }
                    updateProgramLabel(info.programLabel);
                    updateProgramInfoMenu(info);
                    renderApplicationMenu2(topModal ? topModal.id : null);
                    return info;
                }
                const alreadyWired = window.__programMenuSyncWired;
                if (!alreadyWired) {
                    window.__programMenuSyncWired = true;
                }
                if (!alreadyWired)
                    window.addEventListener('languagePreferenceChange', () => {
                        const info = updateProgramLabelByTopModal();
                        const programInfoModal = document.getElementById('program-info-modal');
                        if (programInfoModal && !programInfoModal.classList.contains('hidden')) {
                            const ds = programInfoModal.dataset;
                            const targetId =
                                ds['infoTarget'] || (info ? info.modalId : null) || null;
                            const infoForDialog = resolveProgramInfo(targetId);
                            renderProgramInfo(infoForDialog);
                            if (info && info.modalId === infoForDialog.modalId) {
                                currentProgramInfo = infoForDialog;
                            }
                        }
                        const updateAllSystemStatusUI = window.updateAllSystemStatusUI;
                        if (updateAllSystemStatusUI) updateAllSystemStatusUI();
                    });
                if (!alreadyWired)
                    window.addEventListener('themePreferenceChange', () => {
                        const updateAllSystemStatusUI = window.updateAllSystemStatusUI;
                        if (updateAllSystemStatusUI) updateAllSystemStatusUI();
                    });
                window.updateProgramLabelByTopModal = updateProgramLabelByTopModal;
                window.openProgramInfoFromMenu = openProgramInfoFromMenu;
            })();
        },
    });

    // src/ts/ui/menu.ts
    function registerMenuAction(handler) {
        if (typeof handler !== 'function') return null;
        const actionId = `menu-action-${++menuActionIdCounter}`;
        menuActionHandlers.set(actionId, handler);
        return actionId;
    }
    function normalizeMenuItems(items, context) {
        var _a;
        if (!Array.isArray(items)) return [];
        const normalized = [];
        let previousWasSeparator = true;
        items.forEach(raw => {
            const item = raw;
            if (!item) return;
            if (item.type === 'separator') {
                if (previousWasSeparator) return;
                normalized.push({ type: 'separator' });
                previousWasSeparator = true;
                return;
            }
            const clone = Object.assign({}, item);
            if (typeof item.disabled === 'function') clone.disabled = item.disabled(context);
            if (typeof item.label === 'function') clone.label = item.label(context);
            if (typeof item.shortcut === 'function') clone.shortcut = item.shortcut(context);
            normalized.push(clone);
            previousWasSeparator = false;
        });
        while (
            normalized.length &&
            ((_a = normalized[normalized.length - 1]) == null ? void 0 : _a.type) === 'separator'
        )
            normalized.pop();
        return normalized;
    }
    function buildDefaultMenuDefinition(context) {
        return buildFinderMenuDefinition(context);
    }
    function buildFinderMenuDefinition(context) {
        return [
            {
                id: 'file',
                label: () => translate('menu.sections.file'),
                items: [
                    {
                        id: 'finder-new-window',
                        label: () => translate('menu.finder.newWindow'),
                        shortcut: '\u2318N',
                        icon: 'new',
                        action: () => {
                            var _a, _b;
                            if (
                                window['FinderWindow'] &&
                                typeof window['FinderWindow'].create === 'function'
                            ) {
                                const registry2 = window['WindowRegistry'];
                                const count =
                                    ((_a = registry2 == null ? void 0 : registry2.getWindowCount) ==
                                    null
                                        ? void 0
                                        : _a.call(registry2, 'finder')) || 0;
                                window['FinderWindow'].create({
                                    title: `Finder ${count + 1}`,
                                });
                            } else {
                                const mgr = window['FinderInstanceManager'];
                                if (mgr && typeof mgr.createInstance === 'function') {
                                    const count = mgr.getInstanceCount
                                        ? mgr.getInstanceCount()
                                        : ((_b = mgr.getAllInstances) == null
                                              ? void 0
                                              : _b.call(mgr).length) || 0;
                                    mgr.createInstance({ title: `Finder ${count + 1}` });
                                }
                            }
                        },
                    },
                    {
                        id: 'finder-reload',
                        label: () => translate('menu.finder.reload'),
                        shortcut: '\u2318R',
                        icon: 'reload',
                        action: () => {
                            if (
                                window['FinderSystem'] &&
                                typeof window['FinderSystem'].navigateTo === 'function'
                            ) {
                                try {
                                    const st =
                                        window['FinderSystem'].getState &&
                                        window['FinderSystem'].getState();
                                    if (st && Array.isArray(st.githubRepos)) st.githubRepos = [];
                                    window['FinderSystem'].navigateTo([], 'github');
                                } catch (e) {
                                    console.warn('Finder reload failed', e);
                                }
                            }
                        },
                    },
                    { type: 'separator' },
                    {
                        id: 'session-export',
                        label: () => translate('menu.session.export'),
                        icon: 'save',
                        action: () => {
                            const actionBus = window['ActionBus'];
                            if (actionBus && typeof actionBus.execute === 'function') {
                                actionBus.execute('session:export');
                            }
                        },
                    },
                    {
                        id: 'session-import',
                        label: () => translate('menu.session.import'),
                        icon: 'open',
                        action: () => {
                            const actionBus = window['ActionBus'];
                            if (actionBus && typeof actionBus.execute === 'function') {
                                actionBus.execute('session:import');
                            }
                        },
                    },
                    { type: 'separator' },
                    {
                        id: 'finder-close',
                        label: () => translate('menu.finder.close'),
                        shortcut: '\u2318W',
                        disabled: () => !(context && context.dialog),
                        icon: 'close',
                        action: () => closeContextWindow(context),
                    },
                ],
            },
            createWindowMenuSection(context),
            createHelpMenuSection(context, {
                itemKey: 'menu.finder.help',
                itemIcon: 'help',
            }),
        ];
    }
    function buildSettingsMenuDefinition(context) {
        return [
            {
                id: 'file',
                label: () => translate('menu.sections.file'),
                items: [
                    {
                        id: 'settings-close',
                        label: () => translate('menu.settings.close'),
                        shortcut: '\u2318W',
                        disabled: () => !(context && context.dialog),
                        icon: 'close',
                        action: () => closeContextWindow(context),
                    },
                ],
            },
            createWindowMenuSection(context),
            createHelpMenuSection(context, {
                itemKey: 'menu.settings.help',
                infoModalId: 'settings-modal',
                itemIcon: 'help',
            }),
        ];
    }
    function buildTextEditorMenuDefinition(context) {
        return [
            {
                id: 'file',
                label: () => translate('menu.sections.file'),
                items: [
                    {
                        id: 'text-new',
                        label: () => translate('menu.text.newFile'),
                        shortcut: '\u2318N',
                        icon: 'newFile',
                        action: () => {
                            var _a;
                            if (
                                window['TextEditorWindow'] &&
                                typeof window['TextEditorWindow'].create === 'function'
                            ) {
                                const registry2 = window['WindowRegistry'];
                                const count =
                                    ((_a = registry2 == null ? void 0 : registry2.getWindowCount) ==
                                    null
                                        ? void 0
                                        : _a.call(registry2, 'text-editor')) || 0;
                                window['TextEditorWindow'].create({
                                    title: `Untitled ${count + 1}`,
                                });
                            } else {
                                sendTextEditorMenuAction('file:new');
                            }
                        },
                    },
                    {
                        id: 'text-open',
                        label: () => translate('menu.text.open'),
                        shortcut: '\u2318O',
                        icon: 'open',
                        action: () => sendTextEditorMenuAction('file:open'),
                    },
                    {
                        id: 'text-save',
                        label: () => translate('menu.text.save'),
                        shortcut: '\u2318S',
                        icon: 'save',
                        action: () => sendTextEditorMenuAction('file:save'),
                    },
                ],
            },
            {
                id: 'edit',
                label: () => translate('menu.sections.edit'),
                items: [
                    {
                        id: 'text-undo',
                        label: () => translate('menu.text.undo'),
                        shortcut: '\u2318Z',
                        icon: 'undo',
                        action: () => sendTextEditorMenuAction('edit:undo'),
                    },
                    {
                        id: 'text-redo',
                        label: () => translate('menu.text.redo'),
                        shortcut: '\u21E7\u2318Z',
                        icon: 'redo',
                        action: () => sendTextEditorMenuAction('edit:redo'),
                    },
                    { type: 'separator' },
                    {
                        id: 'text-cut',
                        label: () => translate('menu.text.cut'),
                        shortcut: '\u2318X',
                        icon: 'cut',
                        action: () => sendTextEditorMenuAction('edit:cut'),
                    },
                    {
                        id: 'text-copy',
                        label: () => translate('menu.text.copy'),
                        shortcut: '\u2318C',
                        icon: 'copy',
                        action: () => sendTextEditorMenuAction('edit:copy'),
                    },
                    {
                        id: 'text-paste',
                        label: () => translate('menu.text.paste'),
                        shortcut: '\u2318V',
                        icon: 'paste',
                        action: () => sendTextEditorMenuAction('edit:paste'),
                    },
                    { type: 'separator' },
                    {
                        id: 'text-select-all',
                        label: () => translate('menu.text.selectAll'),
                        shortcut: '\u2318A',
                        icon: 'selectAll',
                        action: () => sendTextEditorMenuAction('edit:selectAll'),
                    },
                ],
            },
            {
                id: 'view',
                label: () => translate('menu.sections.view'),
                items: [
                    {
                        id: 'text-toggle-wrap',
                        label: () => translate('menu.text.toggleWrap'),
                        shortcut: '\u2325\u2318W',
                        icon: 'wrap',
                        action: () => sendTextEditorMenuAction('view:toggleWrap'),
                    },
                ],
            },
            createWindowMenuSection(context),
            createHelpMenuSection(context, {
                itemKey: 'menu.text.help',
                infoModalId: 'text-modal',
                itemIcon: 'help',
            }),
        ];
    }
    function buildImageViewerMenuDefinition(context) {
        const state = window['getImageViewerState']
            ? window['getImageViewerState']()
            : { hasImage: false };
        return [
            {
                id: 'file',
                label: () => translate('menu.sections.file'),
                items: [
                    {
                        id: 'image-open-tab',
                        label: () => translate('menu.image.openInTab'),
                        disabled: !state.hasImage,
                        icon: 'imageOpen',
                        action: () => {
                            if (window['openActiveImageInNewTab'])
                                window['openActiveImageInNewTab']();
                        },
                    },
                    {
                        id: 'image-download',
                        label: () => translate('menu.image.saveImage'),
                        disabled: !state.hasImage,
                        icon: 'download',
                        action: () => {
                            if (window['downloadActiveImage']) window['downloadActiveImage']();
                        },
                    },
                    { type: 'separator' },
                    {
                        id: 'image-close',
                        label: () => translate('menu.image.close'),
                        shortcut: '\u2318W',
                        disabled: () => !(context && context.dialog),
                        icon: 'close',
                        action: () => closeContextWindow(context),
                    },
                ],
            },
            createWindowMenuSection(context),
            createHelpMenuSection(context, {
                itemKey: 'menu.image.help',
                infoModalId: 'image-modal',
                itemIcon: 'help',
            }),
        ];
    }
    function buildAboutMenuDefinition(context) {
        return [
            {
                id: 'file',
                label: () => translate('menu.sections.file'),
                items: [
                    {
                        id: 'about-close',
                        label: () => translate('menu.about.close'),
                        shortcut: '\u2318W',
                        disabled: () => !(context && context.dialog),
                        icon: 'close',
                        action: () => closeContextWindow(context),
                    },
                ],
            },
            createWindowMenuSection(context),
            createHelpMenuSection(context, {
                itemKey: 'menu.about.help',
                infoModalId: 'about-modal',
                itemIcon: 'info',
            }),
        ];
    }
    function buildProgramInfoMenuDefinition(context) {
        return [
            {
                id: 'file',
                label: () => translate('menu.sections.file'),
                items: [
                    {
                        id: 'program-info-close',
                        label: () => translate('menu.programInfo.close'),
                        shortcut: '\u2318W',
                        disabled: () => !(context && context.dialog),
                        icon: 'close',
                        action: () => closeContextWindow(context),
                    },
                ],
            },
            createWindowMenuSection(context),
        ];
    }
    function buildTerminalMenuDefinition(context) {
        var _a;
        const registry2 = window['WindowRegistry'];
        const activeWin =
            (_a = registry2 == null ? void 0 : registry2.getActiveWindow) == null
                ? void 0
                : _a.call(registry2);
        const isTerminalActive = (activeWin == null ? void 0 : activeWin.type) === 'terminal';
        const terminalWin = isTerminalActive ? activeWin : null;
        return [
            {
                id: 'file',
                label: () => translate('menu.sections.file'),
                items: [
                    // New Terminal Window
                    {
                        id: 'terminal-new-window',
                        label: () => translate('menu.terminal.newWindow'),
                        shortcut: '\u2318N',
                        icon: 'new',
                        action: () => {
                            var _a2, _b, _c;
                            if ((_a2 = window['TerminalWindow']) == null ? void 0 : _a2.create) {
                                const count =
                                    ((_b = registry2 == null ? void 0 : registry2.getWindowCount) ==
                                    null
                                        ? void 0
                                        : _b.call(registry2, 'terminal')) || 0;
                                window['TerminalWindow'].create({ title: `Terminal ${count + 1}` });
                            } else if (
                                (_c = window['TerminalInstanceManager']) == null
                                    ? void 0
                                    : _c.createInstance
                            ) {
                                window['TerminalInstanceManager'].createInstance();
                            }
                        },
                    },
                    // New Tab in active Terminal window
                    {
                        id: 'terminal-new-tab',
                        label: () => translate('menu.terminal.newTab'),
                        shortcut: '\u2318T',
                        icon: 'tabNew',
                        disabled: () => !terminalWin,
                        action: () => {
                            if (terminalWin == null ? void 0 : terminalWin.createSession)
                                terminalWin.createSession();
                        },
                    },
                    // Duplicate current tab
                    {
                        id: 'terminal-duplicate-tab',
                        label: () => translate('menu.terminal.duplicateTab'),
                        shortcut: '\u2325\u2318D',
                        icon: 'tabDuplicate',
                        disabled: () => !terminalWin || !terminalWin.activeTabId,
                        action: () => {
                            const activeId = terminalWin == null ? void 0 : terminalWin.activeTabId;
                            if (!activeId) return;
                            const tabs = terminalWin.tabs;
                            const orig = tabs.get(activeId);
                            if (orig && terminalWin.createSession) {
                                const newSession = terminalWin.createSession(orig.title + ' Copy');
                                if (orig.buffer && newSession && newSession.appendOutput) {
                                    newSession.appendOutput(orig.buffer);
                                }
                            }
                        },
                    },
                    { type: 'separator' },
                    // Close current tab (W). If only one tab: close window.
                    {
                        id: 'terminal-close-tab',
                        label: () => translate('menu.terminal.closeTab'),
                        shortcut: '\u2318W',
                        icon: 'tabClose',
                        disabled: () => !terminalWin || !terminalWin.activeTabId,
                        action: () => {
                            var _a2;
                            if (!terminalWin) return;
                            const tabs = terminalWin.tabs;
                            if (tabs.size <= 1) {
                                (_a2 = terminalWin.close) == null ? void 0 : _a2.call(terminalWin);
                                return;
                            }
                            const activeId = terminalWin.activeTabId;
                            if (activeId) terminalWin.removeTab(activeId);
                        },
                    },
                    // Close entire window (W)
                    {
                        id: 'terminal-close-window',
                        label: () => translate('menu.terminal.closeWindow'),
                        shortcut: '\u21E7\u2318W',
                        icon: 'close',
                        disabled: () => !(context && context.dialog),
                        action: () => closeContextWindow(context),
                    },
                ],
            },
            {
                id: 'edit',
                label: () => translate('menu.sections.edit'),
                items: [
                    // Clear terminal scrollback/output
                    {
                        id: 'terminal-clear',
                        label: () => translate('menu.terminal.clear'),
                        shortcut: '\u2318K',
                        icon: 'clear',
                        action: () => {
                            if (!terminalWin) return;
                            const activeId = terminalWin.activeTabId;
                            const tabs = terminalWin.tabs;
                            const tab = activeId ? tabs.get(activeId) : null;
                            const inst = tab || null;
                            if (inst == null ? void 0 : inst.clearOutput) inst.clearOutput();
                        },
                    },
                    { type: 'separator' },
                    // Basic clipboard actions (delegate to focused input)
                    {
                        id: 'terminal-copy',
                        label: () => translate('menu.terminal.copy'),
                        shortcut: '\u2318C',
                        icon: 'copy',
                        action: () => {
                            var _a2;
                            const input = document.querySelector('#terminal-input');
                            if (input) input.select();
                            (_a2 = document.execCommand) == null
                                ? void 0
                                : _a2.call(document, 'copy');
                        },
                    },
                    {
                        id: 'terminal-paste',
                        label: () => translate('menu.terminal.paste'),
                        shortcut: '\u2318V',
                        icon: 'paste',
                        action: async () => {
                            const input = document.querySelector('#terminal-input');
                            if (!input) return;
                            try {
                                const text = await navigator.clipboard.readText();
                                input.value += text;
                                input.dispatchEvent(new Event('input'));
                            } catch (e) {
                                console.warn('Clipboard read failed', e);
                            }
                        },
                    },
                    {
                        id: 'terminal-select-all',
                        label: () => translate('menu.terminal.selectAll'),
                        shortcut: '\u2318A',
                        icon: 'selectAll',
                        action: () => {
                            const input = document.querySelector('#terminal-input');
                            if (input) input.select();
                        },
                    },
                ],
            },
            createWindowMenuSection(context),
            createHelpMenuSection(context, {
                itemKey: 'menu.terminal.help',
                infoModalId: 'terminal-modal',
                itemIcon: 'help',
            }),
        ];
    }
    function createWindowMenuSection(context) {
        return {
            id: 'window',
            label: () => translate('menu.sections.window'),
            items: getWindowMenuItems(context),
        };
    }
    function getWindowMenuItems(context) {
        const dialog = context && context.dialog;
        const hasDialog = Boolean(dialog && typeof dialog.close === 'function');
        const items = [
            {
                id: 'window-minimize',
                label: () => translate('menu.window.minimize'),
                shortcut: '\u2318M',
                disabled: !hasDialog,
                icon: 'windowMinimize',
                action: () => {
                    if (dialog && typeof dialog.minimize === 'function') dialog.minimize();
                },
            },
            {
                id: 'window-zoom',
                label: () => translate('menu.window.zoom'),
                shortcut: '\u2303\u2318F',
                disabled: !hasDialog,
                icon: 'windowZoom',
                action: () => {
                    if (dialog && typeof dialog.toggleMaximize === 'function')
                        dialog.toggleMaximize();
                },
            },
        ];
        const multiInstanceItems = getMultiInstanceMenuItems(context);
        if (multiInstanceItems.length > 0) {
            items.push({ type: 'separator' });
            items.push(...multiInstanceItems);
        }
        items.push(
            { type: 'separator' },
            {
                id: 'window-all-front',
                label: () => translate('menu.window.bringToFront'),
                disabled: !hasAnyVisibleDialog(),
                icon: 'windowFront',
                action: () => {
                    if (window['bringAllWindowsToFront']) window['bringAllWindowsToFront']();
                },
            },
            { type: 'separator' },
            {
                id: 'window-close',
                label: () => translate('menu.window.close'),
                shortcut: '\u2318W',
                disabled: !hasDialog,
                icon: 'close',
                action: () => closeContextWindow(context),
            }
        );
        return items;
    }
    function getMultiInstanceMenuItems(context) {
        var _a, _b, _c;
        const items = [];
        let manager = null;
        let typeLabel = null;
        let newInstanceKey = null;
        const modalId = context == null ? void 0 : context.modalId;
        const registry2 = window['WindowRegistry'];
        const activeWindowType =
            ((_b =
                (_a = registry2 == null ? void 0 : registry2.getActiveWindow) == null
                    ? void 0
                    : _a.call(registry2)) == null
                ? void 0
                : _b.type) || null;
        if (modalId === 'terminal-modal' || activeWindowType === 'terminal') {
            const terminalWindow = window['TerminalWindow'];
            if (registry2 && terminalWindow) {
                typeLabel = 'Terminal';
                newInstanceKey = 'menu.window.newTerminal';
                items.push({
                    id: 'window-new-instance',
                    label: () => translate(newInstanceKey || 'menu.window.newWindow'),
                    shortcut: '\u2318N',
                    icon: 'new',
                    action: () => {
                        var _a2;
                        const count =
                            ((_a2 = registry2.getWindowCount) == null
                                ? void 0
                                : _a2.call(registry2, 'terminal')) || 0;
                        terminalWindow.create({ title: `Terminal ${count + 1}` });
                    },
                });
                const windows =
                    ((_c = registry2.getAllWindows) == null
                        ? void 0
                        : _c.call(registry2, 'terminal')) || [];
                if (windows.length > 1) {
                    items.push({ type: 'separator' });
                    windows.forEach((win, index) => {
                        var _a2, _b2;
                        const isActive =
                            ((_b2 =
                                (_a2 = registry2.getActiveWindow) == null
                                    ? void 0
                                    : _a2.call(registry2)) == null
                                ? void 0
                                : _b2.windowId) === win.windowId;
                        const numberLabel = `Terminal ${index + 1}`;
                        items.push({
                            id: `window-instance-${win.windowId}`,
                            label: () => `${isActive ? '\u2713 ' : ''}${numberLabel}`,
                            shortcut: index < 9 ? `\u2318${index + 1}` : void 0,
                            action: () => {
                                var _a3;
                                (_a3 = win.focus) == null ? void 0 : _a3.call(win);
                            },
                        });
                    });
                    items.push(
                        { type: 'separator' },
                        {
                            id: 'window-close-all',
                            label: () => translate('menu.window.closeAll'),
                            icon: 'close',
                            action: () => {
                                if (
                                    confirm(`Alle ${windows.length} Terminal-Fenster schlie\xDFen?`)
                                ) {
                                    windows.forEach(w => {
                                        var _a2;
                                        return (_a2 = w.close) == null ? void 0 : _a2.call(w);
                                    });
                                }
                            },
                        }
                    );
                }
                return items;
            }
        }
        if (modalId === 'projects-modal' && window['FinderInstanceManager']) {
            manager = window['FinderInstanceManager'];
            typeLabel = 'Finder';
            newInstanceKey = 'menu.window.newFinder';
        } else if (modalId === 'terminal-modal' && window['TerminalInstanceManager']) {
            manager = window['TerminalInstanceManager'];
            typeLabel = 'Terminal';
            newInstanceKey = 'menu.window.newTerminal';
        } else if (modalId === 'text-modal' && window['TextEditorInstanceManager']) {
            manager = window['TextEditorInstanceManager'];
            typeLabel = 'Editor';
            newInstanceKey = 'menu.window.newEditor';
        }
        if (!manager) return items;
        items.push({
            id: 'window-new-instance',
            label: () => translate(newInstanceKey || 'menu.window.newWindow'),
            shortcut: '\u2318N',
            icon: 'new',
            action: () => {
                const count = manager.getInstanceCount();
                manager.createInstance({ title: `${typeLabel} ${count + 1}` });
            },
        });
        const instances = manager.getAllInstances();
        if (instances.length > 1) {
            items.push({ type: 'separator' });
            instances.forEach((instance, index) => {
                var _a2;
                const isActive =
                    ((_a2 = manager.getActiveInstance()) == null ? void 0 : _a2.instanceId) ===
                    instance.instanceId;
                const numberLabel = `${typeLabel} ${index + 1}`;
                items.push({
                    id: `window-instance-${instance.instanceId}`,
                    label: () => `${isActive ? '\u2713 ' : ''}${numberLabel}`,
                    shortcut: index < 9 ? `\u2318${index + 1}` : void 0,
                    action: () => {
                        manager.setActiveInstance(instance.instanceId);
                        const integration = window.multiInstanceIntegration;
                        if (
                            integration &&
                            typeof integration.updateInstanceVisibility === 'function'
                        ) {
                            let type = null;
                            if (manager === window.FinderInstanceManager) type = 'finder';
                            else if (manager === window.TerminalInstanceManager) type = 'terminal';
                            else if (manager === window.TextEditorInstanceManager)
                                type = 'text-editor';
                            if (type) {
                                integration.updateInstanceVisibility(type);
                            }
                        }
                    },
                });
            });
            items.push(
                { type: 'separator' },
                {
                    id: 'window-close-all',
                    label: () => translate('menu.window.closeAll'),
                    icon: 'close',
                    action: () => {
                        var _a2, _b2;
                        const base = translate('menu.window.closeAllConfirm');
                        const confirmMsg =
                            typeof base === 'string' && base !== 'menu.window.closeAllConfirm'
                                ? base
                                : `Close all ${typeLabel} (${instances.length})?`;
                        if (confirm(confirmMsg)) {
                            manager.destroyAllInstances();
                            const targetModal = context == null ? void 0 : context.modalId;
                            if (targetModal) {
                                if (
                                    typeof ((_b2 =
                                        (_a2 = window['API']) == null ? void 0 : _a2.window) == null
                                        ? void 0
                                        : _b2.close) === 'function'
                                ) {
                                    window['API'].window.close(targetModal);
                                } else {
                                    const el = document.getElementById(targetModal);
                                    if (el && !el.classList.contains('hidden')) {
                                        const domUtils = window.DOMUtils;
                                        if (domUtils && typeof domUtils.hide === 'function') {
                                            domUtils.hide(el);
                                        } else {
                                            el.classList.add('hidden');
                                        }
                                    }
                                }
                            }
                        }
                    },
                }
            );
        }
        return items;
    }
    function createHelpMenuSection(context, overrides = {}) {
        const sectionKey = overrides.sectionKey || 'menu.sections.help';
        const itemKey = overrides.itemKey || 'menu.help.showHelp';
        const infoModalId = overrides.infoModalId || context.modalId || null;
        return {
            id: overrides.id || 'help',
            label: () => translate(sectionKey),
            items: [
                {
                    id: 'help-show-info',
                    label: () => translate(itemKey),
                    icon: overrides.itemIcon || 'help',
                    action: () => {
                        if (window['openProgramInfoFromMenu'])
                            window['openProgramInfoFromMenu'](infoModalId);
                    },
                },
            ],
        };
    }
    function renderApplicationMenu(activeModalId) {
        var _a, _b;
        const container = document.getElementById('menubar-links');
        if (!container) return;
        const registry2 = window.WindowRegistry;
        const activeType =
            (_b =
                (_a = registry2 == null ? void 0 : registry2.getActiveWindow) == null
                    ? void 0
                    : _a.call(registry2)) == null
                ? void 0
                : _b.type;
        if (activeType === 'terminal' && activeModalId !== 'terminal-modal') {
            activeModalId = 'terminal-modal';
        }
        const modalKey =
            activeModalId && menuDefinitions[activeModalId] ? activeModalId : 'default';
        const builder = menuDefinitions[modalKey] || menuDefinitions.default;
        const context = createMenuContext(activeModalId || null);
        const sections =
            typeof builder === 'function'
                ? builder(context)
                : Array.isArray(builder)
                  ? builder
                  : [];
        container.innerHTML = '';
        menuActionHandlers.clear();
        menuActionIdCounter = 0;
        currentMenuModalId = activeModalId || null;
        if (!Array.isArray(sections) || sections.length === 0) return;
        sections.forEach((section, sectionIndex) => {
            if (!section) return;
            const items = normalizeMenuItems(section.items, context);
            if (!items.length) return;
            const trigger = document.createElement('div');
            trigger.className = 'menubar-trigger';
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'menubar-item';
            button.dataset.menubarTriggerButton = 'true';
            const label =
                typeof section.label === 'function' ? section.label(context) : section.label;
            button.textContent = label || '';
            const sectionId = section.id || `section-${sectionIndex}`;
            const buttonId = `menubar-menu-${sectionId}`;
            const dropdownId = `menu-dropdown-${sectionId}`;
            button.id = buttonId;
            button.setAttribute('aria-haspopup', 'menu');
            button.setAttribute('aria-expanded', 'false');
            button.setAttribute('aria-controls', dropdownId);
            const dropdown = document.createElement('ul');
            dropdown.id = dropdownId;
            dropdown.className = 'menu-dropdown hidden';
            dropdown.setAttribute('role', 'menu');
            dropdown.setAttribute('aria-labelledby', buttonId);
            items.forEach(item => {
                if (item.type === 'separator') {
                    const separator = document.createElement('li');
                    separator.className = 'menu-separator';
                    separator.setAttribute('role', 'separator');
                    separator.setAttribute('aria-hidden', 'true');
                    dropdown.appendChild(separator);
                    return;
                }
                const li = document.createElement('li');
                li.setAttribute('role', 'none');
                const tagName = item.href ? 'a' : 'button';
                const actionEl = document.createElement(tagName);
                actionEl.className = 'menu-item';
                if (tagName === 'button') actionEl.type = 'button';
                else {
                    actionEl.href = item.href;
                    if (item.external) {
                        actionEl.rel = 'noopener noreferrer';
                        actionEl.target = '_blank';
                    }
                }
                const itemLabel =
                    item.label !== null
                        ? typeof item.label === 'function'
                            ? item.label(context)
                            : item.label
                        : '';
                const labelSpan = document.createElement('span');
                labelSpan.className = 'menu-item-label';
                if (item.icon && window.IconSystem) {
                    const iconSpan = document.createElement('span');
                    iconSpan.className = 'menu-item-icon';
                    const iconSvg = window.IconSystem.getMenuIconSvg
                        ? window.IconSystem.getMenuIconSvg(item.icon)
                        : '';
                    if (window.IconSystem.renderIconIntoElement)
                        window.IconSystem.renderIconIntoElement(iconSpan, iconSvg, item.icon);
                    labelSpan.appendChild(iconSpan);
                }
                labelSpan.appendChild(document.createTextNode(itemLabel));
                actionEl.appendChild(labelSpan);
                if (item.shortcut) {
                    const shortcutSpan = document.createElement('span');
                    shortcutSpan.className = 'menu-item-shortcut';
                    shortcutSpan.textContent =
                        typeof item.shortcut === 'function' ? item.shortcut() : item.shortcut;
                    actionEl.appendChild(shortcutSpan);
                }
                actionEl.setAttribute('role', 'menuitem');
                if (item.title) actionEl.title = item.title;
                const isDisabled = Boolean(item.disabled);
                if (isDisabled) {
                    actionEl.setAttribute('aria-disabled', 'true');
                    if (tagName === 'button') actionEl.disabled = true;
                } else if (typeof item.action === 'function') {
                    const actionId = registerMenuAction(item.action);
                    if (actionId) actionEl.dataset.menuAction = actionId;
                }
                if (item.href && typeof item.onClick === 'function') {
                    actionEl.addEventListener('click', event => {
                        const result = item.onClick(event);
                        if (result === false) event.preventDefault();
                    });
                }
                li.appendChild(actionEl);
                dropdown.appendChild(li);
            });
            if (!dropdown.childElementCount) return;
            trigger.appendChild(button);
            trigger.appendChild(dropdown);
            container.appendChild(trigger);
            if (window.bindDropdownTrigger)
                window.bindDropdownTrigger(button, { hoverRequiresOpen: true });
        });
    }
    function handleMenuActionActivation(event) {
        const target =
            event.target instanceof Element ? event.target.closest('[data-menu-action]') : null;
        if (!target) return;
        const actionId = target.getAttribute('data-menu-action');
        const handler = actionId ? menuActionHandlers.get(actionId) : null;
        if (typeof handler !== 'function') return;
        event.preventDefault();
        event.stopPropagation();
        if (window.hideMenuDropdowns) window.hideMenuDropdowns();
        try {
            handler();
        } catch (err) {
            console.error('Error executing menu action:', err);
        }
    }
    function closeContextWindow(context) {
        const dialog = context && context.dialog;
        if (dialog && typeof dialog.close === 'function') dialog.close();
    }
    function hasAnyVisibleDialog() {
        if (!window['dialogs']) return false;
        return Object.values(window['dialogs']).some(d =>
            d && typeof d.isOpen === 'function' ? d.isOpen() : Boolean(d && d.isOpen)
        );
    }
    function sendTextEditorMenuAction(actionType) {
        if (window.sendTextEditorMenuAction) window.sendTextEditorMenuAction(actionType);
    }
    function createMenuContext(modalId) {
        const w = window;
        if (w.createMenuContext && w.createMenuContext !== createMenuContext) {
            try {
                return w.createMenuContext(modalId);
            } catch (e) {
                console.warn('[Menu] createMenuContext override threw; falling back', e);
            }
        }
        return { modalId, dialog: null };
    }
    function refreshCurrentMenu() {
        renderApplicationMenu(currentMenuModalId);
    }
    function setupInstanceManagerListeners() {
        const managers = [
            window['FinderInstanceManager'],
            window['TerminalInstanceManager'],
            window['TextEditorInstanceManager'],
        ];
        managers.forEach(manager => {
            if (!manager || !manager.getAllInstances) return;
            const originalCreate = manager.createInstance;
            const originalDestroy = manager.destroyInstance;
            const originalDestroyAll = manager.destroyAllInstances;
            if (originalCreate)
                manager.createInstance = function (...args) {
                    const result = originalCreate.apply(this, args);
                    if (result) setTimeout(refreshCurrentMenu, 50);
                    return result;
                };
            if (originalDestroy)
                manager.destroyInstance = function (...args) {
                    const result = originalDestroy.apply(this, args);
                    setTimeout(refreshCurrentMenu, 50);
                    return result;
                };
            if (originalDestroyAll)
                manager.destroyAllInstances = function (...args) {
                    const result = originalDestroyAll.apply(this, args);
                    setTimeout(refreshCurrentMenu, 50);
                    return result;
                };
        });
    }
    var menuActionHandlers, menuActionIdCounter, menuDefinitions, currentMenuModalId;
    var init_menu = __esm({
        'src/ts/ui/menu.ts'() {
            'use strict';
            init_i18n();
            menuActionHandlers = /* @__PURE__ */ new Map();
            menuActionIdCounter = 0;
            menuDefinitions = {
                default: buildDefaultMenuDefinition,
                'projects-modal': buildFinderMenuDefinition,
                'settings-modal': buildSettingsMenuDefinition,
                'text-modal': buildTextEditorMenuDefinition,
                'image-modal': buildImageViewerMenuDefinition,
                'about-modal': buildAboutMenuDefinition,
                'program-info-modal': buildProgramInfoMenuDefinition,
                'terminal-modal': buildTerminalMenuDefinition,
            };
            currentMenuModalId = null;
            if (document.readyState === 'loading')
                document.addEventListener('DOMContentLoaded', setupInstanceManagerListeners);
            else setTimeout(setupInstanceManagerListeners, 100);
            window.MenuSystem = {
                renderApplicationMenu,
                handleMenuActionActivation,
                menuDefinitions,
                getCurrentMenuModalId: () => currentMenuModalId,
            };
            console.log('\u2705 MenuSystem loaded');
        },
    });

    // src/ts/ui/dock.ts
    function getDockReservedBottom() {
        try {
            const dock = document.getElementById('dock');
            if (!dock || dock.classList.contains('hidden')) return 0;
            const rect = dock.getBoundingClientRect();
            const vh = Math.max(window.innerHeight || 0, 0);
            if (vh <= 0) return 0;
            return Math.round(Math.max(0, vh - rect.top));
        } catch {
            return 0;
        }
    }
    function initDockMagnification() {
        const dock = document.getElementById('dock');
        if (!dock) return;
        const icons = Array.from(dock.querySelectorAll('.dock-icon'));
        if (!icons.length) return;
        const items = icons.map(icon => {
            const parent = icon.parentElement;
            const tooltip = parent ? parent.querySelector('.dock-tooltip') : null;
            return {
                icon,
                tooltip,
                baseHeight: icon.offsetHeight || 0,
            };
        });
        let rafId = null;
        let pointerX = null;
        const maxScale = 1.6;
        const minScale = 1;
        const radius = 120;
        const sigma = radius / 3;
        const apply = () => {
            rafId = null;
            if (pointerX === null) {
                items.forEach(({ icon, tooltip }) => {
                    icon.style.transform = '';
                    icon.style.zIndex = '';
                    if (tooltip) {
                        tooltip.style.transform = '';
                        tooltip.style.zIndex = '';
                    }
                });
                return;
            }
            items.forEach(({ icon, tooltip, baseHeight }) => {
                const rect = icon.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const dx = Math.abs(pointerX - centerX);
                const influence = Math.exp(-(dx * dx) / (2 * sigma * sigma));
                const scale = Math.max(
                    minScale,
                    Math.min(maxScale, minScale + (maxScale - minScale) * influence)
                );
                const base = baseHeight || icon.offsetHeight || 0;
                const translateY = Math.max(0, (scale - 1) * base * 0.5);
                icon.style.transform = `translateY(-${translateY.toFixed(1)}px) scale(${scale.toFixed(3)})`;
                icon.style.zIndex = scale > 1.01 ? '300' : '';
                if (tooltip) {
                    const lift = Math.max(0, base * (scale - 1) - translateY);
                    const gap = 12;
                    tooltip.style.transform = `translateY(-${(lift + gap).toFixed(1)}px)`;
                    tooltip.style.zIndex = '400';
                }
            });
        };
        const onMove = e => {
            pointerX = e.clientX;
            if (!rafId) rafId = requestAnimationFrame(apply);
        };
        const onLeave = () => {
            pointerX = null;
            if (!rafId) rafId = requestAnimationFrame(apply);
        };
        dock.addEventListener('mousemove', onMove);
        dock.addEventListener('mouseleave', onLeave);
    }
    function loadDockOrder() {
        try {
            const parsed = getJSON(DOCK_ORDER_STORAGE_KEY, null);
            return Array.isArray(parsed) ? parsed : null;
        } catch {
            return null;
        }
    }
    function saveDockOrder(order) {
        try {
            setJSON(DOCK_ORDER_STORAGE_KEY, order || []);
        } catch {}
    }
    function getDockItemId(item) {
        if (!item) return null;
        return item.getAttribute('data-window-id') || null;
    }
    function getCurrentDockOrder() {
        const tray = document.querySelector('#dock .dock-tray');
        if (!tray) return [];
        return Array.from(tray.querySelectorAll('.dock-item'))
            .map(it => getDockItemId(it))
            .filter(Boolean);
    }
    function applyDockOrder(order) {
        if (!Array.isArray(order) || !order.length) return;
        const tray = document.querySelector('#dock .dock-tray');
        if (!tray) return;
        const items = Array.from(tray.querySelectorAll('.dock-item'));
        const map = new Map(items.map(it => [getDockItemId(it), it]));
        const fragment = document.createDocumentFragment();
        order.forEach(id => {
            const el = map.get(id);
            if (el) {
                fragment.appendChild(el);
                map.delete(id);
            }
        });
        for (const [, el] of map) fragment.appendChild(el);
        tray.appendChild(fragment);
    }
    function createPlaceholder(width, height) {
        const ph = document.createElement('div');
        ph.className = 'dock-placeholder';
        ph.setAttribute('aria-hidden', 'true');
        ph.style.width = Math.max(1, Math.round(width || 48)) + 'px';
        ph.style.height = Math.max(1, Math.round(height || 48)) + 'px';
        ph.style.opacity = '0';
        ph.style.pointerEvents = 'none';
        return ph;
    }
    function initDockDragDrop() {
        const dock = document.getElementById('dock');
        const tray = dock ? dock.querySelector('.dock-tray') : null;
        if (!dock || !tray) return;
        const persisted = loadDockOrder();
        if (persisted && persisted.length) applyDockOrder(persisted);
        let draggedItem = null;
        let placeholder = null;
        let prevUserSelect = '';
        let suppressClicksUntil = 0;
        const updatePlaceholderSize = ref => {
            if (!placeholder || !ref) return;
            try {
                const r = ref.getBoundingClientRect();
                placeholder.style.width = r.width + 'px';
                placeholder.style.height = r.height + 'px';
            } catch {}
        };
        const placeRelativeTo = (targetItem, clientX) => {
            if (!tray || !targetItem) return;
            if (!placeholder) placeholder = createPlaceholder();
            updatePlaceholderSize(draggedItem || targetItem);
            const rect = targetItem.getBoundingClientRect();
            const insertBefore = clientX < rect.left + rect.width / 2;
            tray.insertBefore(placeholder, insertBefore ? targetItem : targetItem.nextSibling);
        };
        const handleTrayDragOver = e => {
            if (!draggedItem) return;
            e.preventDefault();
            if (e.dataTransfer) e.dataTransfer.dropEffect = 'move';
            const items = Array.from(tray.querySelectorAll('.dock-item')).filter(
                it => it !== draggedItem
            );
            if (!placeholder) placeholder = createPlaceholder();
            if (items.length === 0) {
                tray.appendChild(placeholder);
                return;
            }
            let target = null;
            for (const it of items) {
                const r = it.getBoundingClientRect();
                if (e.clientX < r.left + r.width / 2) {
                    target = it;
                    break;
                }
            }
            updatePlaceholderSize(draggedItem || items[0]);
            if (target) tray.insertBefore(placeholder, target);
            else tray.appendChild(placeholder);
        };
        const onDragStart = function (e) {
            const item = this.closest('.dock-item');
            if (!item) return;
            draggedItem = item;
            prevUserSelect = document.body.style.userSelect || '';
            document.body.style.userSelect = 'none';
            suppressClicksUntil = Date.now() + 250;
            try {
                const icon = item.querySelector('.dock-icon') || item;
                const r2 = icon.getBoundingClientRect();
                if (e.dataTransfer) {
                    e.dataTransfer.setData('text/plain', getDockItemId(item) || '');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setDragImage(icon, r2.width / 2, r2.height / 2);
                }
            } catch {}
            const r = item.getBoundingClientRect();
            placeholder = createPlaceholder(r.width, r.height);
            tray.insertBefore(placeholder, item.nextSibling);
        };
        const onDragOver = e => {
            if (!draggedItem) return;
            e.preventDefault();
            if (e.dataTransfer) e.dataTransfer.dropEffect = 'move';
            const target = e.target.closest('.dock-item');
            if (!target || target === draggedItem) {
                handleTrayDragOver(e);
                return;
            }
            placeRelativeTo(target, e.clientX);
        };
        const finalizeDrop = () => {
            if (!draggedItem || !placeholder) return;
            tray.insertBefore(draggedItem, placeholder);
            placeholder.remove();
            placeholder = null;
            const order = getCurrentDockOrder();
            saveDockOrder(order);
        };
        const onDrop = e => {
            if (!draggedItem) return;
            e.preventDefault();
            const phDidNotMove =
                placeholder &&
                placeholder.isConnected &&
                (placeholder.previousSibling === draggedItem ||
                    placeholder.nextSibling === draggedItem);
            if (!placeholder || !placeholder.isConnected || phDidNotMove) {
                const x = e.clientX;
                const items = Array.from(tray.querySelectorAll('.dock-item')).filter(
                    it => it !== draggedItem
                );
                let inserted = false;
                for (const it of items) {
                    const r = it.getBoundingClientRect();
                    if (x < r.left + r.width / 2) {
                        tray.insertBefore(draggedItem, it);
                        inserted = true;
                        break;
                    }
                }
                if (!inserted) tray.appendChild(draggedItem);
                const order = getCurrentDockOrder();
                saveDockOrder(order);
                cleanup();
                return;
            }
            finalizeDrop();
        };
        const cleanup = () => {
            if (placeholder && placeholder.isConnected) placeholder.remove();
            placeholder = null;
            draggedItem = null;
            document.body.style.userSelect = prevUserSelect;
        };
        const onDragEnd = () => {
            cleanup();
        };
        dock.addEventListener(
            'click',
            ev => {
                if (Date.now() < suppressClicksUntil || draggedItem) {
                    ev.stopPropagation();
                    ev.preventDefault();
                }
            },
            true
        );
        window.addEventListener('blur', cleanup);
        const enableDraggable = () => {
            tray.querySelectorAll('.dock-item').forEach(it => {
                it.setAttribute('draggable', 'true');
                it.addEventListener('dragstart', onDragStart);
            });
        };
        enableDraggable();
        tray.addEventListener('dragover', onDragOver);
        tray.addEventListener('drop', onDrop);
        tray.addEventListener('dragend', onDragEnd);
    }
    function updateDockIndicators() {
        const W = window;
        const domUtils = W.DOMUtils;
        const indicatorMappings = [
            { indicatorId: 'finder-indicator', windowType: 'finder' },
            { modalId: 'projects-modal', indicatorId: 'projects-indicator' },
            { modalId: 'settings-modal', indicatorId: 'settings-indicator' },
            { modalId: 'text-modal', indicatorId: 'text-indicator', windowType: 'text-editor' },
            {
                modalId: 'terminal-modal',
                indicatorId: 'terminal-indicator',
                windowType: 'terminal',
            },
        ];
        indicatorMappings.forEach(mapping => {
            const indicator = document.getElementById(mapping.indicatorId);
            if (!indicator) return;
            let hasOpenWindow = false;
            if (mapping.windowType && W.WindowRegistry) {
                const windows = W.WindowRegistry.getWindowsByType(mapping.windowType);
                hasOpenWindow = windows && windows.length > 0;
            }
            if (!hasOpenWindow) {
                const modal = mapping.modalId ? document.getElementById(mapping.modalId) : null;
                if (modal) {
                    const minimized = modal.dataset && modal.dataset.minimized === 'true';
                    hasOpenWindow = !modal.classList.contains('hidden') || minimized;
                }
            }
            if (hasOpenWindow) {
                if (domUtils && typeof domUtils.show === 'function') {
                    domUtils.show(indicator);
                } else {
                    indicator.classList.remove('hidden');
                }
            } else {
                if (domUtils && typeof domUtils.hide === 'function') {
                    domUtils.hide(indicator);
                } else {
                    indicator.classList.add('hidden');
                }
            }
        });
    }
    var DOCK_ORDER_STORAGE_KEY;
    var init_dock = __esm({
        'src/ts/ui/dock.ts'() {
            'use strict';
            init_storage_utils();
            DOCK_ORDER_STORAGE_KEY = 'dock:order:v1';
            if (typeof window !== 'undefined') {
                window.DockSystem = {
                    getDockReservedBottom,
                    initDockMagnification,
                    initDockDragDrop,
                    updateDockIndicators,
                    getCurrentDockOrder,
                    loadDockOrder,
                    saveDockOrder,
                    applyDockOrder,
                };
                if (typeof window.updateDockIndicators !== 'function') {
                    window.updateDockIndicators = updateDockIndicators;
                }
            }
        },
    });

    // src/ts/ui/dialog.ts
    var Dialog;
    var init_dialog = __esm({
        'src/ts/ui/dialog.ts'() {
            'use strict';
            init_z_index_manager();
            Dialog = class {
                constructor(modalId) {
                    var _a;
                    this.modalId = modalId;
                    const el = document.getElementById(modalId);
                    if (!el) {
                        console.error(`Dialog: No element found with id "${modalId}"`);
                        throw new Error(`No dialog with id ${modalId}`);
                    }
                    this.modal = el;
                    const helper =
                        (_a = window.StorageSystem) == null ? void 0 : _a.getDialogWindowElement;
                    this.windowEl = helper
                        ? helper(this.modal)
                        : this.modal.querySelector('.autopointer') || this.modal;
                    this.lastDragPointerX = null;
                    this.init();
                }
                init() {
                    this.makeDraggable();
                    this.makeResizable();
                    const closeButton = this.modal.querySelector(
                        '.draggable-header button[id^="close-"]'
                    );
                    if (closeButton) {
                        closeButton.style.cursor = 'pointer';
                        closeButton.dataset.dialogAction = 'close';
                        if (!closeButton.dataset.dialogBoundClose) {
                            closeButton.dataset.dialogBoundClose = 'true';
                            closeButton.addEventListener('click', e => {
                                e.preventDefault();
                                e.stopPropagation();
                                this.close();
                            });
                        }
                    }
                    const minimizeEl = this.modal.querySelector(
                        '.draggable-header .bg-yellow-500.rounded-full'
                    );
                    const maximizeEl = this.modal.querySelector(
                        '.draggable-header .bg-green-500.rounded-full'
                    );
                    if (minimizeEl) {
                        minimizeEl.style.cursor = 'pointer';
                        minimizeEl.title = minimizeEl.title || 'Minimieren';
                        minimizeEl.dataset.dialogAction = 'minimize';
                        minimizeEl.addEventListener('click', e => {
                            e.stopPropagation();
                            this.minimize();
                        });
                    }
                    if (maximizeEl) {
                        maximizeEl.style.cursor = 'pointer';
                        maximizeEl.title = maximizeEl.title || 'Maximieren';
                        maximizeEl.dataset.dialogAction = 'maximize';
                        maximizeEl.addEventListener('click', e => {
                            e.stopPropagation();
                            this.toggleMaximize();
                        });
                    }
                }
                open() {
                    var _a, _b, _c, _d;
                    if (!this.modal) {
                        console.error(
                            `Cannot open dialog: modal element is undefined (id: ${this.modalId})`
                        );
                        return;
                    }
                    this._ensureInstanceIfNeeded();
                    (_a = window.hideMenuDropdowns) == null ? void 0 : _a.call(window);
                    const domUtils = window.DOMUtils;
                    if (domUtils && typeof domUtils.show === 'function') {
                        domUtils.show(this.modal);
                    } else {
                        this.modal.classList.remove('hidden');
                    }
                    if (this.modal && this.modal.dataset) delete this.modal.dataset.minimized;
                    this.bringToFront();
                    this.enforceMenuBarBoundary();
                    (_b = window.saveOpenModals) == null ? void 0 : _b.call(window);
                    (_c = window.updateDockIndicators) == null ? void 0 : _c.call(window);
                    (_d = window.updateProgramLabelByTopModal) == null ? void 0 : _d.call(window);
                }
                _ensureInstanceIfNeeded() {
                    var _a, _b, _c;
                    const win = window;
                    const config =
                        (_b = (_a = win.WindowManager) == null ? void 0 : _a.getConfig) == null
                            ? void 0
                            : _b.call(_a, this.modalId);
                    if (
                        !config ||
                        !((_c = config.metadata) == null ? void 0 : _c.ensureInstanceOnOpen)
                    )
                        return;
                }
                close() {
                    var _a, _b, _c;
                    if (this.modal.classList.contains('hidden')) return;
                    const domUtils = window.DOMUtils;
                    if (domUtils && typeof domUtils.hide === 'function') {
                        domUtils.hide(this.modal);
                    } else {
                        this.modal.classList.add('hidden');
                    }
                    const zIndexManager = getZIndexManager();
                    zIndexManager.removeWindow(this.modal.id);
                    (_a = window.saveOpenModals) == null ? void 0 : _a.call(window);
                    (_b = window.updateDockIndicators) == null ? void 0 : _b.call(window);
                    (_c = window.updateProgramLabelByTopModal) == null ? void 0 : _c.call(window);
                }
                minimize() {
                    var _a, _b, _c;
                    if (this.modal.dataset) this.modal.dataset.minimized = 'true';
                    const domUtils = window.DOMUtils;
                    if (domUtils && typeof domUtils.hide === 'function') {
                        if (!this.modal.classList.contains('hidden')) {
                            domUtils.hide(this.modal);
                        }
                    } else {
                        if (!this.modal.classList.contains('hidden')) {
                            this.modal.classList.add('hidden');
                        }
                    }
                    (_a = window.saveOpenModals) == null ? void 0 : _a.call(window);
                    (_b = window.updateDockIndicators) == null ? void 0 : _b.call(window);
                    (_c = window.updateProgramLabelByTopModal) == null ? void 0 : _c.call(window);
                }
                toggleMaximize() {
                    var _a, _b, _c, _d;
                    const target = this.windowEl || this.modal;
                    if (!target) return;
                    this.unsnap({ silent: true });
                    const ds = this.modal.dataset || {};
                    const isMax = ds.maximized === 'true';
                    if (isMax) {
                        if (ds.prevLeft !== void 0) target.style.left = ds.prevLeft;
                        if (ds.prevTop !== void 0) target.style.top = ds.prevTop;
                        if (ds.prevWidth !== void 0) target.style.width = ds.prevWidth;
                        if (ds.prevHeight !== void 0) target.style.height = ds.prevHeight;
                        if (ds.prevPosition !== void 0) target.style.position = ds.prevPosition;
                        delete ds.maximized;
                        delete ds.prevLeft;
                        delete ds.prevTop;
                        delete ds.prevWidth;
                        delete ds.prevHeight;
                        delete ds.prevPosition;
                        this.enforceMenuBarBoundary();
                        (_a = window.saveWindowPositions) == null ? void 0 : _a.call(window);
                        return;
                    }
                    const computed = window.getComputedStyle(target);
                    this.modal.dataset.prevLeft = target.style.left || computed.left || '';
                    this.modal.dataset.prevTop = target.style.top || computed.top || '';
                    this.modal.dataset.prevWidth = target.style.width || computed.width || '';
                    this.modal.dataset.prevHeight = target.style.height || computed.height || '';
                    this.modal.dataset.prevPosition =
                        target.style.position || computed.position || '';
                    const minTop = Math.round(
                        ((_b = window.getMenuBarBottom) == null ? void 0 : _b.call(window)) || 0
                    );
                    target.style.position = 'fixed';
                    target.style.left = '0px';
                    target.style.top = `${minTop}px`;
                    target.style.width = '100vw';
                    target.style.height = `calc(100vh - ${minTop}px)`;
                    try {
                        const __dockReserve =
                            ((_c = window.getDockReservedBottom) == null
                                ? void 0
                                : _c.call(window)) || 0;
                        const __maxHeight = Math.max(
                            0,
                            (window.innerHeight || 0) - minTop - __dockReserve
                        );
                        target.style.height = `${__maxHeight}px`;
                    } catch {}
                    this.modal.dataset.maximized = 'true';
                    this.bringToFront();
                    (_d = window.saveWindowPositions) == null ? void 0 : _d.call(window);
                }
                snapTo(side, options = {}) {
                    var _a, _b, _c;
                    const target = this.windowEl || this.modal;
                    if (!target) return null;
                    if (side !== 'left' && side !== 'right') return null;
                    const { silent = false } = options;
                    const ds = this.modal.dataset || {};
                    const alreadySnapped = ds.snapped;
                    if (!alreadySnapped) {
                        const computed = window.getComputedStyle(target);
                        ds.prevSnapLeft = target.style.left || computed.left || '';
                        ds.prevSnapTop = target.style.top || computed.top || '';
                        ds.prevSnapWidth = target.style.width || computed.width || '';
                        ds.prevSnapHeight = target.style.height || computed.height || '';
                        ds.prevSnapPosition = target.style.position || computed.position || '';
                        ds.prevSnapRight = target.style.right || computed.right || '';
                        ds.prevSnapBottom = target.style.bottom || computed.bottom || '';
                    }
                    const metrics =
                        (_a = window.computeSnapMetrics) == null ? void 0 : _a.call(window, side);
                    if (!metrics) {
                        this.unsnap({ silent: true });
                        return null;
                    }
                    target.style.position = 'fixed';
                    target.style.top = `${metrics.top}px`;
                    target.style.left = `${metrics.left}px`;
                    target.style.width = `${metrics.width}px`;
                    target.style.height = `${metrics.height}px`;
                    target.style.right = '';
                    target.style.bottom = '';
                    this.modal.dataset.snapped = side;
                    this.bringToFront();
                    (_b = window.hideSnapPreview) == null ? void 0 : _b.call(window);
                    if (!silent)
                        (_c = window.saveWindowPositions) == null ? void 0 : _c.call(window);
                    return side;
                }
                unsnap(options = {}) {
                    var _a, _b;
                    const target = this.windowEl || this.modal;
                    if (!target) return false;
                    const { silent = false } = options;
                    const ds = this.modal.dataset || {};
                    if (!ds.snapped) return false;
                    const restore = (key, prop) => {
                        if (Object.prototype.hasOwnProperty.call(ds, key)) {
                            const value = ds[key];
                            if (value === '') target.style[prop] = '';
                            else target.style[prop] = value;
                            delete ds[key];
                        } else {
                            target.style[prop] = '';
                        }
                    };
                    restore('prevSnapLeft', 'left');
                    restore('prevSnapTop', 'top');
                    restore('prevSnapWidth', 'width');
                    restore('prevSnapHeight', 'height');
                    restore('prevSnapPosition', 'position');
                    restore('prevSnapRight', 'right');
                    restore('prevSnapBottom', 'bottom');
                    delete ds.snapped;
                    (_a = window.hideSnapPreview) == null ? void 0 : _a.call(window);
                    this.enforceMenuBarBoundary();
                    if (!silent)
                        (_b = window.saveWindowPositions) == null ? void 0 : _b.call(window);
                    return true;
                }
                applySnapAfterDrag(target, pointerX) {
                    var _a, _b, _c;
                    if (!target) {
                        (_a = window.hideSnapPreview) == null ? void 0 : _a.call(window);
                        return null;
                    }
                    const candidate = this.getSnapCandidate(target, pointerX);
                    if (candidate) {
                        this.snapTo(candidate, { silent: true });
                        (_b = window.hideSnapPreview) == null ? void 0 : _b.call(window);
                        return candidate;
                    }
                    this.unsnap({ silent: true });
                    (_c = window.hideSnapPreview) == null ? void 0 : _c.call(window);
                    return null;
                }
                getSnapCandidate(target, pointerX) {
                    if (!target) return null;
                    const viewportWidth = Math.max(window.innerWidth || 0, 0);
                    if (viewportWidth <= 0) return null;
                    const threshold = Math.max(3, Math.min(14, viewportWidth * 35e-4));
                    const rect = target.getBoundingClientRect();
                    const pointerDistLeft =
                        typeof pointerX === 'number' ? Math.max(0, pointerX) : Math.abs(rect.left);
                    if (Math.abs(rect.left) <= threshold || pointerDistLeft <= threshold)
                        return 'left';
                    const distRight = viewportWidth - rect.right;
                    const pointerDistRight =
                        typeof pointerX === 'number'
                            ? Math.max(0, viewportWidth - pointerX)
                            : Math.abs(distRight);
                    if (Math.abs(distRight) <= threshold || pointerDistRight <= threshold)
                        return 'right';
                    return null;
                }
                bringToFront() {
                    const zIndexManager = getZIndexManager();
                    zIndexManager.bringToFront(this.modal.id, this.modal, this.windowEl);
                }
                refocus() {
                    var _a, _b, _c;
                    this.bringToFront();
                    (_a = window.hideMenuDropdowns) == null ? void 0 : _a.call(window);
                    (_b = window.saveOpenModals) == null ? void 0 : _b.call(window);
                    (_c = window.updateProgramLabelByTopModal) == null ? void 0 : _c.call(window);
                }
                makeDraggable() {
                    const header = this.modal.querySelector('.draggable-header');
                    const target = this.windowEl || this.modal;
                    if (!header || !target) return;
                    header.style.cursor = 'move';
                    let offsetX = 0,
                        offsetY = 0;
                    header.addEventListener('mousedown', e => {
                        var _a, _b, _c;
                        this.refocus();
                        if (e.target.closest && e.target.closest('button[id^="close-"]')) return;
                        if (e.target.closest && e.target.closest('[data-dialog-action]')) return;
                        if (this.modal.dataset && this.modal.dataset.maximized === 'true') return;
                        const pointerX = e.clientX;
                        const pointerY = e.clientY;
                        const initialSnapSide = this.modal.dataset
                            ? this.modal.dataset.snapped
                            : null;
                        let rect = target.getBoundingClientRect();
                        let localOffsetX = pointerX - rect.left;
                        let localOffsetY = pointerY - rect.top;
                        if (initialSnapSide) {
                            const preservedOffsetX = localOffsetX;
                            const preservedOffsetY = localOffsetY;
                            this.unsnap({ silent: true });
                            const minTopAfterUnsnap =
                                ((_a = window.getMenuBarBottom) == null
                                    ? void 0
                                    : _a.call(window)) || 0;
                            target.style.position = 'fixed';
                            target.style.left = `${pointerX - preservedOffsetX}px`;
                            target.style.top = `${Math.max(minTopAfterUnsnap, pointerY - preservedOffsetY)}px`;
                            rect = target.getBoundingClientRect();
                            localOffsetX = pointerX - rect.left;
                            localOffsetY = pointerY - rect.top;
                        }
                        const computedPosition = window.getComputedStyle(target).position;
                        if (computedPosition === 'static' || computedPosition === 'relative') {
                            target.style.position = 'fixed';
                        } else if (!target.style.position) {
                            target.style.position = computedPosition;
                        }
                        const minTop =
                            ((_b = window.getMenuBarBottom) == null ? void 0 : _b.call(window)) ||
                            0;
                        target.style.left = `${pointerX - localOffsetX}px`;
                        target.style.top = `${Math.max(minTop, pointerY - localOffsetY)}px`;
                        (_c = window.clampWindowToMenuBar) == null
                            ? void 0
                            : _c.call(window, target);
                        const adjustedRect = target.getBoundingClientRect();
                        offsetX = pointerX - adjustedRect.left;
                        offsetY = pointerY - adjustedRect.top;
                        this.lastDragPointerX = pointerX;
                        const overlay = document.createElement('div');
                        overlay.style.position = 'fixed';
                        overlay.style.top = '0';
                        overlay.style.left = '0';
                        overlay.style.width = '100%';
                        overlay.style.height = '100%';
                        overlay.style.zIndex = '9999';
                        overlay.style.cursor = 'move';
                        overlay.style.backgroundColor = 'transparent';
                        document.body.appendChild(overlay);
                        let isDragging = true;
                        let moved = false;
                        const cleanup = (shouldSave = true) => {
                            var _a2, _b2;
                            if (!isDragging) return;
                            isDragging = false;
                            overlay.remove();
                            overlay.removeEventListener('mousemove', mouseMoveHandler);
                            overlay.removeEventListener('mouseup', mouseUpHandler);
                            window.removeEventListener('mouseup', mouseUpHandler);
                            window.removeEventListener('blur', blurHandler);
                            window.removeEventListener('mousemove', mouseMoveHandler);
                            (_a2 = window.hideSnapPreview) == null ? void 0 : _a2.call(window);
                            if (shouldSave) {
                                if (moved) {
                                    this.applySnapAfterDrag(target, this.lastDragPointerX);
                                } else if (initialSnapSide) {
                                    this.snapTo(initialSnapSide, { silent: true });
                                }
                                (_b2 = window.saveWindowPositions) == null
                                    ? void 0
                                    : _b2.call(window);
                            }
                            this.lastDragPointerX = null;
                        };
                        const mouseMoveHandler = e2 => {
                            moved = true;
                            window.requestAnimationFrame(() => {
                                var _a2, _b2, _c2;
                                const newLeft = e2.clientX - offsetX;
                                const newTop = e2.clientY - offsetY;
                                const minTop2 =
                                    ((_a2 = window.getMenuBarBottom) == null
                                        ? void 0
                                        : _a2.call(window)) || 0;
                                target.style.left = newLeft + 'px';
                                target.style.top = Math.max(minTop2, newTop) + 'px';
                                this.lastDragPointerX = e2.clientX;
                                const candidate = this.getSnapCandidate(
                                    target,
                                    this.lastDragPointerX
                                );
                                if (candidate)
                                    (_b2 = window.showSnapPreview) == null
                                        ? void 0
                                        : _b2.call(window, candidate);
                                else
                                    (_c2 = window.hideSnapPreview) == null
                                        ? void 0
                                        : _c2.call(window);
                            });
                        };
                        const mouseUpHandler = () => cleanup(true);
                        const blurHandler = () => cleanup(true);
                        overlay.addEventListener('mousemove', mouseMoveHandler);
                        overlay.addEventListener('mouseup', mouseUpHandler);
                        window.addEventListener('mousemove', mouseMoveHandler);
                        window.addEventListener('mouseup', mouseUpHandler);
                        window.addEventListener('blur', blurHandler);
                        e.preventDefault();
                    });
                }
                makeResizable() {
                    if (this.modal.dataset.noResize === 'true') return;
                    const target = this.windowEl || this.modal;
                    if (!target) return;
                    const existingHandles = target.querySelectorAll('.resizer');
                    existingHandles.forEach(handle => handle.remove());
                    const computedPosition = window.getComputedStyle(target).position;
                    if (!computedPosition || computedPosition === 'static')
                        target.style.position = 'relative';
                    const ensureFixedPosition = () => {
                        const computed = window.getComputedStyle(target);
                        const rect = target.getBoundingClientRect();
                        if (computed.position === 'static' || computed.position === 'relative') {
                            target.style.position = 'fixed';
                            target.style.left = rect.left + 'px';
                            target.style.top = rect.top + 'px';
                        } else {
                            if (!target.style.left) target.style.left = rect.left + 'px';
                            if (!target.style.top) target.style.top = rect.top + 'px';
                        }
                    };
                    const createHandle = handle => {
                        const resizer = document.createElement('div');
                        resizer.classList.add('resizer', `resizer-${handle.name}`);
                        Object.assign(resizer.style, {
                            position: 'absolute',
                            zIndex: '9999',
                            backgroundColor: 'transparent',
                            pointerEvents: 'auto',
                            touchAction: 'none',
                            cursor: handle.cursor,
                            ...(handle.style || {}),
                        });
                        target.appendChild(resizer);
                        const startResize = event => {
                            event.preventDefault();
                            event.stopPropagation();
                            this.refocus();
                            ensureFixedPosition();
                            const startX = event.clientX;
                            const startY = event.clientY;
                            const rect = target.getBoundingClientRect();
                            const computed = window.getComputedStyle(target);
                            const minWidth = parseFloat(computed.minWidth) || 240;
                            const minHeight = parseFloat(computed.minHeight) || 160;
                            let startLeft = parseFloat(computed.left);
                            let startTop = parseFloat(computed.top);
                            if (!Number.isFinite(startLeft)) startLeft = rect.left;
                            if (!Number.isFinite(startTop)) startTop = rect.top;
                            const startWidth = rect.width;
                            const startHeight = rect.height;
                            const overlay = document.createElement('div');
                            Object.assign(overlay.style, {
                                position: 'fixed',
                                top: '0',
                                left: '0',
                                width: '100%',
                                height: '100%',
                                zIndex: '9999',
                                cursor: handle.cursor,
                                backgroundColor: 'transparent',
                                touchAction: 'none',
                            });
                            document.body.appendChild(overlay);
                            let resizing = true;
                            const applySize = (clientX, clientY) => {
                                if (!resizing) return;
                                window.requestAnimationFrame(() => {
                                    var _a;
                                    const dx = clientX - startX;
                                    const dy = clientY - startY;
                                    let newWidth = startWidth;
                                    let newHeight = startHeight;
                                    let newLeft = startLeft;
                                    let newTop = startTop;
                                    if (handle.directions.includes('e')) newWidth = startWidth + dx;
                                    if (handle.directions.includes('s'))
                                        newHeight = startHeight + dy;
                                    if (handle.directions.includes('w')) {
                                        newWidth = startWidth - dx;
                                        newLeft = startLeft + dx;
                                    }
                                    if (handle.directions.includes('n')) {
                                        newHeight = startHeight - dy;
                                        newTop = startTop + dy;
                                    }
                                    if (newWidth < minWidth) {
                                        const deficit = minWidth - newWidth;
                                        if (handle.directions.includes('w')) newLeft -= deficit;
                                        newWidth = minWidth;
                                    }
                                    if (newHeight < minHeight) {
                                        const deficit = minHeight - newHeight;
                                        if (handle.directions.includes('n')) newTop -= deficit;
                                        newHeight = minHeight;
                                    }
                                    const minTop =
                                        ((_a = window.getMenuBarBottom) == null
                                            ? void 0
                                            : _a.call(window)) || 0;
                                    if (handle.directions.includes('n') && newTop < minTop) {
                                        const overshoot = minTop - newTop;
                                        newTop = minTop;
                                        newHeight = Math.max(minHeight, newHeight - overshoot);
                                    }
                                    if (
                                        handle.directions.includes('w') ||
                                        handle.directions.includes('e')
                                    )
                                        target.style.width = Math.max(minWidth, newWidth) + 'px';
                                    if (
                                        handle.directions.includes('s') ||
                                        handle.directions.includes('n')
                                    )
                                        target.style.height = Math.max(minHeight, newHeight) + 'px';
                                    if (handle.directions.includes('w'))
                                        target.style.left = newLeft + 'px';
                                    if (handle.directions.includes('n'))
                                        target.style.top = newTop + 'px';
                                });
                            };
                            const stopResize = () => {
                                var _a, _b;
                                if (!resizing) return;
                                resizing = false;
                                overlay.remove();
                                overlay.removeEventListener('mousemove', overlayMouseMove);
                                overlay.removeEventListener('mouseup', overlayMouseUp);
                                window.removeEventListener('mousemove', windowMouseMove);
                                window.removeEventListener('mouseup', windowMouseUp);
                                window.removeEventListener('blur', onBlur);
                                (_a = window.clampWindowToMenuBar) == null
                                    ? void 0
                                    : _a.call(window, target);
                                (_b = window.saveWindowPositions) == null
                                    ? void 0
                                    : _b.call(window);
                            };
                            const overlayMouseMove = moveEvent =>
                                applySize(moveEvent.clientX, moveEvent.clientY);
                            const windowMouseMove = moveEvent =>
                                applySize(moveEvent.clientX, moveEvent.clientY);
                            const overlayMouseUp = () => stopResize();
                            const windowMouseUp = () => stopResize();
                            const onBlur = () => stopResize();
                            overlay.addEventListener('mousemove', overlayMouseMove);
                            overlay.addEventListener('mouseup', overlayMouseUp);
                            window.addEventListener('mousemove', windowMouseMove);
                            window.addEventListener('mouseup', windowMouseUp);
                            window.addEventListener('blur', onBlur);
                        };
                        resizer.addEventListener('mousedown', startResize);
                    };
                    target.style.overflow = 'visible';
                    const handles = [
                        {
                            name: 'top',
                            cursor: 'n-resize',
                            directions: ['n'],
                            style: { top: '-4px', left: '12px', right: '12px', height: '8px' },
                        },
                        {
                            name: 'bottom',
                            cursor: 's-resize',
                            directions: ['s'],
                            style: { bottom: '-4px', left: '12px', right: '12px', height: '8px' },
                        },
                        {
                            name: 'left',
                            cursor: 'w-resize',
                            directions: ['w'],
                            style: { left: '-4px', top: '12px', bottom: '12px', width: '8px' },
                        },
                        {
                            name: 'right',
                            cursor: 'e-resize',
                            directions: ['e'],
                            style: { right: '-4px', top: '12px', bottom: '12px', width: '8px' },
                        },
                        {
                            name: 'top-left',
                            cursor: 'nw-resize',
                            directions: ['n', 'w'],
                            style: { top: '-6px', left: '-6px', width: '14px', height: '14px' },
                        },
                        {
                            name: 'top-right',
                            cursor: 'ne-resize',
                            directions: ['n', 'e'],
                            style: { top: '-6px', right: '-6px', width: '14px', height: '14px' },
                        },
                        {
                            name: 'bottom-left',
                            cursor: 'sw-resize',
                            directions: ['s', 'w'],
                            style: { bottom: '-6px', left: '-6px', width: '14px', height: '14px' },
                        },
                        {
                            name: 'bottom-right',
                            cursor: 'se-resize',
                            directions: ['s', 'e'],
                            style: { bottom: '-6px', right: '-6px', width: '14px', height: '14px' },
                        },
                    ];
                    handles.forEach(createHandle);
                }
                enforceMenuBarBoundary() {
                    var _a;
                    (_a = window.clampWindowToMenuBar) == null
                        ? void 0
                        : _a.call(window, this.windowEl || this.modal);
                }
                loadIframe(url) {
                    let contentArea = this.modal.querySelector('.dialog-content');
                    if (!contentArea) {
                        contentArea = document.createElement('div');
                        contentArea.classList.add('dialog-content');
                        contentArea.style.width = '100%';
                        contentArea.style.height = '100%';
                        this.modal.appendChild(contentArea);
                    }
                    contentArea.innerHTML = '';
                    const iframe = document.createElement('iframe');
                    iframe.src = url;
                    iframe.style.width = '100%';
                    iframe.style.height = '100%';
                    iframe.style.border = 'none';
                    iframe.setAttribute('allow', 'fullscreen');
                    contentArea.appendChild(iframe);
                    iframe.addEventListener('load', () => {
                        try {
                            const cw = iframe.contentWindow;
                            if (cw && cw.document) {
                                const handler = () =>
                                    requestAnimationFrame(() => {
                                        this.refocus();
                                    });
                                ['mousedown', 'click', 'touchstart'].forEach(evt => {
                                    cw.document.addEventListener(evt, handler);
                                });
                            } else if (cw) {
                                ['mousedown', 'click', 'touchstart'].forEach(evt => {
                                    cw.addEventListener(evt, () =>
                                        requestAnimationFrame(() => {
                                            this.refocus();
                                        })
                                    );
                                });
                            }
                        } catch (err) {
                            console.error('Could not attach mousedown event in iframe:', err);
                        }
                    });
                }
                saveState() {
                    return {
                        left: this.modal.style.left,
                        top: this.modal.style.top,
                        width: this.modal.style.width,
                        height: this.modal.style.height,
                        zIndex: this.modal.style.zIndex,
                    };
                }
                restoreState(state) {
                    if (!state) return;
                    if (state.left) this.modal.style.left = state.left;
                    if (state.top) this.modal.style.top = state.top;
                    if (state.width) this.modal.style.width = state.width;
                    if (state.height) this.modal.style.height = state.height;
                    if (state.zIndex) this.modal.style.zIndex = state.zIndex;
                }
            };
            window.Dialog = Dialog;
        },
    });

    // src/ts/ui/menubar-utils.ts
    var require_menubar_utils = __commonJS({
        'src/ts/ui/menubar-utils.ts'() {
            'use strict';
            (function () {
                'use strict';
                if (window.bindDropdownTrigger && window.hideMenuDropdowns) {
                    return;
                }
                function hideMenuDropdowns() {
                    const domUtils = window.DOMUtils;
                    document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
                        if (!dropdown.classList.contains('hidden')) {
                            if (domUtils && typeof domUtils.hide === 'function') {
                                domUtils.hide(dropdown);
                            } else {
                                dropdown.classList.add('hidden');
                            }
                        }
                    });
                    document
                        .querySelectorAll('[data-menubar-trigger-button="true"]')
                        .forEach(button => {
                            button.setAttribute('aria-expanded', 'false');
                        });
                    document.querySelectorAll('[data-system-menu-trigger]').forEach(button => {
                        button.setAttribute('aria-expanded', 'false');
                    });
                }
                function isAnyDropdownOpen() {
                    return Boolean(document.querySelector('.menu-dropdown:not(.hidden)'));
                }
                function toggleMenuDropdown(trigger, options = {}) {
                    if (!trigger) return;
                    const menuId = trigger.getAttribute('aria-controls');
                    if (!menuId) return;
                    const forceOpen = Boolean(options.forceOpen);
                    let menu = document.getElementById(menuId);
                    if (!menu) return;
                    const wasOpen = !menu.classList.contains('hidden');
                    const shouldOpen = forceOpen || !wasOpen;
                    hideMenuDropdowns();
                    if (shouldOpen) {
                        if (!wasOpen) {
                            const MenuSystem = window.MenuSystem;
                            if (
                                MenuSystem &&
                                typeof MenuSystem.renderApplicationMenu === 'function'
                            ) {
                                const topModal = Array.from(
                                    document.querySelectorAll('.modal:not(.hidden)')
                                ).sort((a, b) => {
                                    const zA = parseInt(getComputedStyle(a).zIndex, 10) || 0;
                                    const zB = parseInt(getComputedStyle(b).zIndex, 10) || 0;
                                    return zB - zA;
                                })[0];
                                const activeModalId =
                                    (topModal == null ? void 0 : topModal.id) || null;
                                MenuSystem.renderApplicationMenu(activeModalId);
                            }
                            menu = document.getElementById(menuId);
                            if (!menu) return;
                        }
                        const domUtils = window.DOMUtils;
                        if (domUtils && typeof domUtils.show === 'function') {
                            domUtils.show(menu);
                        } else {
                            menu.classList.remove('hidden');
                        }
                        trigger.setAttribute('aria-expanded', 'true');
                    }
                }
                function bindDropdownTrigger(el, options = {}) {
                    if (!el) return;
                    const hoverRequiresExisting =
                        options.hoverRequiresOpen !== void 0 ? options.hoverRequiresOpen : true;
                    let clickJustOccurred = false;
                    el.addEventListener('click', event => {
                        event.stopPropagation();
                        clickJustOccurred = true;
                        const now = Date.now();
                        window.__lastMenuInteractionAt = now;
                        const menuId = el.getAttribute('aria-controls');
                        const menu = menuId ? document.getElementById(menuId) : null;
                        const isOpen = menu ? !menu.classList.contains('hidden') : false;
                        const sinceFocus = now - (window.__lastMenuFocusAt || 0);
                        if (isOpen && sinceFocus > 200) {
                            hideMenuDropdowns();
                            el.setAttribute('aria-expanded', 'false');
                        } else {
                            toggleMenuDropdown(el, { forceOpen: true });
                        }
                        setTimeout(() => {
                            clickJustOccurred = false;
                        }, 200);
                    });
                    el.addEventListener('mouseenter', () => {
                        if (clickJustOccurred) return;
                        window.__lastMenuInteractionAt = Date.now();
                        if (hoverRequiresExisting && !isAnyDropdownOpen()) return;
                        toggleMenuDropdown(el, { forceOpen: true });
                    });
                    el.addEventListener('focus', () => {
                        const now = Date.now();
                        window.__lastMenuInteractionAt = now;
                        window.__lastMenuFocusAt = now;
                        toggleMenuDropdown(el, { forceOpen: true });
                    });
                }
                function handleDocumentClickToCloseMenus(event) {
                    const last = window.__lastMenuInteractionAt;
                    if (last && Date.now() - last < 200) {
                        return;
                    }
                    const target = event.target instanceof Element ? event.target : null;
                    if (!target) return;
                    if (target.closest('.menubar-trigger') || target.closest('.menu-dropdown'))
                        return;
                    hideMenuDropdowns();
                }
                function initMenubarWiring() {
                    if (window.__menubarWired) return;
                    window.__menubarWired = true;
                    const appleMenuTrigger = document.getElementById('apple-menu-trigger');
                    const programLabel = document.getElementById('program-label');
                    bindDropdownTrigger(appleMenuTrigger, { hoverRequiresOpen: true });
                    bindDropdownTrigger(programLabel, { hoverRequiresOpen: true });
                    document.addEventListener('click', event => {
                        const MenuSystem = window.MenuSystem;
                        if (
                            MenuSystem &&
                            typeof MenuSystem.handleMenuActionActivation === 'function'
                        ) {
                            MenuSystem.handleMenuActionActivation(event);
                        }
                    });
                    document.addEventListener('click', handleDocumentClickToCloseMenus);
                    document.addEventListener('pointerdown', handleDocumentClickToCloseMenus, {
                        capture: true,
                    });
                    document.addEventListener('keydown', event => {
                        if (event.key === 'Escape') hideMenuDropdowns();
                    });
                }
                window.hideMenuDropdowns = hideMenuDropdowns;
                window.bindDropdownTrigger = bindDropdownTrigger;
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', initMenubarWiring, {
                        once: true,
                    });
                } else {
                    initMenubarWiring();
                }
            })();
        },
    });

    // src/ts/ui/context-menu.ts
    var guardKey,
        openModal2,
        toggleDarkMode2,
        getMenuItemsForTarget2,
        clearMenu2,
        renderMenu2,
        clampPosition2,
        showContextMenu2,
        buildAndOpenAt2,
        hideContextMenu2,
        bindAutoClose2,
        unbindAutoClose2;
    var init_context_menu = __esm({
        'src/ts/ui/context-menu.ts'() {
            'use strict';
            guardKey = '__customContextMenuInit';
            if (window[guardKey]) {
            } else {
                let openModal = function (id) {
                        const el = document.getElementById(id);
                        if (!el) return;
                        if (!window.dialogs) window.dialogs = {};
                        if (!window.dialogs[id] && typeof window.Dialog === 'function') {
                            try {
                                window.dialogs[id] = new window.Dialog(id);
                            } catch {}
                        }
                        const dlg = window.dialogs[id];
                        if (dlg && typeof dlg.open === 'function') {
                            dlg.open();
                        } else {
                            const domUtils = window.DOMUtils;
                            if (domUtils && typeof domUtils.show === 'function') {
                                domUtils.show(el);
                            } else {
                                el.classList.remove('hidden');
                            }
                            if (typeof window.bringDialogToFront === 'function') {
                                window.bringDialogToFront(id);
                            }
                        }
                        if (typeof window.updateProgramLabelByTopModal === 'function') {
                            window.updateProgramLabelByTopModal();
                        }
                    },
                    toggleDarkMode = function () {
                        if (
                            window.SystemUI &&
                            typeof window.SystemUI.handleSystemToggle === 'function'
                        ) {
                            window.SystemUI.handleSystemToggle('dark-mode');
                        } else {
                            const next = !document.documentElement.classList.contains('dark');
                            document.documentElement.classList.toggle('dark', next);
                            if (
                                window.ThemeSystem &&
                                typeof window.ThemeSystem.setThemePreference === 'function'
                            ) {
                                window.ThemeSystem.setThemePreference(next ? 'dark' : 'light');
                            }
                        }
                    },
                    getMenuItemsForTarget = function (target) {
                        const items = [];
                        const inDesktop = !!(
                            target &&
                            target.closest &&
                            target.closest('#desktop')
                        );
                        const inDockItem = !!(
                            target &&
                            target.closest &&
                            target.closest('#dock .dock-item')
                        );
                        const inImageModal = !!(
                            target &&
                            target.closest &&
                            target.closest('#image-modal')
                        );
                        const inFinderModal = !!(
                            target &&
                            target.closest &&
                            target.closest('[role="dialog"][id*="finder"]')
                        );
                        if (inDockItem) {
                            const dockItem = target.closest('#dock .dock-item');
                            const winId = dockItem && dockItem.getAttribute('data-window-id');
                            if (winId) {
                                items.push({
                                    id: 'open-dock-window',
                                    label: i18n.translate('context.open') || '\xD6ffnen',
                                    action: () => openModal(winId),
                                });
                                items.push({ type: 'separator' });
                            }
                        }
                        if (inImageModal && typeof window.getImageViewerState === 'function') {
                            const st = window.getImageViewerState();
                            if (st && st.hasImage) {
                                items.push({
                                    id: 'image-open-tab',
                                    label:
                                        i18n.translate('context.image.openInTab') ||
                                        i18n.translate('menu.image.openInTab') ||
                                        'Bild in neuem Tab \xF6ffnen',
                                    action: () => {
                                        if (typeof window.openActiveImageInNewTab === 'function')
                                            window.openActiveImageInNewTab();
                                    },
                                });
                                items.push({
                                    id: 'image-save',
                                    label:
                                        i18n.translate('context.image.save') ||
                                        i18n.translate('menu.image.saveImage') ||
                                        'Bild sichern \u2026',
                                    action: () => {
                                        if (typeof window.downloadActiveImage === 'function')
                                            window.downloadActiveImage();
                                    },
                                });
                                items.push({ type: 'separator' });
                            }
                        }
                        if (inFinderModal) {
                            const finderItem =
                                target &&
                                target.closest &&
                                target.closest('.finder-list-item, .finder-grid-item');
                            if (finderItem) {
                                const itemName = finderItem.getAttribute('data-item-name');
                                const itemType = finderItem.getAttribute('data-item-type');
                                if (itemName && itemType) {
                                    items.push({
                                        id: 'finder-open-item',
                                        label:
                                            i18n.translate('context.finder.openItem') ||
                                            '\xD6ffnen',
                                        action: () => {
                                            if (
                                                window.FinderSystem &&
                                                typeof window.FinderSystem.openItem === 'function'
                                            )
                                                window.FinderSystem.openItem(itemName, itemType);
                                        },
                                    });
                                    const isImage = /\.(png|jpe?g|gif|bmp|webp|svg)$/i.test(
                                        itemName
                                    );
                                    if (isImage && itemType === 'file') {
                                        items.push({
                                            id: 'finder-open-with-preview',
                                            label:
                                                i18n.translate('context.finder.openWithPreview') ||
                                                '\xD6ffnen mit Vorschau',
                                            action: () => {
                                                const ab = window.ActionBus;
                                                if (ab && typeof ab.execute === 'function') {
                                                    ab.execute('openWithPreview', { itemName });
                                                }
                                            },
                                        });
                                    }
                                    items.push({ type: 'separator' });
                                    items.push({
                                        id: 'finder-get-info',
                                        label:
                                            i18n.translate('context.finder.getInfo') ||
                                            'Informationen',
                                        action: () => {
                                            console.log('Get info for:', itemName, itemType);
                                        },
                                    });
                                    return items;
                                }
                            }
                            items.push({
                                id: 'finder-refresh',
                                label: i18n.translate('context.finder.refresh') || 'Aktualisieren',
                                action: () => {
                                    if (
                                        window.FinderSystem &&
                                        typeof window.FinderSystem.navigateTo === 'function'
                                    ) {
                                        const state = window.FinderSystem.getState();
                                        if (state) {
                                            window.FinderSystem.navigateTo(
                                                state.currentPath,
                                                state.currentView
                                            );
                                        }
                                    }
                                },
                            });
                            items.push({ type: 'separator' });
                            const currentViewMode =
                                window.FinderSystem && window.FinderSystem.getState
                                    ? window.FinderSystem.getState().viewMode
                                    : 'list';
                            if (currentViewMode !== 'list') {
                                items.push({
                                    id: 'finder-view-list',
                                    label: i18n.translate('context.finder.viewList') || 'Als Liste',
                                    action: () => {
                                        if (
                                            window.FinderSystem &&
                                            typeof window.FinderSystem.setViewMode === 'function'
                                        )
                                            window.FinderSystem.setViewMode('list');
                                    },
                                });
                            }
                            if (currentViewMode !== 'grid') {
                                items.push({
                                    id: 'finder-view-grid',
                                    label:
                                        i18n.translate('context.finder.viewGrid') || 'Als Raster',
                                    action: () => {
                                        if (
                                            window.FinderSystem &&
                                            typeof window.FinderSystem.setViewMode === 'function'
                                        )
                                            window.FinderSystem.setViewMode('grid');
                                    },
                                });
                            }
                            items.push({ type: 'separator' });
                            items.push({
                                id: 'finder-sort-name',
                                label:
                                    i18n.translate('context.finder.sortByName') ||
                                    'Nach Name sortieren',
                                action: () => {
                                    if (
                                        window.FinderSystem &&
                                        typeof window.FinderSystem.setSortBy === 'function'
                                    )
                                        window.FinderSystem.setSortBy('name');
                                },
                            });
                            items.push({
                                id: 'finder-sort-date',
                                label:
                                    i18n.translate('context.finder.sortByDate') ||
                                    'Nach Datum sortieren',
                                action: () => {
                                    if (
                                        window.FinderSystem &&
                                        typeof window.FinderSystem.setSortBy === 'function'
                                    )
                                        window.FinderSystem.setSortBy('date');
                                },
                            });
                            items.push({
                                id: 'finder-sort-size',
                                label:
                                    i18n.translate('context.finder.sortBySize') ||
                                    'Nach Gr\xF6\xDFe sortieren',
                                action: () => {
                                    if (
                                        window.FinderSystem &&
                                        typeof window.FinderSystem.setSortBy === 'function'
                                    )
                                        window.FinderSystem.setSortBy('size');
                                },
                            });
                            return items;
                        }
                        if (inDesktop) {
                            items.push({
                                id: 'open-finder',
                                label: i18n.translate('context.openFinder') || 'Finder \xF6ffnen',
                                action: () => {
                                    var _a;
                                    const W = window;
                                    (_a = W.FinderWindow) == null ? void 0 : _a.focusOrCreate();
                                },
                            });
                            items.push({
                                id: 'open-text',
                                label:
                                    i18n.translate('context.openTextEditor') ||
                                    'Texteditor \xF6ffnen',
                                action: () => openModal('text-modal'),
                            });
                            items.push({
                                id: 'open-projects',
                                label:
                                    i18n.translate('context.openProjects') || 'Projekte \xF6ffnen',
                                action: () => openModal('projects-modal'),
                            });
                            items.push({ type: 'separator' });
                            items.push({
                                id: 'toggle-dark',
                                label:
                                    i18n.translate('context.toggleDarkMode') ||
                                    'Dark Mode umschalten',
                                action: toggleDarkMode,
                            });
                            items.push({
                                id: 'open-settings',
                                label:
                                    i18n.translate('context.openSettings') ||
                                    'Systemeinstellungen \u2026',
                                action: () => openModal('settings-modal'),
                            });
                            items.push({ type: 'separator' });
                            items.push({
                                id: 'about',
                                label: i18n.translate('context.about') || '\xDCber Marvin',
                                action: () => openModal('about-modal'),
                            });
                            return items;
                        }
                        items.push({
                            id: 'open-finder',
                            label: i18n.translate('context.openFinder') || 'Finder \xF6ffnen',
                            action: () => {
                                var _a;
                                const W = window;
                                (_a = W.FinderWindow) == null ? void 0 : _a.focusOrCreate();
                            },
                        });
                        items.push({
                            id: 'open-text',
                            label:
                                i18n.translate('context.openTextEditor') || 'Texteditor \xF6ffnen',
                            action: () => openModal('text-modal'),
                        });
                        items.push({ type: 'separator' });
                        items.push({
                            id: 'toggle-dark',
                            label:
                                i18n.translate('context.toggleDarkMode') || 'Dark Mode umschalten',
                            action: toggleDarkMode,
                        });
                        items.push({
                            id: 'open-settings',
                            label:
                                i18n.translate('context.openSettings') ||
                                'Systemeinstellungen \u2026',
                            action: () => openModal('settings-modal'),
                        });
                        items.push({ type: 'separator' });
                        items.push({
                            id: 'about',
                            label: i18n.translate('context.about') || '\xDCber Marvin',
                            action: () => openModal('about-modal'),
                        });
                        return items;
                    },
                    clearMenu = function () {
                        while (menu.firstChild) menu.removeChild(menu.firstChild);
                    },
                    renderMenu = function (items) {
                        clearMenu();
                        const fragment = document.createDocumentFragment();
                        let firstFocusable = null;
                        items.forEach((it, idx) => {
                            if (it.type === 'separator') {
                                const sep = document.createElement('li');
                                sep.className = 'menu-separator';
                                sep.setAttribute('role', 'separator');
                                fragment.appendChild(sep);
                                return;
                            }
                            const li = document.createElement('li');
                            const btn = document.createElement('button');
                            btn.type = 'button';
                            btn.className = 'menu-item';
                            btn.setAttribute('role', 'menuitem');
                            btn.tabIndex = -1;
                            btn.dataset.itemId = it.id || 'item-' + idx;
                            const labelSpan = document.createElement('span');
                            labelSpan.className = 'menu-item-label';
                            labelSpan.textContent = it.label || '';
                            btn.appendChild(labelSpan);
                            btn.addEventListener('click', ev => {
                                ev.stopPropagation();
                                hideContextMenu();
                                try {
                                    if (it.action) {
                                        it.action();
                                    }
                                } catch (e) {
                                    console.warn('Context action failed', e);
                                }
                            });
                            li.appendChild(btn);
                            fragment.appendChild(li);
                            if (!firstFocusable) firstFocusable = btn;
                        });
                        menu.appendChild(fragment);
                        try {
                            i18n.applyTranslations(menu);
                        } catch {}
                        return firstFocusable;
                    },
                    clampPosition = function (x, y) {
                        const rect = menu.getBoundingClientRect();
                        const vw = Math.max(
                            document.documentElement.clientWidth,
                            window.innerWidth || 0
                        );
                        const vh = Math.max(
                            document.documentElement.clientHeight,
                            window.innerHeight || 0
                        );
                        const margin = 6;
                        const nx = Math.min(
                            Math.max(margin, x),
                            Math.max(margin, vw - rect.width - margin)
                        );
                        const ny = Math.min(
                            Math.max(margin, y),
                            Math.max(margin, vh - rect.height - margin)
                        );
                        return { x: nx, y: ny };
                    },
                    showContextMenu = function (ev) {
                        const target = ev.target instanceof Element ? ev.target : null;
                        if (!target) return;
                        if (target.closest('input, textarea, [contenteditable="true"]')) return;
                        ev.preventDefault();
                        ev.stopPropagation();
                        hideAllDropdowns();
                        buildAndOpenAt(ev.clientX, ev.clientY, target);
                    },
                    buildAndOpenAt = function (x, y, target) {
                        const items = getMenuItemsForTarget(target);
                        const firstFocusable = renderMenu(items);
                        if (document.body && menu.parentElement !== document.body) {
                            document.body.appendChild(menu);
                        } else if (document.body && document.body.lastElementChild !== menu) {
                            document.body.appendChild(menu);
                        }
                        const domUtils = window.DOMUtils;
                        if (domUtils && typeof domUtils.show === 'function') {
                            domUtils.show(menu);
                        } else {
                            menu.classList.remove('hidden');
                        }
                        menu.style.left = Math.max(0, x) + 'px';
                        menu.style.top = Math.max(0, y) + 'px';
                        const clamped = clampPosition(x, y);
                        menu.style.left = clamped.x + 'px';
                        menu.style.top = clamped.y + 'px';
                        if (lastInvokeWasKeyboard && firstFocusable) {
                            firstFocusable.focus();
                        }
                        bindAutoClose();
                    },
                    hideContextMenu = function () {
                        const domUtils = window.DOMUtils;
                        if (!menu.classList.contains('hidden')) {
                            if (domUtils && typeof domUtils.hide === 'function') {
                                domUtils.hide(menu);
                            } else {
                                menu.classList.add('hidden');
                            }
                        }
                        unbindAutoClose();
                    },
                    bindAutoClose = function () {
                        unbindAutoClose();
                        onDocClick = e => {
                            const t2 = e.target instanceof Element ? e.target : null;
                            if (!t2) {
                                hideContextMenu();
                                return;
                            }
                            if (t2.closest('#context-menu')) return;
                            hideContextMenu();
                        };
                        onDocScroll = () => hideContextMenu();
                        onResize = () => hideContextMenu();
                        onKeyDown = e => {
                            var _a, _b;
                            const items = Array.from(menu.querySelectorAll('.menu-item'));
                            const focusIdx = items.findIndex(el => el === document.activeElement);
                            if (e.key === 'Escape') {
                                e.preventDefault();
                                hideContextMenu();
                                return;
                            }
                            if (!items.length) return;
                            if (e.key === 'ArrowDown') {
                                e.preventDefault();
                                const next = items[(Math.max(0, focusIdx) + 1) % items.length];
                                if (next) next.focus();
                            } else if (e.key === 'ArrowUp') {
                                e.preventDefault();
                                const next = items[(focusIdx > 0 ? focusIdx : items.length) - 1];
                                if (next) next.focus();
                            } else if (e.key === 'Home') {
                                e.preventDefault();
                                (_a = items[0]) == null ? void 0 : _a.focus();
                            } else if (e.key === 'End') {
                                e.preventDefault();
                                (_b = items[items.length - 1]) == null ? void 0 : _b.focus();
                            } else if (e.key === 'Enter' || e.key === ' ') {
                                if (
                                    document.activeElement &&
                                    document.activeElement.classList.contains('menu-item')
                                ) {
                                    e.preventDefault();
                                    document.activeElement.click();
                                }
                            }
                        };
                        document.addEventListener('click', onDocClick, { capture: true });
                        document.addEventListener('contextmenu', onDocClick, { capture: true });
                        document.addEventListener('scroll', onDocScroll, { capture: true });
                        window.addEventListener('resize', onResize);
                        document.addEventListener('keydown', onKeyDown);
                    },
                    unbindAutoClose = function () {
                        if (onDocClick)
                            document.removeEventListener('click', onDocClick, { capture: true });
                        if (onDocClick)
                            document.removeEventListener('contextmenu', onDocClick, {
                                capture: true,
                            });
                        if (onDocScroll)
                            document.removeEventListener('scroll', onDocScroll, { capture: true });
                        if (onResize) window.removeEventListener('resize', onResize);
                        if (onKeyDown) document.removeEventListener('keydown', onKeyDown);
                        onDocClick = onDocScroll = onResize = onKeyDown = null;
                    };
                ((openModal2 = openModal),
                    (toggleDarkMode2 = toggleDarkMode),
                    (getMenuItemsForTarget2 = getMenuItemsForTarget),
                    (clearMenu2 = clearMenu),
                    (renderMenu2 = renderMenu),
                    (clampPosition2 = clampPosition),
                    (showContextMenu2 = showContextMenu),
                    (buildAndOpenAt2 = buildAndOpenAt),
                    (hideContextMenu2 = hideContextMenu),
                    (bindAutoClose2 = bindAutoClose),
                    (unbindAutoClose2 = unbindAutoClose));
                window[guardKey] = true;
                const i18n = window.appI18n || {
                    translate: k => k,
                    applyTranslations: _el => {},
                };
                const hideAllDropdowns =
                    typeof window.hideMenuDropdowns === 'function'
                        ? window.hideMenuDropdowns
                        : () => {
                              const domUtils = window.DOMUtils;
                              document.querySelectorAll('.menu-dropdown').forEach(d => {
                                  if (domUtils && typeof domUtils.hide === 'function') {
                                      domUtils.hide(d);
                                  } else {
                                      d.classList.add('hidden');
                                  }
                              });
                              document
                                  .querySelectorAll('[aria-expanded="true"]')
                                  .forEach(b => b.setAttribute('aria-expanded', 'false'));
                          };
                const menu = document.createElement('ul');
                menu.id = 'context-menu';
                menu.className = 'menu-dropdown context-menu hidden';
                menu.setAttribute('role', 'menu');
                menu.setAttribute(
                    'aria-label',
                    i18n.translate('context.menuLabel') || 'Kontextmen\xFC'
                );
                document.addEventListener('DOMContentLoaded', () => {
                    if (!document.body.contains(menu)) document.body.appendChild(menu);
                    try {
                        i18n.applyTranslations(menu);
                    } catch {}
                });
                let onDocClick = null;
                let onDocScroll = null;
                let onResize = null;
                let onKeyDown = null;
                let lastInvokeWasKeyboard = false;
                document.addEventListener('keydown', e => {
                    if (e.key === 'ContextMenu' || (e.shiftKey && e.key === 'F10')) {
                        lastInvokeWasKeyboard = true;
                    }
                });
                document.addEventListener(
                    'keyup',
                    () => {
                        lastInvokeWasKeyboard = false;
                    },
                    { capture: true }
                );
                document.addEventListener('contextmenu', showContextMenu);
                if (typeof window.bindDropdownTrigger === 'function') {
                    document
                        .querySelectorAll('[data-menubar-trigger-button="true"]')
                        .forEach(btn => {
                            btn.addEventListener('click', () => hideContextMenu());
                        });
                }
            }
        },
    });

    // src/ts/services/storage.ts
    var require_storage = __commonJS({
        'src/ts/services/storage.ts'() {
            'use strict';
            init_storage_utils();
            (() => {
                'use strict';
                console.log('\u2705 StorageSystem (TS) loaded');
                const w = window;
                const APP_CONSTANTS2 = w.APP_CONSTANTS || {};
                const FINDER_STATE_KEY = APP_CONSTANTS2.FINDER_STATE_STORAGE_KEY || 'finderState';
                const OPEN_MODALS_KEY = 'openModals';
                const MODAL_POSITIONS_KEY = 'modalPositions';
                const getModalIds2 = () => {
                    const ac = w.APP_CONSTANTS || void 0;
                    const v = ac && ac['MODAL_IDS'];
                    return Array.isArray(v) ? v : [];
                };
                const getTransientModalIds = () => {
                    const ac = w.APP_CONSTANTS || void 0;
                    const v = ac && ac['TRANSIENT_MODAL_IDS'];
                    return v instanceof Set ? v : /* @__PURE__ */ new Set();
                };
                function readFinderState() {
                    try {
                        const parsed = getJSON(FINDER_STATE_KEY, null);
                        if (!parsed || typeof parsed !== 'object') return null;
                        const po = parsed;
                        const repo = typeof po.repo === 'string' ? po.repo.trim() : '';
                        if (!repo) return null;
                        return {
                            repo,
                            path: typeof po.path === 'string' ? po.path : '',
                        };
                    } catch (err) {
                        console.warn('Finder state konnte nicht gelesen werden:', err);
                        return null;
                    }
                }
                function writeFinderState(state) {
                    if (!state || typeof state.repo !== 'string' || !state.repo) {
                        clearFinderState();
                        return;
                    }
                    const payload = {
                        repo: state.repo,
                        path: typeof state.path === 'string' ? state.path : '',
                    };
                    try {
                        setJSON(FINDER_STATE_KEY, payload);
                    } catch (err) {
                        console.warn('Finder state konnte nicht gespeichert werden:', err);
                    }
                }
                function clearFinderState() {
                    try {
                        remove(FINDER_STATE_KEY);
                    } catch (err) {
                        console.warn('Finder state konnte nicht gel\xF6scht werden:', err);
                    }
                }
                function saveOpenModals() {
                    const modalIds = getModalIds2();
                    const transientModalIds = getTransientModalIds();
                    const openModals = modalIds.filter(id => {
                        if (transientModalIds.has(id)) return false;
                        const el = document.getElementById(id);
                        if (!el) return false;
                        const minimized = el.dataset && el.dataset.minimized === 'true';
                        return !el.classList.contains('hidden') || minimized;
                    });
                    try {
                        setJSON(OPEN_MODALS_KEY, openModals);
                    } catch (err) {
                        console.warn('Open modals konnte nicht gespeichert werden:', err);
                    }
                }
                function restoreOpenModals() {
                    const transientModalIds = getTransientModalIds();
                    const toRestore = /* @__PURE__ */ new Set();
                    try {
                        const arr = getJSON(OPEN_MODALS_KEY, []);
                        if (Array.isArray(arr)) arr.forEach(id => toRestore.add(id));
                    } catch (err) {
                        console.warn('Open modals konnte nicht gelesen werden:', err);
                    }
                    try {
                        const legacy = getJSON('window-session', null);
                        if (legacy) {
                            const modalState = legacy && legacy['modalState'];
                            if (modalState && typeof modalState === 'object') {
                                Object.entries(modalState).forEach(([id, state]) => {
                                    try {
                                        const visible = !!(state && state['visible']);
                                        if (visible) toRestore.add(id);
                                    } catch {}
                                });
                            }
                        }
                    } catch (err) {
                        console.warn('Legacy window-session konnte nicht gelesen werden:', err);
                    }
                    toRestore.forEach(id => {
                        if (transientModalIds.has(id)) return;
                        const el = document.getElementById(id);
                        if (!el) {
                            console.warn(`SessionManager: Modal "${id}" not found in DOM`);
                            return;
                        }
                        const WindowManager = w['WindowManager'];
                        if (WindowManager && typeof WindowManager.getConfig === 'function') {
                            const config = WindowManager.getConfig(id);
                            if (!config) {
                                console.warn(
                                    `Skipping restore of modal "${id}": not registered in WindowManager`
                                );
                                return;
                            }
                        }
                        const wm = w['WindowManager'];
                        if (wm && typeof wm.open === 'function') {
                            try {
                                wm.open(id);
                            } catch (err) {
                                console.warn(
                                    `Error restoring modal "${id}" via WindowManager:`,
                                    err
                                );
                                const dialogs = w['dialogs'];
                                const dialogInstance = dialogs && dialogs[id];
                                const openFn = dialogInstance && dialogInstance['open'];
                                if (typeof openFn === 'function') {
                                    try {
                                        openFn();
                                    } catch (openErr) {
                                        console.warn(
                                            `Error restoring modal "${id}" via dialog.open():`,
                                            openErr
                                        );
                                        const domUtils = w.DOMUtils;
                                        if (domUtils && typeof domUtils.show === 'function') {
                                            domUtils.show(el);
                                        } else {
                                            el.classList.remove('hidden');
                                        }
                                    }
                                } else {
                                    const domUtils = w.DOMUtils;
                                    if (domUtils && typeof domUtils.show === 'function') {
                                        domUtils.show(el);
                                    } else {
                                        el.classList.remove('hidden');
                                    }
                                }
                            }
                        } else {
                            const dialogs = w['dialogs'];
                            const dialogInstance = dialogs && dialogs[id];
                            const openFn = dialogInstance && dialogInstance['open'];
                            if (typeof openFn === 'function') {
                                try {
                                    openFn();
                                } catch (err) {
                                    console.warn(`Error restoring modal "${id}":`, err);
                                    const domUtils = w.DOMUtils;
                                    if (domUtils && typeof domUtils.show === 'function') {
                                        domUtils.show(el);
                                    } else {
                                        el.classList.remove('hidden');
                                    }
                                }
                            } else {
                                const domUtils = w.DOMUtils;
                                if (domUtils && typeof domUtils.show === 'function') {
                                    domUtils.show(el);
                                } else {
                                    el.classList.remove('hidden');
                                }
                            }
                        }
                    });
                    const updateDockIndicators2 = w['updateDockIndicators'];
                    if (typeof updateDockIndicators2 === 'function') updateDockIndicators2();
                    const updateProgramLabelByTopModal = w['updateProgramLabelByTopModal'];
                    if (typeof updateProgramLabelByTopModal === 'function')
                        updateProgramLabelByTopModal();
                }
                function getDialogWindowElement(modal) {
                    if (!modal) return null;
                    return modal.querySelector('.autopointer') || modal;
                }
                function saveWindowPositions() {
                    const modalIds = getModalIds2();
                    const transientModalIds = getTransientModalIds();
                    const positions = {};
                    modalIds.forEach(id => {
                        if (transientModalIds.has(id)) return;
                        const el = document.getElementById(id);
                        const windowEl = getDialogWindowElement(el);
                        if (el && windowEl) {
                            positions[id] = {
                                left: windowEl.style.left || '',
                                top: windowEl.style.top || '',
                                width: windowEl.style.width || '',
                                height: windowEl.style.height || '',
                                position: windowEl.style.position || '',
                            };
                        }
                    });
                    try {
                        setJSON(MODAL_POSITIONS_KEY, positions);
                    } catch (err) {
                        console.warn('Window positions konnte nicht gespeichert werden:', err);
                    }
                }
                function restoreWindowPositions() {
                    const transientModalIds = getTransientModalIds();
                    let positions = {};
                    try {
                        positions = getJSON(MODAL_POSITIONS_KEY, {});
                    } catch (err) {
                        console.warn('Window positions konnte nicht gelesen werden:', err);
                        return;
                    }
                    Object.keys(positions).forEach(id => {
                        if (transientModalIds.has(id)) return;
                        const el = document.getElementById(id);
                        const windowEl = getDialogWindowElement(el);
                        if (el && windowEl) {
                            const stored = positions[id];
                            if (!stored) return;
                            if (stored.position) {
                                windowEl.style.position = stored.position;
                            } else if (stored.left || stored.top) {
                                windowEl.style.position = 'fixed';
                            }
                            if (stored.left) windowEl.style.left = stored.left;
                            if (stored.top) windowEl.style.top = stored.top;
                            if (stored.width) windowEl.style.width = stored.width;
                            if (stored.height) windowEl.style.height = stored.height;
                        }
                        const clampWindowToMenuBar = w['clampWindowToMenuBar'];
                        if (typeof clampWindowToMenuBar === 'function') {
                            clampWindowToMenuBar(windowEl);
                        }
                    });
                }
                function resetWindowLayout() {
                    const modalIds = getModalIds2();
                    modalIds.forEach(id => {
                        const modal = document.getElementById(id);
                        const windowEl = getDialogWindowElement(modal);
                        if (modal) {
                            modal.style.zIndex = '';
                        }
                        if (windowEl) {
                            windowEl.style.left = '';
                            windowEl.style.top = '';
                            windowEl.style.width = '';
                            windowEl.style.height = '';
                            windowEl.style.position = '';
                            windowEl.style.zIndex = '';
                        }
                    });
                    if (typeof w['topZIndex'] !== 'undefined') {
                        w['topZIndex'] = 1e3;
                    }
                    try {
                        remove(MODAL_POSITIONS_KEY);
                    } catch (err) {
                        console.warn('Modal positions konnte nicht gel\xF6scht werden:', err);
                    }
                    const hideMenuDropdowns = w['hideMenuDropdowns'];
                    if (typeof hideMenuDropdowns === 'function') hideMenuDropdowns();
                    const syncTopZIndexWithDOM2 = w['syncTopZIndexWithDOM'];
                    if (typeof syncTopZIndexWithDOM2 === 'function') syncTopZIndexWithDOM2();
                    const dialogs = w['dialogs'];
                    if (dialogs) {
                        Object.values(dialogs).forEach(dialog => {
                            const enforce = dialog['enforceMenuBarBoundary'];
                            if (typeof enforce === 'function') enforce();
                        });
                    }
                    clearFinderState();
                    const updateProgramLabelByTopModal = w['updateProgramLabelByTopModal'];
                    if (typeof updateProgramLabelByTopModal === 'function')
                        updateProgramLabelByTopModal();
                }
                const api = {
                    // Finder state
                    readFinderState,
                    writeFinderState,
                    clearFinderState,
                    // Open modals
                    saveOpenModals,
                    restoreOpenModals,
                    // Window positions
                    saveWindowPositions,
                    restoreWindowPositions,
                    getDialogWindowElement,
                    // Layout reset
                    resetWindowLayout,
                };
                w['StorageSystem'] = api;
            })();
        },
    });

    // src/ts/services/theme.ts
    var require_theme = __commonJS({
        'src/ts/services/theme.ts'() {
            'use strict';
            init_storage_utils();
            (() => {
                'use strict';
                const win = window;
                const APP_CONSTANTS2 = win.APP_CONSTANTS || {};
                const THEME_KEY = APP_CONSTANTS2.THEME_PREFERENCE_KEY || 'themePreference';
                const validThemePreferences = ['system', 'light', 'dark'];
                const systemDarkQuery = window.matchMedia('(prefers-color-scheme: dark)');
                let themePreference = (() => {
                    const fromStorage = getString(THEME_KEY);
                    return fromStorage && validThemePreferences.includes(fromStorage)
                        ? fromStorage
                        : 'system';
                })();
                function updateThemeFromPreference() {
                    const useDark =
                        themePreference === 'dark' ||
                        (themePreference === 'system' && systemDarkQuery.matches);
                    document.documentElement.classList.toggle('dark', useDark);
                }
                function setThemePreference(pref) {
                    if (!validThemePreferences.includes(pref)) return;
                    themePreference = pref;
                    setString(THEME_KEY, pref);
                    updateThemeFromPreference();
                    window.dispatchEvent(
                        new CustomEvent('themePreferenceChange', {
                            detail: { preference: pref },
                        })
                    );
                }
                function getThemePreference() {
                    return themePreference;
                }
                updateThemeFromPreference();
                const handleSystemThemeChange = () => {
                    updateThemeFromPreference();
                };
                const mql = systemDarkQuery;
                if (typeof mql.addEventListener === 'function') {
                    mql.addEventListener('change', handleSystemThemeChange);
                } else if (typeof mql.addListener === 'function') {
                    mql.addListener(handleSystemThemeChange);
                }
                const w = window;
                w['ThemeSystem'] = {
                    setThemePreference,
                    getThemePreference,
                    updateThemeFromPreference,
                };
                w['setThemePreference'] = setThemePreference;
                w['getThemePreference'] = getThemePreference;
            })();
        },
    });

    // src/ts/utils/auto-save-helper.ts
    function triggerAutoSave(type) {
        const w = window;
        const SessionManager = w.SessionManager;
        if (SessionManager && typeof SessionManager.saveInstanceType === 'function') {
            try {
                SessionManager.saveInstanceType(type);
            } catch (error) {
                console.warn('Failed to trigger auto-save:', error);
            }
        }
    }
    var init_auto_save_helper = __esm({
        'src/ts/utils/auto-save-helper.ts'() {
            'use strict';
        },
    });

    // src/ts/windows/base-window-instance.ts
    var BaseWindowInstance, base_window_instance_default;
    var init_base_window_instance = __esm({
        'src/ts/windows/base-window-instance.ts'() {
            'use strict';
            init_auto_save_helper();
            BaseWindowInstance = class {
                constructor(config) {
                    this.instanceId = config.id || this._generateId();
                    this.type = config.type || 'unknown';
                    this.title = config.title || 'Untitled';
                    this.container = null;
                    this.windowElement = null;
                    this.state = this._initializeState(config.initialState || {});
                    this.eventListeners = /* @__PURE__ */ new Map();
                    this.isInitialized = false;
                    this.isVisible = false;
                    this.metadata = config.metadata || {};
                    this._skipInitialRender = false;
                }
                _generateId() {
                    return `${this.type}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                }
                _initializeState(initialState) {
                    return {
                        ...initialState,
                        created: Date.now(),
                        modified: Date.now(),
                    };
                }
                init(container) {
                    if (this.isInitialized) {
                        console.warn(`Instance ${this.instanceId} already initialized`);
                        return;
                    }
                    this.container = container;
                    this.render();
                    this.attachEventListeners();
                    this.isInitialized = true;
                    this.emit('initialized');
                }
                // Subclasses must implement render
                render() {
                    throw new Error('render() must be implemented by subclass');
                }
                attachEventListeners() {}
                show() {
                    if (this.container) {
                        const domUtils = window.DOMUtils;
                        if (domUtils && typeof domUtils.show === 'function') {
                            domUtils.show(this.container);
                        } else {
                            this.container.classList.remove('hidden');
                        }
                        this.isVisible = true;
                        this.emit('shown');
                    }
                }
                hide() {
                    if (this.container) {
                        const domUtils = window.DOMUtils;
                        if (domUtils && typeof domUtils.hide === 'function') {
                            domUtils.hide(this.container);
                        } else {
                            this.container.classList.add('hidden');
                        }
                        this.isVisible = false;
                        this.emit('hidden');
                    }
                }
                destroy() {
                    this.emit('beforeDestroy');
                    this.removeAllEventListeners();
                    if (this.container) {
                        try {
                            if (typeof this.container.remove === 'function') {
                                this.container.remove();
                            } else if (this.container.parentNode) {
                                this.container.parentNode.removeChild(this.container);
                            }
                        } catch {
                            try {
                                this.container.innerHTML = '';
                                this.container.classList.add('hidden');
                            } catch {}
                        }
                        this.container = null;
                    }
                    this.windowElement = null;
                    this.isInitialized = false;
                    this.emit('destroyed');
                }
                updateState(updates) {
                    const oldState = { ...this.state };
                    this.state = {
                        ...this.state,
                        ...updates,
                        modified: Date.now(),
                    };
                    this.emit('stateChanged', { oldState, newState: this.state });
                    this._triggerAutoSave();
                }
                _triggerAutoSave() {
                    const w = window;
                    if (
                        w.SessionManager &&
                        typeof w.SessionManager.saveInstanceType === 'function'
                    ) {
                        try {
                            w.SessionManager.saveInstanceType(this.type);
                        } catch (error) {
                            console.warn('Failed to trigger auto-save:', error);
                        }
                    }
                }
                getState() {
                    return { ...this.state };
                }
                serialize() {
                    return {
                        instanceId: this.instanceId,
                        type: this.type,
                        title: this.title,
                        state: this.getState(),
                        metadata: this.metadata,
                    };
                }
                deserialize(data) {
                    this._skipInitialRender = true;
                    if (data.state) this.state = data.state;
                    if (data.title) this.title = data.title;
                    if (data.metadata) this.metadata = { ...this.metadata, ...data.metadata };
                    this.emit('deserialized');
                }
                emit(eventName, data) {
                    const listeners = this.eventListeners.get(eventName) || [];
                    listeners.forEach(callback => {
                        try {
                            callback.call(this, data);
                        } catch (error) {
                            console.error(`Error in event listener for ${eventName}:`, error);
                        }
                    });
                }
                on(eventName, callback) {
                    if (!this.eventListeners.has(eventName)) this.eventListeners.set(eventName, []);
                    this.eventListeners.get(eventName).push(callback);
                }
                off(eventName, callback) {
                    if (!this.eventListeners.has(eventName)) return;
                    const listeners = this.eventListeners.get(eventName);
                    const index = listeners.indexOf(callback);
                    if (index > -1) listeners.splice(index, 1);
                }
                removeAllEventListeners() {
                    this.eventListeners.clear();
                }
                focus() {
                    if (this.container && this.isVisible) this.emit('focused');
                }
                blur() {
                    this.emit('blurred');
                }
            };
            if (typeof window !== 'undefined') {
                window.BaseWindowInstance = BaseWindowInstance;
            }
            base_window_instance_default = BaseWindowInstance;
            console.log('BaseWindowInstance loaded');
            (function () {
                'use strict';
                class BaseWindowInstance2 {
                    constructor(config) {
                        this.instanceId = config.id || this._generateId();
                        this.type = config.type || 'unknown';
                        this.title = config.title || 'Untitled';
                        this.container = null;
                        this.windowElement = null;
                        this.state = this._initializeState(config.initialState || {});
                        this.eventListeners = /* @__PURE__ */ new Map();
                        this.isInitialized = false;
                        this.isVisible = false;
                        this.metadata = config.metadata || {};
                        this._skipInitialRender = false;
                    }
                    _generateId() {
                        return `${this.type}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                    }
                    _initializeState(initialState) {
                        return {
                            ...initialState,
                            created: Date.now(),
                            modified: Date.now(),
                        };
                    }
                    init(container) {
                        if (this.isInitialized) {
                            console.warn(`Instance ${this.instanceId} already initialized`);
                            return;
                        }
                        this.container = container;
                        this.render();
                        this.attachEventListeners();
                        this.isInitialized = true;
                        this.emit('initialized');
                    }
                    render() {
                        throw new Error('render() must be implemented by subclass');
                    }
                    attachEventListeners() {}
                    show() {
                        if (this.container) {
                            const domUtils = window.DOMUtils;
                            if (domUtils && typeof domUtils.show === 'function') {
                                domUtils.show(this.container);
                            } else {
                                this.container.classList.remove('hidden');
                            }
                        }
                    }
                    hide() {
                        if (this.container) {
                            const domUtils = window.DOMUtils;
                            if (domUtils && typeof domUtils.hide === 'function') {
                                domUtils.hide(this.container);
                            } else {
                                this.container.classList.add('hidden');
                            }
                            this.isVisible = false;
                            this.emit('hidden');
                        }
                    }
                    destroy() {
                        this.emit('beforeDestroy');
                        this.removeAllEventListeners();
                        if (this.container) {
                            try {
                                if (typeof this.container.remove === 'function') {
                                    this.container.remove();
                                } else if (this.container.parentNode) {
                                    this.container.parentNode.removeChild(this.container);
                                }
                            } catch {
                                try {
                                    this.container.innerHTML = '';
                                    this.container.classList.add('hidden');
                                } catch {}
                            }
                            this.container = null;
                        }
                        this.windowElement = null;
                        this.isInitialized = false;
                        this.emit('destroyed');
                    }
                    updateState(updates) {
                        const oldState = { ...this.state };
                        this.state = {
                            ...this.state,
                            ...updates,
                            modified: Date.now(),
                        };
                        this.emit('stateChanged', { oldState, newState: this.state });
                        this._triggerAutoSave();
                    }
                    _triggerAutoSave() {
                        triggerAutoSave(this.type);
                    }
                    getState() {
                        return { ...this.state };
                    }
                    serialize() {
                        return {
                            instanceId: this.instanceId,
                            type: this.type,
                            title: this.title,
                            state: this.getState(),
                            metadata: this.metadata,
                        };
                    }
                    deserialize(data) {
                        this._skipInitialRender = true;
                        if (data.state) {
                            this.state = data.state;
                        }
                        if (data.title) {
                            this.title = data.title;
                        }
                        if (data.metadata) {
                            this.metadata = { ...this.metadata, ...data.metadata };
                        }
                        this.emit('deserialized');
                    }
                    emit(eventName, data) {
                        const listeners = this.eventListeners.get(eventName) || [];
                        listeners.forEach(callback => {
                            try {
                                callback.call(this, data);
                            } catch (error) {
                                console.error(`Error in event listener for ${eventName}:`, error);
                            }
                        });
                    }
                    on(eventName, callback) {
                        if (!this.eventListeners.has(eventName)) {
                            this.eventListeners.set(eventName, []);
                        }
                        this.eventListeners.get(eventName).push(callback);
                    }
                    off(eventName, callback) {
                        if (!this.eventListeners.has(eventName)) return;
                        const listeners = this.eventListeners.get(eventName);
                        const index = listeners.indexOf(callback);
                        if (index > -1) {
                            listeners.splice(index, 1);
                        }
                    }
                    removeAllEventListeners() {
                        this.eventListeners.clear();
                    }
                    focus() {
                        if (this.container && this.isVisible) {
                            this.emit('focused');
                        }
                    }
                    blur() {
                        this.emit('blurred');
                    }
                }
                window.BaseWindowInstance = BaseWindowInstance2;
            })();
        },
    });

    // src/ts/windows/instance-manager.ts
    var require_instance_manager = __commonJS({
        'src/ts/windows/instance-manager.ts'() {
            'use strict';
            init_auto_save_helper();
            init_storage_utils();
            console.log('InstanceManager loaded');
            (function () {
                'use strict';
                class InstanceManager {
                    constructor(config) {
                        this.type = config.type;
                        this.instanceClass = config.instanceClass;
                        this.maxInstances = config.maxInstances || 0;
                        this.createContainer =
                            config.createContainer || this._defaultCreateContainer.bind(this);
                        this.instances = /* @__PURE__ */ new Map();
                        this.activeInstanceId = null;
                        this.instanceCounter = 0;
                    }
                    createInstance(config = {}) {
                        if (this.maxInstances > 0 && this.instances.size >= this.maxInstances) {
                            console.warn(
                                `Maximum instances (${this.maxInstances}) reached for ${this.type}`
                            );
                            return null;
                        }
                        this.instanceCounter++;
                        const instanceId = config.id || `${this.type}-${this.instanceCounter}`;
                        if (config.id && this.instances.has(instanceId)) {
                            console.warn(
                                `Instance with id ${instanceId} already exists for ${this.type}; reusing existing instance.`
                            );
                            const existing = this.instances.get(instanceId);
                            try {
                                existing.title = config.title || existing.title;
                                existing.metadata = {
                                    ...existing.metadata,
                                    ...(config.metadata || {}),
                                };
                            } catch {}
                            this.setActiveInstance(instanceId);
                            this._triggerAutoSave();
                            return existing;
                        }
                        const container = this.createContainer(instanceId);
                        if (!container) {
                            console.error('Failed to create container for instance');
                            return null;
                        }
                        const instanceConfig = {
                            id: instanceId,
                            type: this.type,
                            title: config.title || `${this.type} ${this.instanceCounter}`,
                            initialState: config.initialState || {},
                            metadata: config.metadata || {},
                        };
                        const instance = new this.instanceClass(instanceConfig);
                        try {
                            instance.init(container);
                            this.instances.set(instanceId, instance);
                            this._setupInstanceEvents(instance);
                            this.setActiveInstance(instanceId);
                            this._triggerAutoSave();
                            console.log(`Created instance: ${instanceId}`);
                            return instance;
                        } catch (error) {
                            console.error('Failed to initialize instance:', error);
                            container.remove();
                            return null;
                        }
                    }
                    getInstance(instanceId) {
                        return this.instances.get(instanceId) || null;
                    }
                    getActiveInstance() {
                        return this.activeInstanceId
                            ? this.instances.get(this.activeInstanceId) || null
                            : null;
                    }
                    setActiveInstance(instanceId) {
                        if (this.instances.has(instanceId)) {
                            const previousId = this.activeInstanceId;
                            if (previousId === instanceId) {
                                return;
                            }
                            this.activeInstanceId = instanceId;
                            if (previousId) {
                                const previousInstance = this.instances.get(previousId);
                                if (previousInstance) {
                                    previousInstance.blur();
                                }
                            }
                            const instance = this.instances.get(instanceId);
                            if (instance) {
                                instance.focus();
                            }
                            this._triggerAutoSave();
                            try {
                                const KEY = 'windowActiveInstances';
                                const map = getJSON(KEY, {});
                                map[this.type] = this.activeInstanceId;
                                setJSON(KEY, map);
                            } catch {}
                        }
                    }
                    getAllInstances() {
                        return Array.from(this.instances.values());
                    }
                    getAllInstanceIds() {
                        return Array.from(this.instances.keys());
                    }
                    destroyInstance(instanceId) {
                        const instance = this.instances.get(instanceId);
                        if (!instance) {
                            console.warn(`Instance ${instanceId} not found`);
                            return;
                        }
                        instance.destroy();
                        this.instances.delete(instanceId);
                        if (this.activeInstanceId === instanceId) {
                            const remainingIds = this.getAllInstanceIds();
                            const lastId =
                                remainingIds.length > 0
                                    ? remainingIds[remainingIds.length - 1]
                                    : void 0;
                            this.activeInstanceId = lastId != null ? lastId : null;
                        }
                        this._triggerAutoSave();
                        console.log(`Destroyed instance: ${instanceId}`);
                    }
                    destroyAllInstances() {
                        this.instances.forEach(instance => {
                            instance.destroy();
                        });
                        this.instances.clear();
                        this.activeInstanceId = null;
                        this._triggerAutoSave();
                    }
                    hasInstances() {
                        return this.instances.size > 0;
                    }
                    getInstanceCount() {
                        return this.instances.size;
                    }
                    serializeAll() {
                        const activeId = this.activeInstanceId;
                        return this.getAllInstances().map(instance => {
                            const data = instance.serialize();
                            try {
                                const meta = data.metadata || {};
                                if (instance.instanceId === activeId) {
                                    meta.__active = true;
                                }
                                data.metadata = meta;
                            } catch {}
                            return data;
                        });
                    }
                    deserializeAll(data) {
                        if (!Array.isArray(data)) return;
                        let desiredActiveId = null;
                        data.forEach(instanceData => {
                            const instance = this.createInstance({
                                id: instanceData.instanceId,
                                title: instanceData.title,
                                metadata: instanceData.metadata,
                            });
                            if (instance && instanceData.state) {
                                instance.deserialize(instanceData);
                            }
                            try {
                                const meta = instanceData.metadata;
                                if (meta && meta.__active) {
                                    desiredActiveId = instanceData.instanceId || null;
                                }
                            } catch {}
                        });
                        if (desiredActiveId) {
                            this.setActiveInstance(desiredActiveId);
                        } else if (this.instances.size > 0) {
                            const firstInstance = Array.from(this.instances.values())[0];
                            if (firstInstance) {
                                this.setActiveInstance(firstInstance.instanceId);
                            }
                        }
                        this._updateVisibilityAfterRestore();
                    }
                    _updateVisibilityAfterRestore() {
                        const w = window;
                        const integration =
                            w.multiInstanceIntegration || w.MultiInstanceIntegration;
                        if (
                            integration &&
                            typeof integration.updateInstanceVisibility === 'function'
                        ) {
                            integration.updateInstanceVisibility(this.type);
                        }
                    }
                    /**
                     * Reorder instances to match the provided array of instance IDs
                     * @param newOrder - Array of instance IDs in the desired order
                     */
                    reorderInstances(newOrder) {
                        const validIds = newOrder.filter(id => this.instances.has(id));
                        if (validIds.length !== this.instances.size) {
                            console.warn(
                                'Invalid reorder: not all instance IDs provided or some IDs do not exist'
                            );
                            return;
                        }
                        const newMap = /* @__PURE__ */ new Map();
                        validIds.forEach(id => {
                            const instance = this.instances.get(id);
                            if (instance) {
                                newMap.set(id, instance);
                            }
                        });
                        this.instances = newMap;
                        console.log('Instances reordered:', validIds);
                    }
                    _triggerAutoSave() {
                        triggerAutoSave(this.type);
                    }
                    _defaultCreateContainer(instanceId) {
                        const container = document.createElement('div');
                        container.id = `${instanceId}-container`;
                        container.className = 'instance-container';
                        document.body.appendChild(container);
                        return container;
                    }
                    _setupInstanceEvents(instance) {
                        instance.on('focused', () => {
                            this.setActiveInstance(instance.instanceId);
                        });
                        instance.on('destroyed', () => {
                            this.instances.delete(instance.instanceId);
                        });
                    }
                }
                window.InstanceManager = InstanceManager;
            })();
        },
    });

    // src/ts/windows/window-chrome.ts
    var require_window_chrome = __commonJS({
        'src/ts/windows/window-chrome.ts'() {
            'use strict';
            console.log('WindowChrome loaded');
            (function () {
                'use strict';
                function createControlButton(type, symbol, callback) {
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = `window-control-btn window-${type}-btn`;
                    btn.innerHTML = symbol;
                    btn.style.cssText =
                        'width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; border-radius: 4px; transition: background-color 0.2s;';
                    btn.addEventListener('mouseenter', () => {
                        if (type === 'close') {
                            btn.style.backgroundColor = '#ef4444';
                            btn.style.color = '#ffffff';
                        } else {
                            btn.style.backgroundColor = 'rgba(0, 0, 0, 0.1)';
                        }
                    });
                    btn.addEventListener('mouseleave', () => {
                        btn.style.backgroundColor = 'transparent';
                        btn.style.color = '';
                    });
                    if (callback) {
                        btn.addEventListener('click', () => callback());
                    }
                    return btn;
                }
                function createToolbarButton(config) {
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className =
                        'toolbar-btn px-2 py-1 text-sm rounded hover:bg-gray-200 dark:hover:bg-gray-800 transition';
                    if (config.icon) {
                        btn.innerHTML = config.icon;
                    } else if (config.label) {
                        btn.textContent = config.label;
                    }
                    if (config.title) btn.title = config.title;
                    if (config.action) btn.dataset.action = config.action;
                    if (config.onClick) btn.addEventListener('click', config.onClick);
                    return btn;
                }
                const WindowChrome2 = {
                    createTitlebar(config) {
                        const titlebar = document.createElement('div');
                        titlebar.className =
                            'window-titlebar flex items-center justify-between px-3 py-2 bg-gray-200 dark:bg-gray-800 border-b border-gray-300 dark:border-gray-700';
                        titlebar.style.cssText = 'height: 32px; cursor: move; user-select: none;';
                        const leftSide = document.createElement('div');
                        leftSide.className = 'flex items-center gap-2';
                        if (config.icon) {
                            const iconEl = document.createElement('span');
                            iconEl.className = 'window-icon';
                            if (
                                config.icon.startsWith('http') ||
                                config.icon.startsWith('./') ||
                                config.icon.startsWith('/')
                            ) {
                                const img = document.createElement('img');
                                img.src = config.icon;
                                img.alt = '';
                                img.style.cssText =
                                    'width: 16px; height: 16px; object-fit: contain;';
                                iconEl.appendChild(img);
                            } else {
                                iconEl.textContent = config.icon;
                                iconEl.style.fontSize = '16px';
                            }
                            leftSide.appendChild(iconEl);
                        }
                        const titleEl = document.createElement('span');
                        titleEl.className =
                            'window-title font-medium text-sm text-gray-800 dark:text-gray-200';
                        titleEl.textContent = config.title || 'Untitled';
                        titleEl.dataset.titleTarget = 'true';
                        leftSide.appendChild(titleEl);
                        titlebar.appendChild(leftSide);
                        const rightSide = document.createElement('div');
                        rightSide.className = 'flex items-center gap-1';
                        if (config.showMinimize) {
                            rightSide.appendChild(
                                createControlButton('minimize', '\u2212', config.onMinimize)
                            );
                        }
                        if (config.showMaximize) {
                            rightSide.appendChild(
                                createControlButton('maximize', '\u25A1', config.onMaximize)
                            );
                        }
                        if (config.showClose !== false) {
                            rightSide.appendChild(
                                createControlButton('close', '\xD7', config.onClose)
                            );
                        }
                        titlebar.appendChild(rightSide);
                        return titlebar;
                    },
                    createToolbar(buttons) {
                        const toolbar = document.createElement('div');
                        toolbar.className =
                            'window-toolbar flex items-center gap-2 px-3 py-2 bg-gray-100 dark:bg-gray-900 border-b border-gray-300 dark:border-gray-700';
                        buttons.forEach(btn => {
                            if (btn.type === 'separator') {
                                const separator = document.createElement('div');
                                separator.className = 'toolbar-separator';
                                separator.style.cssText =
                                    'width: 1px; height: 20px; background: currentColor; opacity: 0.2;';
                                toolbar.appendChild(separator);
                            } else {
                                toolbar.appendChild(createToolbarButton(btn));
                            }
                        });
                        return toolbar;
                    },
                    createStatusBar(config) {
                        const statusBar = document.createElement('div');
                        statusBar.className =
                            'window-statusbar flex items-center justify-between px-3 py-1 bg-gray-100 dark:bg-gray-900 border-t border-gray-300 dark:border-gray-700 text-xs text-gray-600 dark:text-gray-400';
                        statusBar.style.cssText = 'height: 24px;';
                        const leftEl = document.createElement('span');
                        leftEl.className = 'statusbar-left';
                        leftEl.textContent = config.leftContent || '';
                        statusBar.appendChild(leftEl);
                        const rightEl = document.createElement('span');
                        rightEl.className = 'statusbar-right';
                        rightEl.textContent = config.rightContent || '';
                        statusBar.appendChild(rightEl);
                        return statusBar;
                    },
                    updateTitle(titlebar, newTitle) {
                        const titleEl = titlebar.querySelector('[data-title-target="true"]');
                        if (titleEl) titleEl.textContent = newTitle;
                    },
                    updateStatusBar(statusBar, side, content) {
                        const target = statusBar.querySelector(`.statusbar-${side}`);
                        if (target) target.textContent = content;
                    },
                    createWindowFrame(config) {
                        const frame = document.createElement('div');
                        frame.className =
                            'window-frame flex flex-col h-full bg-white dark:bg-gray-900 rounded-lg shadow-lg overflow-hidden';
                        const titlebar = this.createTitlebar({
                            title: config.title || 'Untitled',
                            icon: config.icon,
                            showClose: config.showClose,
                            showMinimize: config.showMinimize,
                            showMaximize: config.showMaximize,
                            onClose: config.onClose,
                            onMinimize: config.onMinimize,
                            onMaximize: config.onMaximize,
                        });
                        frame.appendChild(titlebar);
                        if (config.toolbar) {
                            const toolbar = this.createToolbar(config.toolbar);
                            frame.appendChild(toolbar);
                        }
                        const content = document.createElement('div');
                        content.className = 'window-content flex-1 overflow-auto';
                        frame.appendChild(content);
                        let statusbar = null;
                        if (config.showStatusBar) {
                            statusbar = this.createStatusBar({
                                leftContent: config.statusBarLeft || '',
                                rightContent: config.statusBarRight || '',
                            });
                            frame.appendChild(statusbar);
                        }
                        return { frame, titlebar, content, statusbar };
                    },
                };
                window.WindowChrome = WindowChrome2;
            })();
        },
    });

    // src/ts/windows/base-tab.ts
    var BaseTab;
    var init_base_tab = __esm({
        'src/ts/windows/base-tab.ts'() {
            'use strict';
            BaseTab = class _BaseTab {
                constructor(config) {
                    this.id = config.id || this._generateId();
                    this.type = config.type;
                    this.title = config.title || 'Untitled';
                    this.icon = config.icon;
                    this.parentWindow = null;
                    this.element = null;
                    this.contentState = config.content || {};
                    this.metadata = config.metadata || {
                        created: Date.now(),
                        modified: Date.now(),
                    };
                    this.isVisible = false;
                }
                _generateId() {
                    return `tab-${this.type}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                }
                /**
                 * Set parent window (called when tab is added to a window)
                 */
                setParentWindow(window2) {
                    this.parentWindow = window2;
                }
                /**
                 * Erstellt das DOM des Tabs. Subklassen MSSEN berschreiben. Der Default
                 * liefert nur einen Platzhalter.
                 */
                createDOM() {
                    const container = document.createElement('div');
                    container.id = `${this.id}-container`;
                    container.className = 'tab-content hidden w-full h-full';
                    container.textContent = `Tab content for ${this.title}`;
                    this.element = container;
                    return container;
                }
                /**
                 * Rendering-Hook. Subklassen implementieren hier die eigentliche UI.
                 */
                render() {
                    if (!this.element) {
                        this.createDOM();
                    }
                }
                /**
                 * Tab sichtbar machen und ggf. in die ContentArea des Elternfensters einhngen.
                 */
                show() {
                    var _a;
                    if (!this.element) {
                        this.render();
                        if ((_a = this.parentWindow) == null ? void 0 : _a.contentElement) {
                            this.parentWindow.contentElement.appendChild(this.element);
                        }
                    }
                    if (this.element) {
                        const domUtils = window.DOMUtils;
                        if (domUtils && typeof domUtils.show === 'function') {
                            domUtils.show(this.element);
                        } else {
                            this.element.classList.remove('hidden');
                        }
                    }
                    this.isVisible = true;
                    this.onShow();
                }
                /**
                 * Tab verbergen (DOM bleibt erhalten, CSS .hidden).
                 */
                hide() {
                    if (this.element) {
                        const domUtils = window.DOMUtils;
                        if (domUtils && typeof domUtils.hide === 'function') {
                            domUtils.hide(this.element);
                        } else {
                            this.element.classList.add('hidden');
                        }
                    }
                    this.isVisible = false;
                    this.onHide();
                }
                /**
                 * LifecycleHook beim Anzeigen.
                 */
                onShow() {}
                /**
                 * LifecycleHook beim Verbergen.
                 */
                onHide() {}
                /**
                 * Tabtitel aktualisieren und Parent zur TabbarReRender benachrichtigen.
                 */
                setTitle(title) {
                    var _a, _b;
                    this.title = title;
                    this.metadata.modified = Date.now();
                    if (this.parentWindow) {
                        (_b = (_a = this.parentWindow)._renderTabs) == null ? void 0 : _b.call(_a);
                    }
                }
                /**
                 * ContentState aktualisieren (z. B. Cursorposition, offene Datei, Sortierung,...)
                 */
                updateContentState(updates) {
                    this.contentState = {
                        ...this.contentState,
                        ...updates,
                    };
                    this.metadata.modified = Date.now();
                    this._saveState();
                }
                /**
                 * Serialize tab state for session management
                 */
                serialize() {
                    return {
                        id: this.id,
                        type: this.type,
                        title: this.title,
                        icon: this.icon,
                        contentState: this.contentState,
                        created: this.metadata.created,
                        modified: this.metadata.modified || Date.now(),
                    };
                }
                /**
                 * Rehydrierung  Subklassen berschreiben diese Methode meist, um ihren
                 * konkreten Zustand zurckzusetzen.
                 */
                static deserialize(state) {
                    return new _BaseTab({
                        id: state.id,
                        type: state.type,
                        title: state.title,
                        icon: state.icon,
                        content: state.contentState,
                        metadata: {
                            created: state.created,
                            modified: state.modified,
                        },
                    });
                }
                _saveState() {
                    var _a, _b;
                    if (this.parentWindow) {
                        (_b = (_a = this.parentWindow)._saveState) == null ? void 0 : _b.call(_a);
                    }
                }
                /**
                 * Transfer tab to another window
                 */
                transferTo(targetWindow) {
                    if (!this.parentWindow || this.parentWindow === targetWindow) return;
                    this.parentWindow.removeTab(this.id);
                    targetWindow.addTab(this);
                }
                /**
                 * Destroy tab and cleanup
                 */
                destroy() {
                    if (this.element) {
                        this.element.remove();
                        this.element = null;
                    }
                    this.parentWindow = null;
                    this._saveState();
                }
            };
            window.BaseTab = BaseTab;
        },
    });

    // src/ts/windows/base-window.ts
    var BaseWindow;
    var init_base_window = __esm({
        'src/ts/windows/base-window.ts'() {
            'use strict';
            init_z_index_manager();
            BaseWindow = class _BaseWindow {
                constructor(config) {
                    this.type = config.type;
                    this.id = config.id || this._generateId();
                    this.element = null;
                    this.titlebarElement = null;
                    this.contentElement = null;
                    this.position = config.position || this._getDefaultPosition();
                    this.zIndex = 1e3;
                    this.isMinimized = false;
                    this.isMaximized = false;
                    this.tabs = /* @__PURE__ */ new Map();
                    this.activeTabId = null;
                    this.metadata = config.metadata || {};
                    this.dragState = {
                        isDragging: false,
                        startX: 0,
                        startY: 0,
                        offsetX: 0,
                        offsetY: 0,
                    };
                    if (config.tabs) {
                        config.tabs.forEach(tab => this.addTab(tab));
                    }
                }
                _generateId() {
                    return `window-${this.type}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                }
                _getDefaultPosition() {
                    const offset = Math.random() * 100 - 50;
                    return {
                        x: window.innerWidth / 2 - 400 + offset,
                        y: window.innerHeight / 2 - 300 + offset,
                        width: 800,
                        height: 600,
                    };
                }
                /**
                 * Create the window DOM element.
                 * Subklassen knnen berschreiben, wenn z. B. eine dedizierte Tabbar
                 * oder zustzliche UIElemente ntig sind. Wichtig: setze this.element,
                 * this.titlebarElement und this.contentElement.
                 */
                createDOM() {
                    const windowEl = document.createElement('div');
                    windowEl.id = this.id;
                    windowEl.className =
                        'modal multi-window hidden fixed bg-white dark:bg-gray-800 rounded-lg overflow-hidden shadow-lg flex flex-col max-h-[90vh] min-w-[560px] min-h-[360px]';
                    windowEl.setAttribute('role', 'dialog');
                    windowEl.setAttribute('aria-modal', 'false');
                    windowEl.style.pointerEvents = 'auto';
                    windowEl.style.left = `${this.position.x}px`;
                    windowEl.style.top = `${this.position.y}px`;
                    windowEl.style.width = `${this.position.width}px`;
                    windowEl.style.height = `${this.position.height}px`;
                    windowEl.style.zIndex = String(this.zIndex);
                    this.titlebarElement = this._createTitlebar();
                    windowEl.appendChild(this.titlebarElement);
                    const tabBar = document.createElement('div');
                    tabBar.id = `${this.id}-tabs`;
                    tabBar.className = 'window-tab-bar';
                    windowEl.appendChild(tabBar);
                    this.contentElement = document.createElement('div');
                    this.contentElement.id = `${this.id}-content`;
                    this.contentElement.className = 'flex-1 overflow-hidden';
                    windowEl.appendChild(this.contentElement);
                    this.element = windowEl;
                    this._attachDragHandlers();
                    this._attachFocusHandler();
                    this._attachResizeHandlers();
                    this._registerWithWindowManager();
                    const W = window;
                    if (W.appI18n && typeof W.appI18n.applyTranslations === 'function') {
                        W.appI18n.applyTranslations(windowEl);
                    }
                    return windowEl;
                }
                /**
                 * Baut die Titelleiste inklusive Close/Minimize/Maximize Dots.
                 * Events sind an BaseWindowMethoden gebunden (close/minimize/toggleMaximize).
                 */
                _createTitlebar() {
                    const titlebar = document.createElement('div');
                    titlebar.className =
                        'window-titlebar flex items-center px-4 py-2 bg-gray-200 dark:bg-gray-700 rounded-t-lg draggable-header cursor-move';
                    const controls = document.createElement('div');
                    controls.className = 'flex space-x-2';
                    const closeBtn = document.createElement('button');
                    closeBtn.className =
                        'ml-auto text-2xl leading-none text-gray-700 dark:text-gray-300';
                    closeBtn.title = 'Schlie\xDFen';
                    closeBtn.setAttribute('data-i18n-title', 'common.close');
                    closeBtn.innerHTML = '<div class="w-3 h-3 bg-red-500 rounded-full"></div>';
                    closeBtn.addEventListener('click', () => this.close());
                    const minBtn = document.createElement('div');
                    minBtn.className = 'w-3 h-3 bg-yellow-500 rounded-full cursor-pointer';
                    minBtn.title = 'Minimieren';
                    minBtn.setAttribute('data-i18n-title', 'menuItems.window.minimize');
                    minBtn.addEventListener('click', () => this.minimize());
                    const maxBtn = document.createElement('div');
                    maxBtn.className = 'w-3 h-3 bg-green-500 rounded-full cursor-pointer';
                    maxBtn.title = 'Zoomen';
                    maxBtn.setAttribute('data-i18n-title', 'menuItems.window.zoom');
                    maxBtn.addEventListener('click', () => this.toggleMaximize());
                    controls.appendChild(closeBtn);
                    controls.appendChild(minBtn);
                    controls.appendChild(maxBtn);
                    const title = document.createElement('h2');
                    title.className =
                        'ml-4 font-semibold text-gray-700 dark:text-gray-300 no-select';
                    const typeKey = this.type === 'text-editor' ? 'text' : this.type;
                    const titleKey = `desktop.${typeKey}`;
                    title.setAttribute('data-i18n', titleKey);
                    title.textContent = this.metadata.title || this.type;
                    titlebar.appendChild(controls);
                    titlebar.appendChild(title);
                    return titlebar;
                }
                /**
                 * Ermglicht Dragging des Fensters ber die Titelleiste.
                 * Speicherung der Position erfolgt am Ende des Drags via _saveState().
                 */
                _attachDragHandlers() {
                    if (!this.titlebarElement) return;
                    this.titlebarElement.addEventListener('mousedown', e => {
                        var _a;
                        if (e.target.tagName === 'BUTTON') return;
                        this.dragState.isDragging = true;
                        this.dragState.startX = e.clientX;
                        this.dragState.startY = e.clientY;
                        const rect =
                            (_a = this.element) == null ? void 0 : _a.getBoundingClientRect();
                        if (rect) {
                            this.dragState.offsetX = this.dragState.startX - rect.left;
                            this.dragState.offsetY = this.dragState.startY - rect.top;
                        }
                        e.preventDefault();
                    });
                    document.addEventListener('mousemove', e => {
                        if (!this.dragState.isDragging || !this.element) return;
                        const newX = e.clientX - this.dragState.offsetX;
                        const newY = e.clientY - this.dragState.offsetY;
                        this.position.x = newX;
                        this.position.y = newY;
                        this._updatePosition();
                    });
                    document.addEventListener('mouseup', () => {
                        if (this.dragState.isDragging) {
                            this.dragState.isDragging = false;
                            this._saveState();
                        }
                    });
                }
                /**
                 * Klick in das Fenster bringt es nach vorne und aktualisiert MenubarStatus.
                 */
                _attachFocusHandler() {
                    if (!this.element) return;
                    this.element.addEventListener('mousedown', () => {
                        this.bringToFront();
                    });
                }
                /**
                 * Fgt 8 ResizeGriffe hinzu (N, S, E, W sowie Ecken).
                 * Whrend des Resizings wird ein Overlay gesetzt, um MouseEvents zuverlssig
                 * zu capturen. Mindestgren werden bercksichtigt.
                 */
                _attachResizeHandlers() {
                    if (!this.element) return;
                    const existingHandles = this.element.querySelectorAll('.resizer');
                    existingHandles.forEach(handle => handle.remove());
                    const createHandle = handle => {
                        const resizer = document.createElement('div');
                        resizer.classList.add('resizer', `resizer-${handle.name}`);
                        Object.assign(resizer.style, {
                            position: 'absolute',
                            zIndex: '9999',
                            backgroundColor: 'transparent',
                            pointerEvents: 'auto',
                            touchAction: 'none',
                            cursor: handle.cursor,
                            ...(handle.style || {}),
                        });
                        this.element.appendChild(resizer);
                        const startResize = event => {
                            event.preventDefault();
                            event.stopPropagation();
                            this.bringToFront();
                            const startX = event.clientX;
                            const startY = event.clientY;
                            const rect = this.element.getBoundingClientRect();
                            const computed = window.getComputedStyle(this.element);
                            const minWidth = parseFloat(computed.minWidth) || 560;
                            const minHeight = parseFloat(computed.minHeight) || 360;
                            let startLeft = parseFloat(computed.left);
                            let startTop = parseFloat(computed.top);
                            if (!Number.isFinite(startLeft)) startLeft = rect.left;
                            if (!Number.isFinite(startTop)) startTop = rect.top;
                            const startWidth = rect.width;
                            const startHeight = rect.height;
                            const overlay = document.createElement('div');
                            Object.assign(overlay.style, {
                                position: 'fixed',
                                top: '0',
                                left: '0',
                                width: '100%',
                                height: '100%',
                                zIndex: '9999',
                                cursor: handle.cursor,
                                backgroundColor: 'transparent',
                                touchAction: 'none',
                            });
                            document.body.appendChild(overlay);
                            let resizing = true;
                            const applySize = (clientX, clientY) => {
                                if (!resizing) return;
                                window.requestAnimationFrame(() => {
                                    var _a;
                                    const dx = clientX - startX;
                                    const dy = clientY - startY;
                                    let newWidth = startWidth;
                                    let newHeight = startHeight;
                                    let newLeft = startLeft;
                                    let newTop = startTop;
                                    if (handle.directions.includes('e')) newWidth = startWidth + dx;
                                    if (handle.directions.includes('s'))
                                        newHeight = startHeight + dy;
                                    if (handle.directions.includes('w')) {
                                        newWidth = startWidth - dx;
                                        newLeft = startLeft + dx;
                                    }
                                    if (handle.directions.includes('n')) {
                                        newHeight = startHeight - dy;
                                        newTop = startTop + dy;
                                    }
                                    if (newWidth < minWidth) {
                                        const deficit = minWidth - newWidth;
                                        if (handle.directions.includes('w')) newLeft -= deficit;
                                        newWidth = minWidth;
                                    }
                                    if (newHeight < minHeight) {
                                        const deficit = minHeight - newHeight;
                                        if (handle.directions.includes('n')) newTop -= deficit;
                                        newHeight = minHeight;
                                    }
                                    const minTop =
                                        ((_a = window.getMenuBarBottom) == null
                                            ? void 0
                                            : _a.call(window)) || 0;
                                    if (handle.directions.includes('n') && newTop < minTop) {
                                        const overshoot = minTop - newTop;
                                        newTop = minTop;
                                        newHeight = Math.max(minHeight, newHeight - overshoot);
                                    }
                                    if (
                                        handle.directions.includes('w') ||
                                        handle.directions.includes('e')
                                    ) {
                                        this.element.style.width =
                                            Math.max(minWidth, newWidth) + 'px';
                                        this.position.width = Math.max(minWidth, newWidth);
                                    }
                                    if (
                                        handle.directions.includes('s') ||
                                        handle.directions.includes('n')
                                    ) {
                                        this.element.style.height =
                                            Math.max(minHeight, newHeight) + 'px';
                                        this.position.height = Math.max(minHeight, newHeight);
                                    }
                                    if (handle.directions.includes('w')) {
                                        this.element.style.left = newLeft + 'px';
                                        this.position.x = newLeft;
                                    }
                                    if (handle.directions.includes('n')) {
                                        this.element.style.top = newTop + 'px';
                                        this.position.y = newTop;
                                    }
                                });
                            };
                            const stopResize = () => {
                                if (!resizing) return;
                                resizing = false;
                                overlay.remove();
                                overlay.removeEventListener('mousemove', overlayMouseMove);
                                overlay.removeEventListener('mouseup', overlayMouseUp);
                                window.removeEventListener('mousemove', windowMouseMove);
                                window.removeEventListener('mouseup', windowMouseUp);
                                window.removeEventListener('blur', onBlur);
                                this._saveState();
                            };
                            const overlayMouseMove = moveEvent =>
                                applySize(moveEvent.clientX, moveEvent.clientY);
                            const windowMouseMove = moveEvent =>
                                applySize(moveEvent.clientX, moveEvent.clientY);
                            const overlayMouseUp = () => stopResize();
                            const windowMouseUp = () => stopResize();
                            const onBlur = () => stopResize();
                            overlay.addEventListener('mousemove', overlayMouseMove);
                            overlay.addEventListener('mouseup', overlayMouseUp);
                            window.addEventListener('mousemove', windowMouseMove);
                            window.addEventListener('mouseup', windowMouseUp);
                            window.addEventListener('blur', onBlur);
                        };
                        resizer.addEventListener('mousedown', startResize);
                    };
                    const handles = [
                        {
                            name: 'top',
                            cursor: 'n-resize',
                            directions: ['n'],
                            style: { top: '-4px', left: '12px', right: '12px', height: '8px' },
                        },
                        {
                            name: 'bottom',
                            cursor: 's-resize',
                            directions: ['s'],
                            style: { bottom: '-4px', left: '12px', right: '12px', height: '8px' },
                        },
                        {
                            name: 'left',
                            cursor: 'w-resize',
                            directions: ['w'],
                            style: { left: '-4px', top: '12px', bottom: '12px', width: '8px' },
                        },
                        {
                            name: 'right',
                            cursor: 'e-resize',
                            directions: ['e'],
                            style: { right: '-4px', top: '12px', bottom: '12px', width: '8px' },
                        },
                        {
                            name: 'top-left',
                            cursor: 'nw-resize',
                            directions: ['n', 'w'],
                            style: { top: '-6px', left: '-6px', width: '14px', height: '14px' },
                        },
                        {
                            name: 'top-right',
                            cursor: 'ne-resize',
                            directions: ['n', 'e'],
                            style: { top: '-6px', right: '-6px', width: '14px', height: '14px' },
                        },
                        {
                            name: 'bottom-left',
                            cursor: 'sw-resize',
                            directions: ['s', 'w'],
                            style: { bottom: '-6px', left: '-6px', width: '14px', height: '14px' },
                        },
                        {
                            name: 'bottom-right',
                            cursor: 'se-resize',
                            directions: ['s', 'e'],
                            style: { bottom: '-6px', right: '-6px', width: '14px', height: '14px' },
                        },
                    ];
                    handles.forEach(createHandle);
                }
                _updatePosition() {
                    if (!this.element) return;
                    this.element.style.left = `${this.position.x}px`;
                    this.element.style.top = `${this.position.y}px`;
                }
                /**
                 * Fenster anzeigen. Erzeugt bei Bedarf das DOM, hngt Tabs an die ContentArea an
                 * und ruft bringToFront() + MenubarUpdate. Persistiert den Zustand.
                 */
                show() {
                    var _a, _b;
                    if (!this.element) {
                        this.createDOM();
                        document.body.appendChild(this.element);
                        if (this.contentElement) {
                            this.tabs.forEach(tab => {
                                if (tab.element && !this.contentElement.contains(tab.element)) {
                                    this.contentElement.appendChild(tab.element);
                                }
                            });
                        }
                    }
                    if (this.element) {
                        const domUtils = window.DOMUtils;
                        if (domUtils && typeof domUtils.show === 'function') {
                            domUtils.show(this.element);
                        } else {
                            this.element.classList.remove('hidden');
                        }
                    }
                    this.bringToFront();
                    const W = window;
                    (_a = W.updateProgramLabelByTopModal) == null ? void 0 : _a.call(W);
                    (_b = W.updateDockIndicators) == null ? void 0 : _b.call(W);
                    this._saveState();
                }
                /**
                 * Fenster ausblenden und Menubar entsprechend aktualisieren.
                 */
                hide() {
                    var _a, _b, _c;
                    (_a = this.element) == null ? void 0 : _a.classList.add('hidden');
                    const W = window;
                    (_b = W.updateProgramLabelByTopModal) == null ? void 0 : _b.call(W);
                    const menuSystem = W.MenuSystem;
                    if (menuSystem == null ? void 0 : menuSystem.renderApplicationMenu) {
                        const current =
                            (_c = menuSystem.getCurrentMenuModalId) == null
                                ? void 0
                                : _c.call(menuSystem);
                        menuSystem.renderApplicationMenu(current);
                    }
                    this._saveState();
                }
                /**
                 * Fenster schlieen. bergibt die endgltige Entfernung an den WindowRegistry,
                 * sodass dieser Aufrumarbeiten bernehmen kann.
                 */
                close() {
                    var _a, _b;
                    this.hide();
                    const W = window;
                    const zIndexManager = getZIndexManager();
                    zIndexManager.removeWindow(this.id);
                    if (W.WindowRegistry) {
                        W.WindowRegistry.removeWindow(this.id);
                    }
                    (_a = W.updateDockIndicators) == null ? void 0 : _a.call(W);
                    const menuSystem = W.MenuSystem;
                    if (menuSystem == null ? void 0 : menuSystem.renderApplicationMenu) {
                        const current =
                            (_b = menuSystem.getCurrentMenuModalId) == null
                                ? void 0
                                : _b.call(menuSystem);
                        menuSystem.renderApplicationMenu(current);
                    }
                }
                /**
                 * Fenster minimieren (aktuell nur Hide + Flag). Integration in Dock/Taskbar
                 * kann spter hier erfolgen.
                 */
                minimize() {
                    this.isMinimized = true;
                    this.hide();
                }
                /**
                 * Maximieren/Restore. Setzt inlineStyles auf das innere WindowElement.
                 */
                toggleMaximize() {
                    this.isMaximized = !this.isMaximized;
                    if (!this.element) return;
                    const windowEl = this.element.querySelector('div');
                    if (!windowEl) return;
                    if (this.isMaximized) {
                        windowEl.style.width = '95vw';
                        windowEl.style.height = '95vh';
                    } else {
                        windowEl.style.width = `${this.position.width}px`;
                        windowEl.style.height = `${this.position.height}px`;
                    }
                    this._saveState();
                }
                /**
                 * Nach vorne holen. Nutzt bevorzugt den (legacy) __zIndexManager, ansonsten
                 * WindowRegistry.getNextZIndex(). Aktualisiert die Menubar.
                 */
                bringToFront() {
                    var _a, _b, _c, _d;
                    const W = window;
                    const zIndexManager = getZIndexManager();
                    zIndexManager.bringToFront(this.id, this.element, this.element);
                    if (this.element) {
                        const currentZ = parseInt(this.element.style.zIndex || '0', 10);
                        if (!Number.isNaN(currentZ)) this.zIndex = currentZ;
                    }
                    (_b = (_a = W.WindowRegistry) == null ? void 0 : _a.setActiveWindow) == null
                        ? void 0
                        : _b.call(_a, this.id);
                    (_c = W.updateProgramLabelByTopModal) == null ? void 0 : _c.call(W);
                    const menuSystem = W.MenuSystem;
                    if (menuSystem == null ? void 0 : menuSystem.renderApplicationMenu) {
                        const current =
                            (_d = menuSystem.getCurrentMenuModalId) == null
                                ? void 0
                                : _d.call(menuSystem);
                        menuSystem.renderApplicationMenu(current);
                    }
                }
                /**
                 * Tab hinzufgen. Erzeugt bei Bedarf dessen DOM und hngt ihn in die ContentArea.
                 * Falls noch kein aktiver Tab existiert, wird dieser gesetzt. Rendert die Tabbar neu
                 * und speichert den Zustand.
                 */
                addTab(tab) {
                    this.tabs.set(tab.id, tab);
                    tab.setParentWindow(this);
                    if (!tab.element) {
                        tab.element = tab.createDOM();
                    }
                    if (tab.element && this.contentElement) {
                        this.contentElement.appendChild(tab.element);
                    }
                    if (!this.activeTabId) {
                        this.setActiveTab(tab.id);
                    }
                    this._renderTabs();
                    this._saveState();
                }
                /**
                 * Tab entfernen und ggf. anderen Tab aktivieren. Bei Leere wird das Fenster
                 * automatisch geschlossen.
                 */
                removeTab(tabId) {
                    const tab = this.tabs.get(tabId);
                    if (!tab) return;
                    tab.destroy();
                    this.tabs.delete(tabId);
                    if (this.activeTabId === tabId) {
                        const remainingTabs = Array.from(this.tabs.keys());
                        this.activeTabId = remainingTabs[0] || null;
                        if (this.activeTabId) {
                            this.setActiveTab(this.activeTabId);
                        }
                    }
                    if (this.tabs.size === 0) {
                        this.close();
                    } else {
                        this._renderTabs();
                        this._saveState();
                    }
                }
                /**
                 * Tab abkoppeln (z. B. fr Drag&Drop in anderes Fenster). Der Tab bleibt bestehen,
                 * wird aber aus diesem Fenster entfernt und versteckt.
                 */
                detachTab(tabId) {
                    const tab = this.tabs.get(tabId) || null;
                    if (!tab) return null;
                    tab.hide();
                    tab.setParentWindow(null);
                    this.tabs.delete(tabId);
                    if (this.activeTabId === tabId) {
                        const remaining = Array.from(this.tabs.keys());
                        this.activeTabId = remaining[0] || null;
                        if (this.activeTabId) this.setActiveTab(this.activeTabId);
                    }
                    if (this.tabs.size === 0) {
                        this.close();
                    } else {
                        this._renderTabs();
                        this._saveState();
                    }
                    return tab;
                }
                /**
                 * Tab in ein ZielFenster verschieben.
                 */
                transferTabTo(target, tabId) {
                    const tab = this.detachTab(tabId);
                    if (tab) {
                        target.addTab(tab);
                        target.setActiveTab(tab.id);
                    }
                }
                /**
                 * Aktiven Tab setzen (zeigt diesen und versteckt alle anderen).
                 */
                setActiveTab(tabId) {
                    const tab = this.tabs.get(tabId);
                    if (!tab) return;
                    this.tabs.forEach(t2 => t2.hide());
                    this.activeTabId = tabId;
                    tab.show();
                    this._renderTabs();
                    this._saveState();
                }
                /**
                 * Einfache DefaultTabbar. Subklassen (z. B. FinderWindow/TextEditorWindow) knnen
                 * diese Methode berschreiben und die dedizierte WindowTabsLeiste nutzen.
                 */
                _renderTabs() {
                    var _a;
                    const tabBar =
                        (_a = this.element) == null ? void 0 : _a.querySelector(`#${this.id}-tabs`);
                    if (!tabBar) return;
                    tabBar.innerHTML = '';
                    this.tabs.forEach(tab => {
                        const tabEl = document.createElement('button');
                        tabEl.className = `px-3 py-1 text-sm ${tab.id === this.activeTabId ? 'bg-white dark:bg-gray-900' : 'bg-gray-200 dark:bg-gray-800'}`;
                        tabEl.textContent = tab.title;
                        tabEl.addEventListener('click', () => this.setActiveTab(tab.id));
                        tabBar.appendChild(tabEl);
                    });
                }
                /**
                 * Serialisierung des Fensterzustands (fr SessionRestore).
                 */
                serialize() {
                    return {
                        id: this.id,
                        type: this.type,
                        position: { ...this.position },
                        zIndex: this.zIndex,
                        isMinimized: this.isMinimized,
                        isMaximized: this.isMaximized,
                        activeTabId: this.activeTabId,
                        tabs: Array.from(this.tabs.keys()),
                        created: this.metadata.created || Date.now(),
                        modified: Date.now(),
                    };
                }
                /**
                 * Rehydrierung aus persistiertem Zustand. Subklassen knnen eigene
                 * deserializeRoutinen bereitstellen.
                 */
                static deserialize(state) {
                    const window2 = new _BaseWindow({
                        id: state.id,
                        type: state.type,
                        position: state.position,
                        metadata: {
                            created: state.created,
                        },
                    });
                    window2.zIndex = state.zIndex;
                    window2.isMinimized = state.isMinimized;
                    window2.isMaximized = state.isMaximized;
                    window2.activeTabId = state.activeTabId;
                    return window2;
                }
                _saveState() {
                    var _a, _b;
                    const W = window;
                    if (W.MultiWindowSessionManager) {
                        W.MultiWindowSessionManager.saveSession();
                    }
                    if (W.SessionManager) {
                        (_b = (_a = W.SessionManager).saveWindowState) == null
                            ? void 0
                            : _b.call(_a, this.serialize());
                    }
                }
                /**
                 * Vollstndiges Aufrumen: Tabs zerstren, DOM entfernen, Menubar aktualisieren
                 * und Session speichern.
                 */
                destroy() {
                    var _a;
                    this.tabs.forEach(tab => tab.destroy());
                    this.tabs.clear();
                    if (this.element) {
                        this.element.remove();
                        this.element = null;
                    }
                    this._saveState();
                    const W = window;
                    (_a = W.updateProgramLabelByTopModal) == null ? void 0 : _a.call(W);
                }
                /**
                 * Registrierung im (legacy) WindowManager, damit ProgramLabel/Anwendungsmens
                 * korrekt auf das aktive Fenster gemappt werden. Diese Brcke hlt die neue
                 * MultiWindowWelt kompatibel zur bestehenden Menubar.
                 */
                _registerWithWindowManager() {
                    const W = window;
                    const WM = W.WindowManager;
                    if (
                        !WM ||
                        typeof WM.getConfig !== 'function' ||
                        typeof WM.register !== 'function'
                    )
                        return;
                    if (WM.getConfig(this.id)) return;
                    const map = {
                        finder: { programKey: 'programs.finder', icon: './img/sucher.png' },
                        'text-editor': { programKey: 'programs.text', icon: './img/notepad.png' },
                        terminal: { programKey: 'programs.terminal', icon: './img/terminal.png' },
                    };
                    const meta = map[this.type] || {
                        programKey: 'programs.default',
                        icon: './img/sucher.png',
                    };
                    try {
                        WM.register({
                            id: this.id,
                            type: 'persistent',
                            programKey: meta.programKey,
                            icon: meta.icon,
                            closeButtonId: null,
                            metadata: {
                                /* dynamic multi-window */
                            },
                        });
                        if (typeof WM.setDialogInstance === 'function') {
                            WM.setDialogInstance(this.id, {
                                open: () => this.show(),
                                close: () => this.hide(),
                                bringToFront: () => this.bringToFront(),
                            });
                        }
                    } catch (e) {
                        console.warn('[BaseWindow] WM.register failed for', this.id, e);
                    }
                }
            };
            window.BaseWindow = BaseWindow;
        },
    });

    // src/ts/windows/window-registry.ts
    var WindowRegistry, registry, window_registry_default;
    var init_window_registry = __esm({
        'src/ts/windows/window-registry.ts'() {
            'use strict';
            init_z_index_manager();
            WindowRegistry = class {
                constructor() {
                    this.zIndexManager = getZIndexManager();
                    this.windows = /* @__PURE__ */ new Map();
                    this.nextZIndex = BASE_Z_INDEX2;
                    this.initialized = false;
                    this.activeWindowId = null;
                }
                /**
                 * Sync z-index with WindowManager to avoid conflicts
                 */
                _syncZIndexWithWindowManager() {
                    var _a, _b;
                    const W = window;
                    const legacyTopZ =
                        (_b = (_a = W.WindowManager) == null ? void 0 : _a.getTopZIndex) == null
                            ? void 0
                            : _b.call(_a);
                    if (typeof legacyTopZ === 'number') {
                        this.nextZIndex = this.zIndexManager.ensureTopZIndex(legacyTopZ);
                    } else {
                        this.nextZIndex = this.zIndexManager.getTopZIndex();
                    }
                }
                init() {
                    if (this.initialized) return;
                    this._syncZIndexWithWindowManager();
                    document.addEventListener('mousedown', e => {
                        const target = e.target;
                        const modal = target.closest('.modal');
                        if (modal) {
                            const windowId = modal.id;
                            const window2 = this.windows.get(windowId);
                            if (window2) {
                                window2.bringToFront();
                            }
                        }
                    });
                    this.initialized = true;
                }
                /**
                 * Register a window
                 */
                registerWindow(window2) {
                    this.windows.set(window2.id, window2);
                    console.log(
                        `[WindowRegistry] Registered window: ${window2.id} (type: ${window2.type})`
                    );
                    if (!this.activeWindowId) this.activeWindowId = window2.id;
                }
                /**
                 * Remove a window
                 */
                removeWindow(windowId) {
                    const window2 = this.windows.get(windowId);
                    if (window2) {
                        window2.destroy();
                        this.windows.delete(windowId);
                        console.log(`[WindowRegistry] Removed window: ${windowId}`);
                        if (this.activeWindowId === windowId) {
                            const top = this.getTopWindow();
                            this.activeWindowId = top ? top.id : null;
                        }
                    }
                }
                /**
                 * Get a window by ID
                 */
                getWindow(windowId) {
                    return this.windows.get(windowId) || null;
                }
                /**
                 * Get all windows, optionally filtered by type
                 * @param type - Optional window type filter (e.g., 'terminal', 'finder', 'text-editor')
                 */
                getAllWindows(type) {
                    const allWindows = Array.from(this.windows.values());
                    return type ? allWindows.filter(w => w.type === type) : allWindows;
                }
                /**
                 * Get windows by type
                 * @deprecated Use getAllWindows(type) instead
                 */
                getWindowsByType(type) {
                    return this.getAllWindows(type);
                }
                /**
                 * Get next z-index for stacking
                 */
                getNextZIndex() {
                    this._syncZIndexWithWindowManager();
                    this.nextZIndex = this.zIndexManager.bumpZIndex();
                    return this.nextZIndex;
                }
                /**
                 * Get current top z-index without incrementing
                 */
                getTopZIndex() {
                    this.nextZIndex = this.zIndexManager.getTopZIndex();
                    return this.nextZIndex;
                }
                /**
                 * Update top z-index from external source (e.g., WindowManager)
                 */
                updateTopZIndex(newZIndex) {
                    this.nextZIndex = this.zIndexManager.ensureTopZIndex(newZIndex);
                }
                /**
                 * Close all windows of a specific type
                 */
                closeAllWindowsOfType(type) {
                    const windows = this.getWindowsByType(type);
                    windows.forEach(window2 => window2.close());
                }
                /**
                 * Close all windows
                 */
                closeAllWindows() {
                    const windows = Array.from(this.windows.values());
                    windows.forEach(window2 => window2.close());
                }
                /**
                 * Get top-most window
                 */
                getTopWindow() {
                    const topId = this.zIndexManager.getTopWindowId();
                    if (topId) {
                        const win = this.windows.get(topId);
                        if (win) return win;
                    }
                    const windows = Array.from(this.windows.values());
                    if (windows.length === 0) return null;
                    return windows.reduce((top, current) => {
                        return current.zIndex > top.zIndex ? current : top;
                    });
                }
                /**
                 * Mark a window as actively focused. Consumers (menus) can use this
                 * to react to focus changes and render the correct application menu.
                 */
                setActiveWindow(windowId) {
                    this.activeWindowId = windowId;
                }
                /**
                 * Retrieve the currently active window, if known.
                 */
                getActiveWindow() {
                    if (!this.activeWindowId) return null;
                    return this.windows.get(this.activeWindowId) || null;
                }
                /**
                 * Serialize all windows for session management
                 */
                serializeAll() {
                    return Array.from(this.windows.values()).map(w => w.serialize());
                }
                /**
                 * Restore windows from session
                 */
                restoreFromSession(states) {
                    states.forEach(state => {
                        console.log(
                            `[WindowRegistry] Restore window ${state.id} (type: ${state.type})`
                        );
                    });
                }
                /**
                 * Get count of windows by type
                 */
                getWindowCount(type) {
                    if (type) {
                        return this.getWindowsByType(type).length;
                    }
                    return this.windows.size;
                }
                /**
                 * Check if any windows are open
                 */
                hasOpenWindows() {
                    return this.windows.size > 0;
                }
                /**
                 * Find window containing a specific tab
                 */
                findWindowByTabId(tabId) {
                    for (const window2 of this.windows.values()) {
                        if (window2.tabs.has(tabId)) {
                            return window2;
                        }
                    }
                    return null;
                }
                /**
                 * Debug: Log all windows
                 */
                debugLogWindows() {
                    console.log('[WindowRegistry] Open windows:', {
                        total: this.windows.size,
                        windows: Array.from(this.windows.values()).map(w => ({
                            id: w.id,
                            type: w.type,
                            tabs: w.tabs.size,
                            zIndex: w.zIndex,
                            minimized: w.isMinimized,
                            maximized: w.isMaximized,
                        })),
                    });
                }
            };
            registry = new WindowRegistry();
            window.WindowRegistry = registry;
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => registry.init());
            } else {
                registry.init();
            }
            window_registry_default = registry;
        },
    });

    // src/ts/services/virtual-fs.ts
    var VirtualFileSystemManager, VirtualFS;
    var init_virtual_fs = __esm({
        'src/ts/services/virtual-fs.ts'() {
            'use strict';
            init_storage_utils();
            VirtualFileSystemManager = class {
                constructor() {
                    this.listeners = [];
                    this.STORAGE_KEY = 'virtual-file-system';
                    this.AUTO_SAVE_DELAY = 1e3;
                    // 1 second debounce
                    this.saveTimeout = null;
                    this.root = this.createDefaultStructure();
                    this.load();
                }
                getRootContainer() {
                    return this.root['/'].children;
                }
                // ========================================================================
                // Initialization
                // ========================================================================
                createDefaultStructure() {
                    const now = /* @__PURE__ */ new Date().toISOString();
                    return {
                        '/': {
                            type: 'folder',
                            icon: '/',
                            created: now,
                            modified: now,
                            children: {
                                home: {
                                    type: 'folder',
                                    icon: '\u{1F3E0}',
                                    created: now,
                                    modified: now,
                                    children: {
                                        marvin: {
                                            type: 'folder',
                                            icon: '\u{1F464}',
                                            created: now,
                                            modified: now,
                                            children: {
                                                '.profile': {
                                                    type: 'file',
                                                    icon: '\u2699\uFE0F',
                                                    content:
                                                        '# ~/.profile\n# User profile configuration\n\nexport PATH=$HOME/bin:/usr/local/bin:/usr/bin:/bin\nexport EDITOR=vim\n',
                                                    size: 112,
                                                    created: now,
                                                    modified: now,
                                                },
                                                'README.md': {
                                                    type: 'file',
                                                    icon: '\u{1F4DD}',
                                                    content:
                                                        '# Welcome to your home directory\n\nThis is your personal space in the virtual file system.\n\n## Structure\n- Documents: Store your text files and documents\n- Downloads: Temporary download location\n- Pictures: Image files\n- Projects: Your code projects\n',
                                                    size: 248,
                                                    created: now,
                                                    modified: now,
                                                },
                                                Documents: {
                                                    type: 'folder',
                                                    icon: '\u{1F4C4}',
                                                    created: now,
                                                    modified: now,
                                                    children: {
                                                        'notes.txt': {
                                                            type: 'file',
                                                            icon: '\u{1F4DD}',
                                                            content: 'Personal notes...',
                                                            size: 17,
                                                            created: now,
                                                            modified: now,
                                                        },
                                                    },
                                                },
                                                Downloads: {
                                                    type: 'folder',
                                                    icon: '\u2B07\uFE0F',
                                                    created: now,
                                                    modified: now,
                                                    children: {},
                                                },
                                                Pictures: {
                                                    type: 'folder',
                                                    icon: '\u{1F5BC}\uFE0F',
                                                    created: now,
                                                    modified: now,
                                                    children: {},
                                                },
                                                Projects: {
                                                    type: 'folder',
                                                    icon: '\u{1F4BC}',
                                                    created: now,
                                                    modified: now,
                                                    children: {},
                                                },
                                            },
                                        },
                                    },
                                },
                                etc: {
                                    type: 'folder',
                                    icon: '\u2699\uFE0F',
                                    created: now,
                                    modified: now,
                                    children: {
                                        hosts: {
                                            type: 'file',
                                            icon: '\u{1F310}',
                                            content:
                                                '# /etc/hosts\n127.0.0.1   localhost\n::1         localhost\n',
                                            size: 57,
                                            created: now,
                                            modified: now,
                                        },
                                    },
                                },
                                usr: {
                                    type: 'folder',
                                    icon: '\u{1F4E6}',
                                    created: now,
                                    modified: now,
                                    children: {
                                        bin: {
                                            type: 'folder',
                                            icon: '\u26A1',
                                            created: now,
                                            modified: now,
                                            children: {},
                                        },
                                        share: {
                                            type: 'folder',
                                            icon: '\u{1F4DA}',
                                            created: now,
                                            modified: now,
                                            children: {
                                                doc: {
                                                    type: 'folder',
                                                    icon: '\u{1F4D6}',
                                                    created: now,
                                                    modified: now,
                                                    children: {
                                                        README: {
                                                            type: 'file',
                                                            icon: '\u{1F4DD}',
                                                            content:
                                                                'Virtual File System Documentation\n\nThis is a UNIX-like filesystem hierarchy.\n\nStandard directories:\n- /home: User home directories\n- /etc: System configuration\n- /usr: User programs and data\n- /var: Variable data (logs, temp)\n- /tmp: Temporary files\n',
                                                            size: 252,
                                                            created: now,
                                                            modified: now,
                                                        },
                                                    },
                                                },
                                            },
                                        },
                                    },
                                },
                                var: {
                                    type: 'folder',
                                    icon: '\u{1F4CA}',
                                    created: now,
                                    modified: now,
                                    children: {
                                        log: {
                                            type: 'folder',
                                            icon: '\u{1F4DC}',
                                            created: now,
                                            modified: now,
                                            children: {},
                                        },
                                        tmp: {
                                            type: 'folder',
                                            icon: '\u{1F5C2}\uFE0F',
                                            created: now,
                                            modified: now,
                                            children: {},
                                        },
                                    },
                                },
                                tmp: {
                                    type: 'folder',
                                    icon: '\u{1F5D1}\uFE0F',
                                    created: now,
                                    modified: now,
                                    children: {},
                                },
                            },
                        },
                    };
                }
                // ========================================================================
                // Persistence
                // ========================================================================
                load() {
                    try {
                        const stored = getJSON(this.STORAGE_KEY, null);
                        if (stored && Object.keys(stored).length > 0) {
                            this.root = stored;
                            console.log('[VirtualFS] Loaded from localStorage');
                        } else {
                            this.root = this.createDefaultStructure();
                            console.log('[VirtualFS] No stored data, initialized with defaults');
                        }
                    } catch (error) {
                        console.error('[VirtualFS] Failed to load:', error);
                        this.root = this.createDefaultStructure();
                    }
                }
                scheduleSave() {
                    if (this.saveTimeout !== null) {
                        window.clearTimeout(this.saveTimeout);
                    }
                    this.saveTimeout = window.setTimeout(() => {
                        this.save();
                        this.saveTimeout = null;
                    }, this.AUTO_SAVE_DELAY);
                }
                save() {
                    try {
                        setJSON(this.STORAGE_KEY, this.root);
                        console.log('[VirtualFS] Saved to localStorage');
                    } catch (error) {
                        console.error('[VirtualFS] Failed to save:', error);
                    }
                }
                forceSave() {
                    if (this.saveTimeout !== null) {
                        window.clearTimeout(this.saveTimeout);
                        this.saveTimeout = null;
                    }
                    this.save();
                }
                // ========================================================================
                // Event System
                // ========================================================================
                addEventListener(listener) {
                    this.listeners.push(listener);
                }
                removeEventListener(listener) {
                    const index = this.listeners.indexOf(listener);
                    if (index !== -1) {
                        this.listeners.splice(index, 1);
                    }
                }
                emit(event) {
                    this.listeners.forEach(listener => {
                        try {
                            listener(event);
                        } catch (error) {
                            console.error('[VirtualFS] Listener error:', error);
                        }
                    });
                }
                // ========================================================================
                // Path Utilities
                // ========================================================================
                parsePath(path) {
                    if (Array.isArray(path)) {
                        return path;
                    }
                    return path.split('/').filter(p => p.length > 0);
                }
                normalizePath(path) {
                    return this.parsePath(path).join('/');
                }
                navigate(path) {
                    const parts = this.parsePath(path);
                    if (parts.length === 0) {
                        return null;
                    }
                    const rootFolder = this.root['/'];
                    if (!rootFolder || rootFolder.type !== 'folder') {
                        return null;
                    }
                    let current = rootFolder.children;
                    let lastItem = null;
                    for (const part of parts) {
                        const item = current[part];
                        if (!item) {
                            return null;
                        }
                        lastItem = item;
                        if (item.type === 'folder') {
                            current = item.children;
                        } else {
                            return item;
                        }
                    }
                    return lastItem;
                }
                // ========================================================================
                // Read Operations
                // ========================================================================
                exists(path) {
                    return this.navigate(path) !== null;
                }
                get(path) {
                    return this.navigate(path);
                }
                getFolder(path) {
                    const item = this.navigate(path);
                    return (item == null ? void 0 : item.type) === 'folder' ? item : null;
                }
                getFile(path) {
                    const item = this.navigate(path);
                    return (item == null ? void 0 : item.type) === 'file' ? item : null;
                }
                list(path = []) {
                    const parts = this.parsePath(path);
                    if (parts.length === 0) {
                        const rootFolder = this.root['/'];
                        return (rootFolder == null ? void 0 : rootFolder.children) || {};
                    }
                    const folder = this.getFolder(path);
                    return (folder == null ? void 0 : folder.children) || {};
                }
                readFile(path) {
                    const file = this.getFile(path);
                    return (file == null ? void 0 : file.content) || null;
                }
                // ========================================================================
                // Write Operations
                // ========================================================================
                createFile(path, content = '', icon = '\u{1F4DD}') {
                    const parts = this.parsePath(path);
                    if (parts.length === 0) {
                        return false;
                    }
                    const fileName = parts[parts.length - 1];
                    const parentPath = parts.slice(0, -1);
                    const parent = parentPath.length > 0 ? this.getFolder(parentPath) : null;
                    const container =
                        (parent == null ? void 0 : parent.children) || this.getRootContainer();
                    if (container[fileName]) {
                        console.warn('[VirtualFS] File already exists:', this.normalizePath(path));
                        return false;
                    }
                    const now = /* @__PURE__ */ new Date().toISOString();
                    const file = {
                        type: 'file',
                        icon,
                        content,
                        size: content.length,
                        created: now,
                        modified: now,
                    };
                    container[fileName] = file;
                    if (parent) {
                        parent.modified = now;
                    }
                    this.scheduleSave();
                    this.emit({ type: 'create', path: this.normalizePath(path), item: file });
                    return true;
                }
                createFolder(path, icon = '\u{1F4C1}') {
                    const parts = this.parsePath(path);
                    if (parts.length === 0) {
                        return false;
                    }
                    const folderName = parts[parts.length - 1];
                    const parentPath = parts.slice(0, -1);
                    const parent = parentPath.length > 0 ? this.getFolder(parentPath) : null;
                    const container =
                        (parent == null ? void 0 : parent.children) || this.getRootContainer();
                    if (container[folderName]) {
                        console.warn(
                            '[VirtualFS] Folder already exists:',
                            this.normalizePath(path)
                        );
                        return false;
                    }
                    const now = /* @__PURE__ */ new Date().toISOString();
                    const folder = {
                        type: 'folder',
                        icon,
                        children: {},
                        created: now,
                        modified: now,
                    };
                    container[folderName] = folder;
                    if (parent) {
                        parent.modified = now;
                    }
                    this.scheduleSave();
                    this.emit({ type: 'create', path: this.normalizePath(path), item: folder });
                    return true;
                }
                writeFile(path, content) {
                    const file = this.getFile(path);
                    if (!file) {
                        console.warn('[VirtualFS] File not found:', this.normalizePath(path));
                        return false;
                    }
                    file.content = content;
                    file.size = content.length;
                    file.modified = /* @__PURE__ */ new Date().toISOString();
                    this.scheduleSave();
                    this.emit({ type: 'update', path: this.normalizePath(path), item: file });
                    return true;
                }
                delete(path) {
                    const parts = this.parsePath(path);
                    if (parts.length === 0) {
                        return false;
                    }
                    const itemName = parts[parts.length - 1];
                    const parentPath = parts.slice(0, -1);
                    const parent = parentPath.length > 0 ? this.getFolder(parentPath) : null;
                    const container =
                        (parent == null ? void 0 : parent.children) || this.getRootContainer();
                    if (!container[itemName]) {
                        console.warn('[VirtualFS] Item not found:', this.normalizePath(path));
                        return false;
                    }
                    const item = container[itemName];
                    delete container[itemName];
                    if (parent) {
                        parent.modified = /* @__PURE__ */ new Date().toISOString();
                    }
                    this.scheduleSave();
                    this.emit({ type: 'delete', path: this.normalizePath(path), item });
                    return true;
                }
                rename(oldPath, newName) {
                    const parts = this.parsePath(oldPath);
                    if (parts.length === 0) {
                        return false;
                    }
                    const oldName = parts[parts.length - 1];
                    const parentPath = parts.slice(0, -1);
                    const parent = parentPath.length > 0 ? this.getFolder(parentPath) : null;
                    const container =
                        (parent == null ? void 0 : parent.children) || this.getRootContainer();
                    if (!container[oldName]) {
                        console.warn('[VirtualFS] Item not found:', this.normalizePath(oldPath));
                        return false;
                    }
                    if (container[newName]) {
                        console.warn('[VirtualFS] Target name already exists:', newName);
                        return false;
                    }
                    const item = container[oldName];
                    container[newName] = item;
                    delete container[oldName];
                    if (parent) {
                        parent.modified = /* @__PURE__ */ new Date().toISOString();
                    }
                    item.modified = /* @__PURE__ */ new Date().toISOString();
                    const newPath = [...parentPath, newName].join('/');
                    this.scheduleSave();
                    this.emit({
                        type: 'rename',
                        path: newPath,
                        oldPath: this.normalizePath(oldPath),
                        item,
                    });
                    return true;
                }
                // ========================================================================
                // Stats & Utilities
                // ========================================================================
                getStats() {
                    let totalFiles = 0;
                    let totalFolders = 0;
                    let totalSize = 0;
                    const traverse = items => {
                        for (const item of Object.values(items)) {
                            if (item.type === 'file') {
                                totalFiles++;
                                totalSize += item.size;
                            } else if (item.type === 'folder') {
                                totalFolders++;
                                traverse(item.children);
                            }
                        }
                    };
                    traverse(this.root['/'].children);
                    return { totalFiles, totalFolders, totalSize };
                }
                reset() {
                    this.root = this.createDefaultStructure();
                    this.save();
                    console.log('[VirtualFS] Reset to defaults');
                }
                export() {
                    return JSON.parse(JSON.stringify(this.root));
                }
                import(data) {
                    try {
                        if (!data || typeof data !== 'object') {
                            return false;
                        }
                        this.root = data;
                        this.save();
                        console.log('[VirtualFS] Imported successfully');
                        return true;
                    } catch (error) {
                        console.error('[VirtualFS] Import failed:', error);
                        return false;
                    }
                }
            };
            VirtualFS = new VirtualFileSystemManager();
            if (typeof window !== 'undefined') {
                window.VirtualFS = VirtualFS;
            }
        },
    });

    // src/ts/apps/terminal/terminal-session.ts
    var TerminalSession;
    var init_terminal_session = __esm({
        'src/ts/apps/terminal/terminal-session.ts'() {
            'use strict';
            init_base_tab();
            init_virtual_fs();
            TerminalSession = class _TerminalSession extends BaseTab {
                constructor(config) {
                    super({
                        type: 'terminal-session',
                        title: (config == null ? void 0 : config.title) || 'Terminal',
                        ...config,
                    });
                    this.outputElement = null;
                    this.inputElement = null;
                    this.commandHistory = [];
                    this.historyIndex = -1;
                    this.vfsCwd = '/home/marvin';
                    try {
                        const home = VirtualFS.getFolder('/home/marvin');
                        if (!home || !home.children) {
                            console.warn('[TerminalSession] VirtualFS missing defaults, resetting');
                            VirtualFS.reset();
                        }
                    } catch (error) {
                        console.warn('[TerminalSession] VirtualFS check failed, resetting', error);
                        VirtualFS.reset();
                    }
                }
                /**
                 * Create terminal DOM
                 */
                createDOM() {
                    const container = document.createElement('div');
                    container.id = `${this.id}-container`;
                    container.className = 'tab-content hidden w-full h-full';
                    const html = `
            <div class="terminal-wrapper h-full flex flex-col bg-gray-900 text-green-400 font-mono text-sm">
                <div class="terminal-output flex-1 overflow-y-auto p-4 space-y-1" data-terminal-output>
                </div>
                <div class="terminal-input-line flex items-center px-4 py-2 border-t border-gray-700">
                    <span class="terminal-prompt text-blue-400">guest@marvin:${this.vfsCwd}$</span>
                    <input
                        type="text"
                        class="flex-1 ml-2 bg-transparent outline-none text-green-400 terminal-input"
                        autocomplete="off"
                        spellcheck="false"
                        aria-label="Terminal input"
                        data-terminal-input
                    />
                </div>
            </div>
        `;
                    container.innerHTML = html;
                    this.element = container;
                    this.outputElement = container.querySelector('[data-terminal-output]');
                    this.inputElement = container.querySelector('[data-terminal-input]');
                    this._attachEventListeners();
                    this.showWelcomeMessage();
                    return container;
                }
                _attachEventListeners() {
                    if (!this.inputElement) return;
                    this.inputElement.addEventListener('keydown', e => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            const command = this.inputElement.value.trim();
                            if (command) {
                                this.executeCommand(command);
                            }
                            this.inputElement.value = '';
                            this.inputElement.focus();
                        } else if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            if (this.historyIndex > 0) {
                                this.historyIndex--;
                                const historyEntry = this.commandHistory[this.historyIndex];
                                if (historyEntry !== void 0) {
                                    this.inputElement.value = historyEntry;
                                }
                            }
                        } else if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            if (this.historyIndex < this.commandHistory.length - 1) {
                                this.historyIndex++;
                                const historyEntry = this.commandHistory[this.historyIndex];
                                if (historyEntry !== void 0) {
                                    this.inputElement.value = historyEntry;
                                }
                            } else {
                                this.historyIndex = this.commandHistory.length;
                                this.inputElement.value = '';
                            }
                        } else if (e.key === 'Tab') {
                            e.preventDefault();
                            this.handleTabCompletion();
                        }
                    });
                }
                /**
                 * Basic tab completion for commands and VirtualFS paths.
                 *
                 * This is primarily used by Playwright E2E tests (tests/e2e/terminal/terminal-autocomplete.spec.js)
                 * and intentionally stays simple:
                 * - Completes first token as command
                 * - Completes first argument for cd/cat/mkdir/rm
                 */
                handleTabCompletion() {
                    var _a, _b;
                    if (!this.inputElement) return;
                    const input = this.inputElement.value;
                    if (input === '') return;
                    const endsWithSpace = input.endsWith(' ');
                    const tokens = input.split(' ').filter((t2, i, arr) => {
                        if (t2 !== '') return true;
                        return i === arr.length - 1;
                    });
                    const cmd = (_a = tokens[0]) != null ? _a : '';
                    const arg1 = (_b = tokens[1]) != null ? _b : '';
                    const availableCommands = [
                        'help',
                        'clear',
                        'ls',
                        'pwd',
                        'cd',
                        'cat',
                        'touch',
                        'mkdir',
                        'rm',
                        'echo',
                        'date',
                        'whoami',
                    ];
                    try {
                        console.debug('[TerminalSession] Tab on input', {
                            input,
                            cwd: this.vfsCwd,
                        });
                    } catch {}
                    if (tokens.length <= 1 && !endsWithSpace) {
                        const matches = availableCommands.filter(c => c.startsWith(cmd));
                        try {
                            console.debug('[TerminalSession] Command matches', { cmd, matches });
                        } catch {}
                        if (matches.length === 1) {
                            const match = matches[0];
                            if (match !== void 0) this.inputElement.value = match + ' ';
                            return;
                        }
                        if (availableCommands.includes(cmd)) {
                            this.inputElement.value = cmd + ' ';
                        }
                        return;
                    }
                    if (tokens.length === 1 && endsWithSpace && availableCommands.includes(cmd)) {
                        this.inputElement.value = cmd + ' ';
                        return;
                    }
                    const completeForCmd =
                        cmd === 'cd' || cmd === 'cat' || cmd === 'mkdir' || cmd === 'rm';
                    if (!completeForCmd) return;
                    if (arg1 === '') return;
                    if (cmd === 'mkdir' && arg1.endsWith('/')) return;
                    const allowFolders = cmd === 'cd' || cmd === 'mkdir';
                    const allowFiles = cmd === 'cat' || cmd === 'rm';
                    const allowBoth = cmd === 'rm';
                    this.completePathArgument(cmd, arg1, {
                        allowFolders: allowBoth ? true : allowFolders,
                        allowFiles: allowBoth ? true : allowFiles,
                    });
                }
                findCommonPrefix(strings) {
                    var _a;
                    if (strings.length === 0) return '';
                    const first = (_a = strings[0]) != null ? _a : '';
                    if (strings.length === 1) return first;
                    let prefix = first;
                    for (let i = 1; i < strings.length; i++) {
                        const cur = strings[i];
                        if (cur === void 0) continue;
                        while (cur.indexOf(prefix) !== 0) {
                            prefix = prefix.slice(0, -1);
                            if (prefix === '') return '';
                        }
                    }
                    return prefix;
                }
                completePathArgument(cmd, rawArg, opts) {
                    if (!this.inputElement) return;
                    const lastSlashIdx = rawArg.lastIndexOf('/');
                    const dirPrefix = lastSlashIdx >= 0 ? rawArg.slice(0, lastSlashIdx + 1) : '';
                    const basePrefix = lastSlashIdx >= 0 ? rawArg.slice(lastSlashIdx + 1) : rawArg;
                    if (basePrefix === '' && rawArg.endsWith('/')) return;
                    let dirForResolve;
                    if (dirPrefix === '') {
                        dirForResolve = this.vfsCwd;
                    } else {
                        const rawDir = dirPrefix.endsWith('/') ? dirPrefix.slice(0, -1) : dirPrefix;
                        dirForResolve = this.vfsResolve(rawDir);
                    }
                    const folder = VirtualFS.getFolder(dirForResolve);
                    try {
                        console.debug('[TerminalSession] Dir resolve', {
                            rawArg,
                            dirPrefix,
                            basePrefix,
                            dirForResolve,
                            folderFound: !!folder,
                        });
                    } catch {}
                    if (!folder) return;
                    const entries = Object.entries(folder.children);
                    const matches = entries
                        .filter(([name, item]) => {
                            if (!name.startsWith(basePrefix)) return false;
                            if (item.type === 'folder') return opts.allowFolders;
                            return opts.allowFiles;
                        })
                        .map(([name, item]) => ({ name, item }));
                    try {
                        console.debug('[TerminalSession] Path matches', {
                            cmd,
                            basePrefix,
                            count: matches.length,
                            names: matches.map(m => m.name),
                        });
                    } catch {}
                    if (matches.length === 0) return;
                    const names = matches.map(m => m.name);
                    if (matches.length === 1) {
                        const m = matches[0];
                        let completed = m.name;
                        if (cmd === 'cd' && m.item.type === 'folder' && !completed.endsWith('/')) {
                            completed += '/';
                        }
                        this.inputElement.value = `${cmd} ${dirPrefix}${completed}`;
                        return;
                    }
                    const common = this.findCommonPrefix(names);
                    if (common.length > basePrefix.length) {
                        this.inputElement.value = `${cmd} ${dirPrefix}${common}`;
                    } else {
                        try {
                            const formatted = matches.map(
                                m =>
                                    (m.item.type === 'folder' ? '\u{1F4C1} ' : '\u{1F4C4} ') +
                                    m.name
                            );
                            this.addOutput(
                                `guest@marvin:${this.vfsCwd}$ ${this.inputElement.value}`,
                                'command'
                            );
                            this.addOutput(formatted.join('  '), 'info');
                        } catch {}
                    }
                }
                showWelcomeMessage() {
                    this.addOutput(
                        'Willkommen im Terminal! Gib "help" ein f\xFCr verf\xFCgbare Befehle.',
                        'info'
                    );
                }
                executeCommand(command) {
                    this.addOutput(`guest@marvin:${this.vfsCwd}$ ${command}`, 'command');
                    const [cmd, ...args] = command.split(' ');
                    if (cmd === void 0) return;
                    const commands = {
                        help: () => this.showHelp(),
                        clear: () => this.clearOutput(),
                        ls: () => this.listDirectory(args[0]),
                        pwd: () => this.printWorkingDirectory(),
                        cd: () => this.changeDirectory(args[0]),
                        cat: () => this.catFile(args[0]),
                        touch: () => this.touch(args[0]),
                        mkdir: () => this.mkdir(args[0]),
                        rm: () => this.rm(args[0]),
                        echo: () => this.echo(args.join(' ')),
                        date: () => this.showDate(),
                        whoami: () => this.addOutput('guest', 'output'),
                    };
                    const commandFn = commands[cmd];
                    if (commandFn !== void 0) {
                        commandFn();
                    } else {
                        this.addOutput(
                            `Befehl nicht gefunden: ${cmd}. Gib "help" ein f\xFCr verf\xFCgbare Befehle.`,
                            'error'
                        );
                    }
                    this.commandHistory.push(command);
                    this.historyIndex = this.commandHistory.length;
                    this.updateContentState({ commandHistory: this.commandHistory });
                }
                addOutput(text, type = 'output') {
                    if (!this.outputElement) return;
                    const line = document.createElement('div');
                    line.className = `terminal-line terminal-${type}`;
                    const colorMap = {
                        command: 'text-blue-400',
                        output: 'text-green-400',
                        error: 'text-red-400',
                        info: 'text-yellow-400',
                    };
                    line.className += ` ${colorMap[type] || 'text-green-400'}`;
                    line.textContent = text;
                    this.outputElement.appendChild(line);
                    this.outputElement.scrollTop = this.outputElement.scrollHeight;
                }
                clearOutput() {
                    if (this.outputElement) this.outputElement.innerHTML = '';
                }
                showHelp() {
                    const helpText = [
                        'Verf\xFCgbare Befehle:',
                        '  help     - Zeige diese Hilfe',
                        '  clear    - L\xF6sche Ausgabe',
                        '  ls       - Liste Dateien',
                        '  pwd      - Zeige aktuelles Verzeichnis',
                        '  cd <dir> - Wechsle Verzeichnis',
                        '  cat <f>  - Zeige Dateiinhalt',
                        '  touch <f> - Erstelle leere Datei',
                        '  mkdir <d> - Erstelle Verzeichnis',
                        '  rm <p>    - L\xF6sche Datei/Verzeichnis',
                        '  echo <t> - Gebe Text aus',
                        '  date     - Zeige Datum/Zeit',
                        '  whoami   - Zeige Benutzername',
                    ];
                    helpText.forEach(l => this.addOutput(l, 'info'));
                }
                listDirectory(path) {
                    const target = this.vfsResolve(path);
                    const item = VirtualFS.get(target);
                    if (!item) {
                        this.addOutput(
                            `Verzeichnis/Datei nicht gefunden: ${path || target}`,
                            'error'
                        );
                        return;
                    }
                    if (item.type === 'file') {
                        this.addOutput('\u{1F4C4} ' + target.split('/').pop(), 'output');
                        return;
                    }
                    const entries = VirtualFS.list(target);
                    const names = Object.keys(entries);
                    if (names.length === 0) {
                        this.addOutput('(leer)', 'output');
                        return;
                    }
                    names.forEach(name => {
                        const child = entries[name];
                        if (child) {
                            const prefix = child.type === 'folder' ? '\u{1F4C1} ' : '\u{1F4C4} ';
                            this.addOutput(prefix + name, 'output');
                        }
                    });
                }
                printWorkingDirectory() {
                    this.addOutput(this.vfsCwd, 'output');
                }
                changeDirectory(path) {
                    const target = this.vfsResolve(path || '/home/marvin');
                    const folder = VirtualFS.getFolder(target);
                    if (!folder) {
                        this.addOutput(`Verzeichnis nicht gefunden: ${path || target}`, 'error');
                        return;
                    }
                    this.vfsCwd = target;
                    this.updatePrompt();
                    this.updateContentState({ currentPath: this.vfsCwd });
                }
                catFile(filename) {
                    if (!filename) {
                        this.addOutput('Dateiname fehlt', 'error');
                        return;
                    }
                    const target = this.vfsResolve(filename);
                    const file = VirtualFS.getFile(target);
                    if (!file) this.addOutput(`Datei nicht gefunden: ${filename}`, 'error');
                    else this.addOutput(file.content, 'output');
                }
                echo(text) {
                    this.addOutput(text, 'output');
                }
                showDate() {
                    this.addOutput(/* @__PURE__ */ new Date().toString(), 'output');
                }
                updatePrompt() {
                    var _a;
                    const prompt =
                        (_a = this.element) == null ? void 0 : _a.querySelector('.terminal-prompt');
                    if (prompt) {
                        prompt.textContent = `guest@marvin:${this.vfsCwd}$`;
                    }
                }
                // ---------------------------
                // VirtualFS helpers & cmds
                // ---------------------------
                vfsResolve(path) {
                    if (!path || path.trim() === '' || path === '.') return this.vfsCwd;
                    let raw = path.trim();
                    if (raw === '~') return '/home/marvin';
                    if (raw.startsWith('~/')) raw = '/home/marvin/' + raw.slice(2);
                    if (raw.startsWith('/')) {
                        const parts2 = raw.split('/').filter(Boolean);
                        const resolved2 = [];
                        for (const p of parts2) {
                            if (p === '.') continue;
                            if (p === '..') {
                                if (resolved2.length > 0) resolved2.pop();
                            } else {
                                resolved2.push(p);
                            }
                        }
                        return '/' + resolved2.join('/');
                    }
                    const base = this.vfsCwd.split('/').filter(Boolean);
                    const parts = raw.split('/').filter(Boolean);
                    const combined = [...base, ...parts];
                    const resolved = [];
                    for (const p of combined) {
                        if (p === '.') continue;
                        if (p === '..') {
                            if (resolved.length > 0) resolved.pop();
                        } else {
                            resolved.push(p);
                        }
                    }
                    return '/' + resolved.join('/');
                }
                touch(path) {
                    if (!path) {
                        this.addOutput('Pfad/Dateiname fehlt', 'error');
                        return;
                    }
                    const target = this.vfsResolve(path);
                    const existing = VirtualFS.get(target);
                    if (existing) {
                        if (existing.type === 'file') {
                            this.addOutput(`Datei existiert bereits: ${target}`, 'error');
                        } else {
                            this.addOutput(`Pfad ist ein Verzeichnis: ${target}`, 'error');
                        }
                        return;
                    }
                    const parts = target.split('/');
                    const name = parts.pop();
                    const parentPath = parts.join('/');
                    const parent = VirtualFS.getFolder(parentPath);
                    if (!parent) {
                        this.addOutput(
                            `\xDCbergeordnetes Verzeichnis nicht gefunden: ${parentPath}`,
                            'error'
                        );
                        return;
                    }
                    const ok = VirtualFS.createFile([...parts, name].join('/'), '');
                    if (!ok) this.addOutput(`Konnte Datei nicht erstellen: ${target}`, 'error');
                }
                mkdir(path) {
                    if (!path) {
                        this.addOutput('Verzeichnisname fehlt', 'error');
                        return;
                    }
                    const target = this.vfsResolve(path);
                    const parts = target.split('/');
                    const name = parts.pop();
                    const parentPath = parts.join('/');
                    const parent = VirtualFS.getFolder(parentPath);
                    if (!parent) {
                        this.addOutput(
                            `\xDCbergeordnetes Verzeichnis nicht gefunden: ${parentPath}`,
                            'error'
                        );
                        return;
                    }
                    const ok = VirtualFS.createFolder([...parts, name].join('/'));
                    if (!ok)
                        this.addOutput(`Konnte Verzeichnis nicht erstellen: ${target}`, 'error');
                }
                rm(path) {
                    if (!path) {
                        this.addOutput('Pfad fehlt', 'error');
                        return;
                    }
                    const target = this.vfsResolve(path);
                    if (!VirtualFS.get(target)) {
                        this.addOutput(`Nicht gefunden: ${target}`, 'error');
                        return;
                    }
                    const ok = VirtualFS.delete(target);
                    if (!ok) this.addOutput(`Konnte nicht l\xF6schen: ${target}`, 'error');
                }
                /**
                 * Get parent path of a given path
                 */
                parentPath(path) {
                    const parts = path.split('/').filter(Boolean);
                    parts.pop();
                    return parts.length > 0 ? '/' + parts.join('/') : '/';
                }
                /**
                 * Serialize session state
                 */
                serialize() {
                    return {
                        ...super.serialize(),
                        currentPath: this.vfsCwd,
                        commandHistory: this.commandHistory,
                        vfsCwd: this.vfsCwd,
                    };
                }
                /**
                 * Restore session from state
                 */
                static deserialize(state) {
                    const session = new _TerminalSession({
                        id: state.id,
                        title: state.title,
                    });
                    if (state.vfsCwd) {
                        session.vfsCwd = state.vfsCwd;
                    } else if (state.currentPath) {
                        session.vfsCwd = state.currentPath;
                    }
                    if (state.commandHistory) {
                        session.commandHistory = state.commandHistory;
                        session.historyIndex = session.commandHistory.length;
                    }
                    return session;
                }
                /**
                 * Focus terminal input when tab is shown
                 */
                onShow() {
                    if (this.inputElement && typeof this.inputElement.focus === 'function') {
                        this.inputElement.focus();
                    }
                }
            };
            window.TerminalSession = TerminalSession;
        },
    });

    // src/ts/apps/terminal/terminal-window.ts
    var TerminalWindow;
    var init_terminal_window = __esm({
        'src/ts/apps/terminal/terminal-window.ts'() {
            'use strict';
            init_base_window();
            TerminalWindow = class _TerminalWindow extends BaseWindow {
                constructor(config) {
                    super({
                        type: 'terminal',
                        title: 'Terminal',
                        ...config,
                    });
                }
                /**
                 * Accessor for tests: alias tabs as sessions for Terminal nomenclature
                 */
                get sessions() {
                    return Array.from(this.tabs.values());
                }
                /**
                 * Get the currently active session (active tab)
                 * This getter provides test compatibility for accessing the active terminal session
                 */
                get activeSession() {
                    if (!this.activeTabId) return null;
                    return this.tabs.get(this.activeTabId) || null;
                }
                /**
                 * Create terminal-specific window DOM
                 */
                createDOM() {
                    const modal = super.createDOM();
                    return modal;
                }
                /**
                 * Override tab rendering to use WindowTabs system
                 */
                _renderTabs() {
                    const W = window;
                    if (!W.WindowTabs || !this.element) return;
                    const tabBar = this.element.querySelector(`#${this.id}-tabs`);
                    if (!tabBar) return;
                    const makeInst = tab => ({
                        instanceId: tab.id,
                        title: tab.title,
                        metadata: { tabLabel: tab.title },
                        __tab: tab,
                        show: () => tab.show(),
                        hide: () => tab.hide(),
                    });
                    const adapter = {
                        getAllInstances: () => Array.from(this.tabs.values()).map(makeInst),
                        getActiveInstance: () => {
                            const activeId = this.activeTabId;
                            const t2 = activeId ? this.tabs.get(activeId) : null;
                            return t2 ? makeInst(t2) : null;
                        },
                        getAllInstanceIds: () => Array.from(this.tabs.keys()),
                        getInstance: id => {
                            const t2 = this.tabs.get(id) || null;
                            return t2 ? makeInst(t2) : null;
                        },
                        setActiveInstance: id => this.setActiveTab(id),
                        createInstance: cfg => {
                            const W2 = window;
                            const session = W2.TerminalSession
                                ? new W2.TerminalSession({
                                      title:
                                          (cfg == null ? void 0 : cfg.title) ||
                                          `Terminal ${this.tabs.size + 1}`,
                                  })
                                : null;
                            if (session) {
                                this.addTab(session);
                                return makeInst(session);
                            }
                            return null;
                        },
                        destroyInstance: id => this.removeTab(id),
                        getInstanceCount: () => this.tabs.size,
                        reorderInstances: newOrder => {
                            const old = this.tabs;
                            const rebuilt = /* @__PURE__ */ new Map();
                            newOrder.forEach(id => {
                                const t2 = old.get(id);
                                if (t2) rebuilt.set(id, t2);
                            });
                            old.forEach((t2, id) => {
                                if (!rebuilt.has(id)) rebuilt.set(id, t2);
                            });
                            this.tabs = rebuilt;
                            this._renderTabs();
                        },
                        detachInstance: id => {
                            const t2 = this.detachTab(id);
                            return t2 ? makeInst(t2) : null;
                        },
                        adoptInstance: inst => {
                            const tab = inst.__tab || inst;
                            this.addTab(tab);
                            this.setActiveTab(tab.id);
                            return makeInst(tab);
                        },
                    };
                    if (this.tabController) {
                        this.tabController.destroy();
                    }
                    this.tabController = W.WindowTabs.create(adapter, tabBar, {
                        addButton: true,
                        onCreateInstanceTitle: () => `Terminal ${this.tabs.size + 1}`,
                    });
                }
                /**
                 * Create a new terminal session in this window
                 */
                createSession(title) {
                    const W = window;
                    if (!W.TerminalSession) {
                        console.error('TerminalSession class not loaded');
                        return null;
                    }
                    const session = new W.TerminalSession({
                        title: title || `Terminal ${this.tabs.size + 1}`,
                    });
                    this.addTab(session);
                    return session;
                }
                /**
                 * Static factory method to create a terminal window with one session
                 */
                static create(config) {
                    const window2 = new _TerminalWindow(config);
                    window2.createSession();
                    const W = globalThis;
                    if (W.WindowRegistry) {
                        W.WindowRegistry.registerWindow(window2);
                    }
                    window2.show();
                    return window2;
                }
                /**
                 * Focus existing Terminal window or create new one (macOS-like Dock behavior)
                 * - If no Terminal window exists, create a new one
                 * - If Terminal windows exist, focus the most recently active one
                 */
                static focusOrCreate(config) {
                    const W = globalThis;
                    if (!W.WindowRegistry) {
                        return _TerminalWindow.create(config);
                    }
                    const terminalWindows = W.WindowRegistry.getWindowsByType('terminal');
                    if (terminalWindows.length === 0) {
                        return _TerminalWindow.create(config);
                    }
                    let mostRecentWindow = terminalWindows[0];
                    for (const win of terminalWindows) {
                        if (win.zIndex > mostRecentWindow.zIndex) {
                            mostRecentWindow = win;
                        }
                    }
                    if (mostRecentWindow.tabs.size === 0 && W.TerminalSession) {
                        mostRecentWindow.createSession();
                    }
                    mostRecentWindow.bringToFront();
                    return mostRecentWindow;
                }
            };
            window.TerminalWindow = TerminalWindow;
        },
    });

    // src/ts/apps/text-editor/text-editor-document.ts
    var TextEditorDocument;
    var init_text_editor_document = __esm({
        'src/ts/apps/text-editor/text-editor-document.ts'() {
            'use strict';
            init_base_tab();
            init_storage_utils();
            TextEditorDocument = class _TextEditorDocument extends BaseTab {
                constructor(config) {
                    super({
                        type: 'text-editor-document',
                        title: (config == null ? void 0 : config.title) || 'Untitled.txt',
                        ...config,
                    });
                    this.editor = null;
                    this.statusBar = null;
                    this.wordCountDisplay = null;
                    this.lineColDisplay = null;
                    this.findReplacePanel = null;
                    this.findInput = null;
                    this.replaceInput = null;
                    this.fileInput = null;
                    this.wrapMode = 'off';
                    this.filename = this.title;
                    this.isDirty = false;
                }
                /**
                 * Create document DOM
                 */
                createDOM() {
                    const container = document.createElement('div');
                    container.id = `${this.id}-container`;
                    container.className = 'tab-content hidden w-full h-full';
                    const isDark = document.documentElement.classList.contains('dark');
                    container.innerHTML = `
            <div class="text-editor-wrapper flex flex-col h-full" style="background: ${isDark ? '#0f172a' : '#fafafa'}; color: ${isDark ? '#e5e7eb' : '#111827'};">
                <!-- Toolbar -->
                <div class="text-editor-toolbar flex-none" style="background: ${isDark ? '#1f2937' : '#f5f5f5'}; padding: 8px 12px; border-bottom: 1px solid ${isDark ? '#374151' : '#d1d5db'}; display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                    <button type="button" class="btn-new" title="Neu">Neu</button>
                    <button type="button" class="btn-open" title="\xD6ffnen">\xD6ffnen</button>
                    <button type="button" class="btn-save" title="Speichern">Speichern</button>
                    <div style="width: 1px; height: 20px; background: ${isDark ? '#475569' : '#d1d5db'}; margin: 0 4px;"></div>
                    <button type="button" class="btn-bold" title="Fett" style="font-weight: bold;">B</button>
                    <button type="button" class="btn-italic" title="Kursiv" style="font-style: italic;">I</button>
                    <button type="button" class="btn-underline" title="Unterstrichen" style="text-decoration: underline;">U</button>
                    <div style="width: 1px; height: 20px; background: ${isDark ? '#475569' : '#d1d5db'}; margin: 0 4px;"></div>
                    <button type="button" class="btn-find" title="Suchen">\u{1F50D}</button>
                    <button type="button" class="btn-wrap" title="Zeilenumbruch">\u23CE</button>
                    <input type="file" class="file-input" accept=".txt,.md,.markdown" style="display:none">
                </div>

                <!-- Find/Replace Panel -->
                <div class="find-replace-panel" style="background: ${isDark ? '#1f2937' : '#f5f5f5'}; padding: 8px 12px; border-bottom: 1px solid ${isDark ? '#374151' : '#d1d5db'}; display: none; gap: 8px; align-items: center;">
                    <input type="text" class="find-input" placeholder="Suchen..." style="padding: 4px 8px; border: 1px solid ${isDark ? '#475569' : '#d1d5db'}; border-radius: 4px; background: ${isDark ? '#111827' : '#ffffff'}; color: inherit;">
                    <input type="text" class="replace-input" placeholder="Ersetzen..." style="padding: 4px 8px; border: 1px solid ${isDark ? '#475569' : '#d1d5db'}; border-radius: 4px; background: ${isDark ? '#111827' : '#ffffff'}; color: inherit;">
                    <button type="button" class="btn-find-next">Weiter</button>
                    <button type="button" class="btn-replace-one">Ersetzen</button>
                    <button type="button" class="btn-replace-all">Alle</button>
                    <button type="button" class="btn-close-find">\u2715</button>
                </div>

                <!-- Status -->
                <div class="status-bar" style="padding: 6px 12px; border-bottom: 1px solid ${isDark ? '#374151' : '#d1d5db'}; background: ${isDark ? '#1f2937' : '#f5f5f5'}; font-size: 13px; display: none;"></div>

                <!-- Editor -->
                <textarea class="text-editor-textarea flex-1 w-full resize-none p-4 border-0 outline-none"
                    spellcheck="false"
                    wrap="off"
                    style="background: ${isDark ? '#111827' : '#ffffff'}; color: inherit; font-family: 'SFMono-Regular', Menlo, Monaco, Consolas, monospace; font-size: 14px; line-height: 1.6;"
                    placeholder="Text eingeben..."></textarea>

                <!-- Status Bar -->
                <div class="editor-statusbar flex-none" style="background: ${isDark ? '#1f2937' : '#f5f5f5'}; padding: 6px 12px; border-top: 1px solid ${isDark ? '#374151' : '#d1d5db'}; font-size: 12px; display: flex; justify-content: space-between;">
                    <span class="word-count">W\xF6rter: 0 | Zeichen: 0</span>
                    <span class="line-col">Zeile 1, Spalte 1</span>
                </div>
            </div>
        `;
                    this.element = container;
                    this.editor = container.querySelector('.text-editor-textarea');
                    this.statusBar = container.querySelector('.status-bar');
                    this.wordCountDisplay = container.querySelector('.word-count');
                    this.lineColDisplay = container.querySelector('.line-col');
                    this.findReplacePanel = container.querySelector('.find-replace-panel');
                    this.findInput = container.querySelector('.find-input');
                    this.replaceInput = container.querySelector('.replace-input');
                    this.fileInput = container.querySelector('.file-input');
                    this._attachEventListeners();
                    this._applyButtonStyles();
                    this._loadWrapPreference();
                    if (this.contentState && this.contentState.content && this.editor) {
                        this.editor.value = this.contentState.content;
                        this._updateWordCount();
                        this._updateCursorPosition();
                    }
                    return container;
                }
                _attachEventListeners() {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
                    if (!this.element) return;
                    (_a = this.editor) == null
                        ? void 0
                        : _a.addEventListener('input', () => this._handleInput());
                    (_b = this.editor) == null
                        ? void 0
                        : _b.addEventListener('click', () => this._updateCursorPosition());
                    (_c = this.editor) == null
                        ? void 0
                        : _c.addEventListener('keyup', () => this._updateCursorPosition());
                    (_d = this.element.querySelector('.btn-new')) == null
                        ? void 0
                        : _d.addEventListener('click', () => this.clearContent());
                    (_e = this.element.querySelector('.btn-open')) == null
                        ? void 0
                        : _e.addEventListener('click', () => this.openFile());
                    (_f = this.element.querySelector('.btn-save')) == null
                        ? void 0
                        : _f.addEventListener('click', () => this.saveFile());
                    (_g = this.element.querySelector('.btn-bold')) == null
                        ? void 0
                        : _g.addEventListener('click', () => this._wrapSelection('**', '**'));
                    (_h = this.element.querySelector('.btn-italic')) == null
                        ? void 0
                        : _h.addEventListener('click', () => this._wrapSelection('*', '*'));
                    (_i = this.element.querySelector('.btn-underline')) == null
                        ? void 0
                        : _i.addEventListener('click', () => this._wrapSelection('<u>', '</u>'));
                    (_j = this.element.querySelector('.btn-find')) == null
                        ? void 0
                        : _j.addEventListener('click', () => this.toggleFindReplace());
                    (_k = this.element.querySelector('.btn-wrap')) == null
                        ? void 0
                        : _k.addEventListener('click', () => this.toggleWrapMode());
                    (_l = this.element.querySelector('.btn-find-next')) == null
                        ? void 0
                        : _l.addEventListener('click', () => this.findNext());
                    (_m = this.element.querySelector('.btn-replace-one')) == null
                        ? void 0
                        : _m.addEventListener('click', () => this.replaceOne());
                    (_n = this.element.querySelector('.btn-replace-all')) == null
                        ? void 0
                        : _n.addEventListener('click', () => this.replaceAll());
                    (_o = this.element.querySelector('.btn-close-find')) == null
                        ? void 0
                        : _o.addEventListener('click', () => this.closeFindReplace());
                    (_p = this.fileInput) == null
                        ? void 0
                        : _p.addEventListener('change', e => this._handleFileOpen(e));
                }
                _applyButtonStyles() {
                    if (!this.element) return;
                    const isDark = document.documentElement.classList.contains('dark');
                    const buttons = this.element.querySelectorAll('button');
                    buttons.forEach(btn => {
                        btn.style.cssText = `
                padding: 6px 12px;
                font-size: 13px;
                border: 1px solid ${isDark ? '#475569' : '#d1d5db'};
                background: ${isDark ? '#111827' : '#ffffff'};
                color: inherit;
                border-radius: 6px;
                cursor: pointer;
            `;
                    });
                }
                _handleInput() {
                    this.isDirty = true;
                    if (this.editor) {
                        this.updateContentState({ content: this.editor.value });
                        this._updateWordCount();
                    }
                }
                _updateWordCount() {
                    if (!this.editor || !this.wordCountDisplay) return;
                    const text = this.editor.value;
                    const words = text.trim() ? text.trim().split(/\s+/).length : 0;
                    const chars = text.length;
                    this.wordCountDisplay.textContent = `W\xF6rter: ${words} | Zeichen: ${chars}`;
                }
                _updateCursorPosition() {
                    if (!this.editor || !this.lineColDisplay) return;
                    const pos = this.editor.selectionStart;
                    const textBeforeCursor = this.editor.value.substring(0, pos);
                    const line = (textBeforeCursor.match(/\n/g) || []).length + 1;
                    const lastNewline = textBeforeCursor.lastIndexOf('\n');
                    const col = pos - lastNewline;
                    this.lineColDisplay.textContent = `Zeile ${line}, Spalte ${col}`;
                }
                clearContent() {
                    if (
                        this.isDirty &&
                        !confirm('Ungespeicherte \xC4nderungen gehen verloren. Fortfahren?')
                    )
                        return;
                    if (this.editor) this.editor.value = '';
                    this.filename = 'Untitled.txt';
                    this.isDirty = false;
                    this.setTitle(this.filename);
                    this.updateContentState({ content: '' });
                    this._updateWordCount();
                }
                openFile() {
                    var _a;
                    (_a = this.fileInput) == null ? void 0 : _a.click();
                }
                _handleFileOpen(event) {
                    var _a;
                    const target = event.target;
                    const file =
                        (_a = target == null ? void 0 : target.files) == null ? void 0 : _a[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = e => {
                        const content = e.target.result;
                        if (this.editor) this.editor.value = content;
                        this.filename = file.name;
                        this.setTitle(this.filename);
                        this.isDirty = false;
                        this.updateContentState({ content });
                        this._updateWordCount();
                        this._showStatus(`Ge\xF6ffnet: ${file.name}`);
                    };
                    reader.readAsText(file);
                }
                saveFile() {
                    var _a;
                    const content = ((_a = this.editor) == null ? void 0 : _a.value) || '';
                    const blob = new Blob([content], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = this.filename;
                    a.click();
                    URL.revokeObjectURL(url);
                    this.isDirty = false;
                    this._showStatus(`Gespeichert: ${this.filename}`);
                }
                _wrapSelection(before, after) {
                    if (!this.editor) return;
                    const start = this.editor.selectionStart;
                    const end = this.editor.selectionEnd;
                    const selectedText = this.editor.value.substring(start, end);
                    const replacement = before + selectedText + after;
                    this.editor.setRangeText(replacement, start, end, 'select');
                    this.editor.focus();
                    this._handleInput();
                }
                toggleWrapMode() {
                    this.wrapMode = this.wrapMode === 'soft' ? 'off' : 'soft';
                    if (this.editor) {
                        this.editor.wrap = this.wrapMode;
                        this.editor.style.whiteSpace =
                            this.wrapMode === 'soft' ? 'pre-wrap' : 'pre';
                    }
                    try {
                        setString(`textEditorWrapMode_${this.id}`, this.wrapMode);
                    } catch (e) {
                        console.warn('Could not save wrap mode', e);
                    }
                    this.updateContentState({ wrapMode: this.wrapMode });
                }
                _loadWrapPreference() {
                    try {
                        const saved = getString(`textEditorWrapMode_${this.id}`);
                        if (saved && this.editor) {
                            this.wrapMode = saved;
                            this.editor.wrap = this.wrapMode;
                            this.editor.style.whiteSpace =
                                this.wrapMode === 'soft' ? 'pre-wrap' : 'pre';
                        }
                    } catch (e) {
                        console.warn('Could not load wrap mode', e);
                    }
                }
                toggleFindReplace() {
                    var _a;
                    if (!this.findReplacePanel) return;
                    const isHidden = this.findReplacePanel.style.display === 'none';
                    this.findReplacePanel.style.display = isHidden ? 'flex' : 'none';
                    if (isHidden && this.findInput) this.findInput.focus();
                    else (_a = this.editor) == null ? void 0 : _a.focus();
                }
                closeFindReplace() {
                    var _a;
                    if (this.findReplacePanel) {
                        this.findReplacePanel.style.display = 'none';
                        (_a = this.editor) == null ? void 0 : _a.focus();
                    }
                }
                findNext() {
                    if (!this.findInput || !this.editor) return;
                    const searchText = this.findInput.value;
                    if (!searchText) return;
                    const content = this.editor.value;
                    const currentPos = this.editor.selectionEnd;
                    const index = content.indexOf(searchText, currentPos);
                    if (index !== -1) {
                        this.editor.setSelectionRange(index, index + searchText.length);
                        this.editor.focus();
                    } else {
                        const firstIndex = content.indexOf(searchText);
                        if (firstIndex !== -1) {
                            this.editor.setSelectionRange(
                                firstIndex,
                                firstIndex + searchText.length
                            );
                            this.editor.focus();
                        }
                    }
                }
                replaceOne() {
                    if (!this.findInput || !this.replaceInput || !this.editor) return;
                    const searchText = this.findInput.value;
                    const replaceText = this.replaceInput.value;
                    if (!searchText) return;
                    const start = this.editor.selectionStart;
                    const end = this.editor.selectionEnd;
                    const selectedText = this.editor.value.substring(start, end);
                    if (selectedText === searchText) {
                        this.editor.setRangeText(replaceText, start, end, 'end');
                        this._handleInput();
                    }
                    this.findNext();
                }
                replaceAll() {
                    if (!this.findInput || !this.replaceInput || !this.editor) return;
                    const searchText = this.findInput.value;
                    const replaceText = this.replaceInput.value;
                    if (!searchText) return;
                    const count = (this.editor.value.match(new RegExp(searchText, 'g')) || [])
                        .length;
                    this.editor.value = this.editor.value.split(searchText).join(replaceText);
                    this._handleInput();
                    this._showStatus(`${count} Ersetzungen`);
                }
                _showStatus(message) {
                    if (!this.statusBar) return;
                    this.statusBar.textContent = message;
                    this.statusBar.style.display = 'block';
                    setTimeout(() => {
                        if (this.statusBar) this.statusBar.style.display = 'none';
                    }, 3e3);
                }
                /**
                 * Serialize document state
                 */
                serialize() {
                    return {
                        ...super.serialize(),
                        filename: this.filename,
                        wrapMode: this.wrapMode,
                        isDirty: this.isDirty,
                    };
                }
                /**
                 * Restore document from state
                 */
                static deserialize(state) {
                    const doc = new _TextEditorDocument({
                        id: state.id,
                        title: state.title || state.filename,
                        content: state.contentState,
                    });
                    if (state.filename) doc.filename = state.filename;
                    if (state.wrapMode) doc.wrapMode = state.wrapMode;
                    if (state.isDirty !== void 0) doc.isDirty = state.isDirty;
                    return doc;
                }
                /**
                 * Focus editor when tab is shown
                 */
                onShow() {
                    if (this.editor && typeof this.editor.focus === 'function') {
                        this.editor.focus();
                    }
                }
            };
            window.TextEditorDocument = TextEditorDocument;
        },
    });

    // src/ts/apps/text-editor/text-editor-window.ts
    var TextEditorWindow;
    var init_text_editor_window = __esm({
        'src/ts/apps/text-editor/text-editor-window.ts'() {
            'use strict';
            init_base_window();
            TextEditorWindow = class _TextEditorWindow extends BaseWindow {
                constructor(config) {
                    super({
                        type: 'text-editor',
                        title: 'TextEditor',
                        ...config,
                    });
                }
                /**
                 * Create text-editor-specific window DOM
                 */
                createDOM() {
                    const modal = super.createDOM();
                    return modal;
                }
                /**
                 * Override tab rendering to use WindowTabs system
                 */
                _renderTabs() {
                    const W = window;
                    if (!W.WindowTabs || !this.element) return;
                    const tabBar = this.element.querySelector(`#${this.id}-tabs`);
                    if (!tabBar) return;
                    const makeInst = tab => ({
                        instanceId: tab.id,
                        title: tab.title,
                        metadata: { tabLabel: tab.title },
                        __tab: tab,
                        show: () => tab.show(),
                        hide: () => tab.hide(),
                    });
                    const adapter = {
                        getAllInstances: () => Array.from(this.tabs.values()).map(makeInst),
                        getActiveInstance: () => {
                            const activeId = this.activeTabId;
                            const t2 = activeId ? this.tabs.get(activeId) : null;
                            return t2 ? makeInst(t2) : null;
                        },
                        getAllInstanceIds: () => Array.from(this.tabs.keys()),
                        getInstance: id => {
                            const t2 = this.tabs.get(id) || null;
                            return t2 ? makeInst(t2) : null;
                        },
                        setActiveInstance: id => this.setActiveTab(id),
                        createInstance: cfg => {
                            const W2 = window;
                            const doc = W2.TextEditorDocument
                                ? new W2.TextEditorDocument({
                                      title:
                                          (cfg == null ? void 0 : cfg.title) ||
                                          `Editor ${this.tabs.size + 1}`,
                                  })
                                : null;
                            if (doc) {
                                this.addTab(doc);
                                return makeInst(doc);
                            }
                            return null;
                        },
                        destroyInstance: id => this.removeTab(id),
                        getInstanceCount: () => this.tabs.size,
                        reorderInstances: newOrder => {
                            const old = this.tabs;
                            const rebuilt = /* @__PURE__ */ new Map();
                            newOrder.forEach(id => {
                                const t2 = old.get(id);
                                if (t2) rebuilt.set(id, t2);
                            });
                            old.forEach((t2, id) => {
                                if (!rebuilt.has(id)) rebuilt.set(id, t2);
                            });
                            this.tabs = rebuilt;
                            this._renderTabs();
                        },
                        detachInstance: id => {
                            const t2 = this.detachTab(id);
                            return t2 ? makeInst(t2) : null;
                        },
                        adoptInstance: inst => {
                            const tab = inst.__tab || inst;
                            this.addTab(tab);
                            this.setActiveTab(tab.id);
                            return makeInst(tab);
                        },
                    };
                    if (this.tabController) {
                        this.tabController.destroy();
                    }
                    this.tabController = W.WindowTabs.create(adapter, tabBar, {
                        addButton: true,
                        onCreateInstanceTitle: () => `Editor ${this.tabs.size + 1}`,
                    });
                }
                /**
                 * Create a new document in this window
                 */
                createDocument(title, content) {
                    const W = window;
                    if (!W.TextEditorDocument) {
                        console.error('TextEditorDocument class not loaded');
                        return null;
                    }
                    const doc = new W.TextEditorDocument({
                        title: title || `Editor ${this.tabs.size + 1}`,
                        content: { content: content || '' },
                    });
                    this.addTab(doc);
                    return doc;
                }
                /**
                 * Static factory method to create a text editor window with one document
                 */
                static create(config) {
                    const window2 = new _TextEditorWindow(config);
                    window2.createDocument();
                    window2.show();
                    const W = globalThis;
                    if (W.WindowRegistry) {
                        W.WindowRegistry.registerWindow(window2);
                    }
                    return window2;
                }
            };
            window.TextEditorWindow = TextEditorWindow;
        },
    });

    // src/ts/apps/text-editor/text-editor-instance.ts
    var require_text_editor_instance = __commonJS({
        'src/ts/apps/text-editor/text-editor-instance.ts'() {
            'use strict';
            init_storage_utils();
            console.log('TextEditorInstance (TS) loaded');
            (() => {
                'use strict';
                const Base = window.BaseWindowInstance;
                class TextEditorInstance extends Base {
                    constructor(config) {
                        super({
                            ...config,
                            type: 'text-editor',
                        });
                        this.editor = null;
                        this.statusBar = null;
                        this.saveButton = null;
                        this.fileInput = null;
                        this.wordCountDisplay = null;
                        this.lineColDisplay = null;
                        this.findReplacePanel = null;
                        this.findInput = null;
                        this.replaceInput = null;
                        this.wrapMode = 'off';
                        this.currentRemoteFile = null;
                        this.currentFilename = config.filename || 'Untitled.txt';
                        this.isDirty = false;
                    }
                    render() {
                        if (!this.container) return;
                        const isDark = document.documentElement.classList.contains('dark');
                        this.container.innerHTML = `
                <div class="text-editor-wrapper flex flex-col h-full" style="background: ${isDark ? '#0f172a' : '#fafafa'}; color: ${isDark ? '#e5e7eb' : '#111827'};">
                    <!-- Toolbar -->
                    <div class="text-editor-toolbar flex-none" style="background: ${isDark ? '#1f2937' : '#f5f5f5'}; padding: 8px 12px; border-bottom: 1px solid ${isDark ? '#374151' : '#d1d5db'}; display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                        <button type="button" class="text-editor-btn" data-action="clear" title="Neu">Neu</button>
                        <button type="button" class="text-editor-btn" data-action="open" title="\xD6ffnen">\xD6ffnen</button>
                        <button type="button" class="text-editor-btn text-save-btn" data-action="save" title="Speichern">Speichern</button>
                        <div class="toolbar-separator"></div>
                        <button type="button" class="text-editor-btn" data-action="bold" title="Fett" style="font-weight: bold;">B</button>
                        <button type="button" class="text-editor-btn" data-action="italic" title="Kursiv" style="font-style: italic;">I</button>
                        <button type="button" class="text-editor-btn" data-action="underline" title="Unterstrichen" style="text-decoration: underline;">U</button>
                        <div class="toolbar-separator"></div>
                        <button type="button" class="text-editor-btn" data-action="find" title="Suchen & Ersetzen">\u{1F50D}</button>
                        <button type="button" class="text-editor-btn" data-action="toggleWrap" title="Zeilenumbruch">\u23CE</button>
                        <input type="file" class="text-file-input"
                            accept=".txt,.md,.markdown,.html,.css,.js,.json,.yml,.yaml,.xml"
                            style="display:none">
                    </div>

                    <!-- Find/Replace Panel (hidden by default) -->
                    <div class="find-replace-panel" style="background: ${isDark ? '#1f2937' : '#f5f5f5'}; padding: 8px 12px; border-bottom: 1px solid ${isDark ? '#374151' : '#d1d5db'}; display: none; gap: 8px; align-items: center;">
                        <input type="text" class="find-input" placeholder="Suchen..." style="padding: 4px 8px; border: 1px solid ${isDark ? '#475569' : '#d1d5db'}; border-radius: 4px; background: ${isDark ? '#111827' : '#ffffff'}; color: inherit;">
                        <input type="text" class="replace-input" placeholder="Ersetzen..." style="padding: 4px 8px; border: 1px solid ${isDark ? '#475569' : '#d1d5db'}; border-radius: 4px; background: ${isDark ? '#111827' : '#ffffff'}; color: inherit;">
                        <button type="button" class="text-editor-btn" data-action="findNext">Weiter</button>
                        <button type="button" class="text-editor-btn" data-action="replaceOne">Ersetzen</button>
                        <button type="button" class="text-editor-btn" data-action="replaceAll">Alle ersetzen</button>
                        <button type="button" class="text-editor-btn" data-action="closeFindReplace">\u2715</button>
                    </div>

                    <!-- Status Bar for filename -->
                    <div class="text-file-status" style="padding: 6px 12px; border-bottom: 1px solid ${isDark ? '#374151' : '#d1d5db'}; background: ${isDark ? '#1f2937' : '#f5f5f5'}; font-size: 13px; opacity: 0.85; display: none;"></div>

                    <!-- Editor Textarea -->
                    <textarea class="text-editor-textarea flex-1 w-full resize-none p-4 border-0 outline-none"
                        spellcheck="false"
                        wrap="off"
                        style="background: ${isDark ? '#111827' : '#ffffff'}; color: inherit; font-family: 'SFMono-Regular', Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 14px; line-height: 1.6; tab-size: 4;"
                        placeholder="Text eingeben..."></textarea>

                    <!-- Status Bar -->
                    <div class="text-editor-statusbar flex-none" style="background: ${isDark ? '#1f2937' : '#f5f5f5'}; padding: 6px 12px; border-top: 1px solid ${isDark ? '#374151' : '#d1d5db'}; font-size: 12px; opacity: 0.75; display: flex; justify-content: space-between;">
                        <span class="word-count-display">W\xF6rter: 0 | Zeichen: 0</span>
                        <span class="line-col-display">Zeile 1, Spalte 1</span>
                    </div>
                </div>
            `;
                        this._applyButtonStyles();
                    }
                    _applyButtonStyles() {
                        if (!this.container) return;
                        const isDark = document.documentElement.classList.contains('dark');
                        const buttons = this.container.querySelectorAll('.text-editor-btn');
                        buttons.forEach(btn => {
                            btn.style.cssText = `
                    padding: 6px 12px;
                    font-size: 13px;
                    border: 1px solid ${isDark ? '#475569' : '#d1d5db'};
                    background: ${isDark ? '#111827' : '#ffffff'};
                    color: inherit;
                    border-radius: 6px;
                    cursor: pointer;
                    transition: background 0.2s;
                `;
                        });
                        const separators = this.container.querySelectorAll('.toolbar-separator');
                        separators.forEach(sep => {
                            sep.style.cssText = `
                    width: 1px;
                    height: 20px;
                    background: ${isDark ? '#475569' : '#d1d5db'};
                    margin: 0 4px;
                `;
                        });
                    }
                    attachEventListeners() {
                        var _a, _b, _c, _d;
                        if (!this.container) return;
                        this.editor = this.container.querySelector('.text-editor-textarea');
                        this.statusBar = this.container.querySelector('.text-file-status');
                        this.saveButton = this.container.querySelector('[data-action="save"]');
                        this.fileInput = this.container.querySelector('.text-file-input');
                        this.wordCountDisplay = this.container.querySelector('.word-count-display');
                        this.lineColDisplay = this.container.querySelector('.line-col-display');
                        this.findReplacePanel = this.container.querySelector('.find-replace-panel');
                        this.findInput = this.container.querySelector('.find-input');
                        this.replaceInput = this.container.querySelector('.replace-input');
                        if (
                            !this._skipInitialRender &&
                            this.state &&
                            this.state.content &&
                            this.editor
                        ) {
                            this.editor.value = this.state.content;
                        }
                        (_a = this.editor) == null
                            ? void 0
                            : _a.addEventListener('input', () => this._handleInput());
                        (_b = this.editor) == null
                            ? void 0
                            : _b.addEventListener('click', () => this._updateCursorPosition());
                        (_c = this.editor) == null
                            ? void 0
                            : _c.addEventListener('keyup', () => this._updateCursorPosition());
                        (_d = this.editor) == null
                            ? void 0
                            : _d.addEventListener('select', () => this._updateCursorPosition());
                        this.container.addEventListener('click', e => {
                            const target = e.target;
                            const btn = target == null ? void 0 : target.closest('[data-action]');
                            if (!btn) return;
                            const action = btn.getAttribute('data-action');
                            this._handleAction(action);
                        });
                        if (this.fileInput) {
                            this.fileInput.addEventListener('change', e => this._handleFileOpen(e));
                        }
                        this._updateWordCount();
                        this._updateCursorPosition();
                        this._loadWrapPreference();
                    }
                    _handleAction(action) {
                        const actions = {
                            clear: () => this.clearContent(),
                            open: () => this.openFile(),
                            save: () => this.saveFile(),
                            bold: () => this._wrapSelection('**', '**'),
                            italic: () => this._wrapSelection('*', '*'),
                            underline: () => this._wrapSelection('<u>', '</u>'),
                            find: () => this.toggleFindReplace(),
                            toggleWrap: () => this.toggleWrapMode(),
                            findNext: () => this.findNext(),
                            replaceOne: () => this.replaceOne(),
                            replaceAll: () => this.replaceAll(),
                            closeFindReplace: () => this.closeFindReplace(),
                        };
                        if (actions[action]) actions[action]();
                    }
                    _handleInput() {
                        this.isDirty = true;
                        if (this.editor) {
                            this.updateState({ content: this.editor.value });
                            this._updateWordCount();
                            this._updateSaveButton();
                            const emit = Base.prototype.emit;
                            emit.call(this, 'contentChanged', { content: this.editor.value });
                        }
                    }
                    _updateWordCount() {
                        if (!this.editor || !this.wordCountDisplay) return;
                        const text = this.editor.value;
                        const words = text.trim() ? text.trim().split(/\s+/).length : 0;
                        const chars = text.length;
                        this.wordCountDisplay.textContent = `W\xF6rter: ${words} | Zeichen: ${chars}`;
                    }
                    _updateCursorPosition() {
                        if (!this.editor || !this.lineColDisplay) return;
                        const pos = this.editor.selectionStart;
                        const textBeforeCursor = this.editor.value.substring(0, pos);
                        const line = (textBeforeCursor.match(/\n/g) || []).length + 1;
                        const lastNewline = textBeforeCursor.lastIndexOf('\n');
                        const col = pos - lastNewline;
                        this.lineColDisplay.textContent = `Zeile ${line}, Spalte ${col}`;
                        this.updateState({ cursorPosition: { line, col } });
                    }
                    _updateSaveButton() {
                        if (!this.saveButton) return;
                        if (this.isDirty) {
                            this.saveButton.style.fontWeight = 'bold';
                            this.saveButton.setAttribute('title', '\xC4nderungen speichern');
                        } else {
                            this.saveButton.style.fontWeight = 'normal';
                            this.saveButton.setAttribute('title', 'Speichern');
                        }
                    }
                    clearContent() {
                        if (
                            this.isDirty &&
                            !confirm('Ungespeicherte \xC4nderungen gehen verloren. Fortfahren?')
                        ) {
                            return;
                        }
                        if (this.editor) this.editor.value = '';
                        this.currentFilename = 'Untitled.txt';
                        this.isDirty = false;
                        this.updateState({ content: '', filename: this.currentFilename });
                        this._updateWordCount();
                        this._updateSaveButton();
                        this._hideStatusBar();
                        const emit = Base.prototype.emit;
                        emit.call(this, 'contentCleared');
                    }
                    openFile() {
                        var _a;
                        (_a = this.fileInput) == null ? void 0 : _a.click();
                    }
                    _handleFileOpen(event) {
                        var _a;
                        const target = event.target;
                        const file =
                            (_a = target == null ? void 0 : target.files) == null ? void 0 : _a[0];
                        if (!file) return;
                        const reader = new FileReader();
                        reader.onload = e => {
                            const result = e.target.result;
                            if (this.editor) this.editor.value = result;
                            this.currentFilename = file.name;
                            this.isDirty = false;
                            this.updateState({ content: result, filename: file.name });
                            this._updateWordCount();
                            this._updateSaveButton();
                            this._showStatusBar(`Ge\xF6ffnet: ${file.name}`);
                            const emit = Base.prototype.emit;
                            emit.call(this, 'fileOpened', { filename: file.name });
                        };
                        reader.readAsText(file);
                    }
                    saveFile() {
                        var _a;
                        const content = ((_a = this.editor) == null ? void 0 : _a.value) || '';
                        const blob = new Blob([content], { type: 'text/plain' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = this.currentFilename;
                        a.click();
                        URL.revokeObjectURL(url);
                        this.isDirty = false;
                        this._updateSaveButton();
                        this._showStatusBar(`Gespeichert: ${this.currentFilename}`);
                        const emit = Base.prototype.emit;
                        emit.call(this, 'fileSaved', { filename: this.currentFilename });
                    }
                    _wrapSelection(before, after) {
                        if (!this.editor) return;
                        const start = this.editor.selectionStart;
                        const end = this.editor.selectionEnd;
                        const selectedText = this.editor.value.substring(start, end);
                        const replacement = before + selectedText + after;
                        this.editor.setRangeText(replacement, start, end, 'select');
                        this.editor.focus();
                        this._handleInput();
                    }
                    toggleWrapMode() {
                        this.wrapMode = this.wrapMode === 'soft' ? 'off' : 'soft';
                        if (this.editor) {
                            this.editor.wrap = this.wrapMode;
                            this.editor.style.whiteSpace =
                                this.wrapMode === 'soft' ? 'pre-wrap' : 'pre';
                        }
                        try {
                            setString(`textEditorWrapMode_${this.instanceId}`, this.wrapMode);
                        } catch (e) {
                            console.warn('Could not save wrap mode', e);
                        }
                        this.updateState({ wrapMode: this.wrapMode });
                        this._showStatusBar(
                            this.wrapMode === 'soft'
                                ? 'Zeilenumbruch aktiviert'
                                : 'Zeilenumbruch deaktiviert'
                        );
                    }
                    _loadWrapPreference() {
                        try {
                            const id = this.instanceId;
                            const saved = getString(`textEditorWrapMode_${id}`);
                            if (saved && this.editor) {
                                this.wrapMode = saved;
                                this.editor.wrap = this.wrapMode;
                                this.editor.style.whiteSpace =
                                    this.wrapMode === 'soft' ? 'pre-wrap' : 'pre';
                            }
                        } catch (e) {
                            console.warn('Could not load wrap mode', e);
                        }
                    }
                    toggleFindReplace() {
                        var _a;
                        if (!this.findReplacePanel) return;
                        const isHidden = this.findReplacePanel.style.display === 'none';
                        this.findReplacePanel.style.display = isHidden ? 'flex' : 'none';
                        if (isHidden && this.findInput) this.findInput.focus();
                        else (_a = this.editor) == null ? void 0 : _a.focus();
                    }
                    closeFindReplace() {
                        var _a;
                        if (this.findReplacePanel) {
                            this.findReplacePanel.style.display = 'none';
                            (_a = this.editor) == null ? void 0 : _a.focus();
                        }
                    }
                    findNext() {
                        if (!this.findInput || !this.editor) return;
                        const searchText = this.findInput.value;
                        if (!searchText) return;
                        const content = this.editor.value;
                        const currentPos = this.editor.selectionEnd;
                        const index = content.indexOf(searchText, currentPos);
                        if (index !== -1) {
                            this.editor.setSelectionRange(index, index + searchText.length);
                            this.editor.focus();
                        } else {
                            const firstIndex = content.indexOf(searchText);
                            if (firstIndex !== -1) {
                                this.editor.setSelectionRange(
                                    firstIndex,
                                    firstIndex + searchText.length
                                );
                                this.editor.focus();
                            } else {
                                this._showStatusBar('Nicht gefunden');
                            }
                        }
                    }
                    replaceOne() {
                        if (!this.findInput || !this.replaceInput || !this.editor) return;
                        const searchText = this.findInput.value;
                        const replaceText = this.replaceInput.value;
                        if (!searchText) return;
                        const start = this.editor.selectionStart;
                        const end = this.editor.selectionEnd;
                        const selectedText = this.editor.value.substring(start, end);
                        if (selectedText === searchText) {
                            this.editor.setRangeText(replaceText, start, end, 'end');
                            this._handleInput();
                        }
                        this.findNext();
                    }
                    replaceAll() {
                        if (!this.findInput || !this.replaceInput || !this.editor) return;
                        const searchText = this.findInput.value;
                        const replaceText = this.replaceInput.value;
                        if (!searchText) return;
                        const newContent = this.editor.value.split(searchText).join(replaceText);
                        const count = (this.editor.value.match(new RegExp(searchText, 'g')) || [])
                            .length;
                        this.editor.value = newContent;
                        this._handleInput();
                        this._showStatusBar(`${count} Ersetzungen vorgenommen`);
                    }
                    _showStatusBar(message) {
                        if (!this.statusBar) return;
                        this.statusBar.textContent = message;
                        this.statusBar.style.display = 'block';
                        setTimeout(() => this._hideStatusBar(), 3e3);
                    }
                    _hideStatusBar() {
                        if (this.statusBar) this.statusBar.style.display = 'none';
                    }
                    show() {
                        const baseShow = Base.prototype.show;
                        baseShow.call(this);
                        if (this.container) {
                            this.editor = this.container.querySelector('.text-editor-textarea');
                        }
                        if (this.editor && this.state && typeof this.state.content === 'string') {
                            this.editor.value = this.state.content;
                            this._updateWordCount();
                            this._updateCursorPosition();
                        }
                    }
                    focus() {
                        var _a;
                        const baseFocus = Base.prototype.focus;
                        baseFocus.call(this);
                        (_a = this.editor) == null ? void 0 : _a.focus();
                    }
                    serialize() {
                        var _a;
                        const baseSerialize = Base.prototype.serialize;
                        const baseObj = baseSerialize.call(this);
                        return {
                            ...baseObj,
                            content: ((_a = this.editor) == null ? void 0 : _a.value) || '',
                            filename: this.currentFilename,
                            wrapMode: this.wrapMode,
                            isDirty: this.isDirty,
                        };
                    }
                    deserialize(data) {
                        const baseDeserialize = Base.prototype.deserialize;
                        baseDeserialize.call(this, data);
                        const d = data;
                        if (d.content && this.editor) {
                            this.editor.value = d.content;
                            this._updateWordCount();
                        }
                        if (d.filename) this.currentFilename = d.filename;
                        if (d.wrapMode) {
                            this.wrapMode = d.wrapMode;
                            if (this.editor) {
                                this.editor.wrap = this.wrapMode;
                                this.editor.style.whiteSpace =
                                    this.wrapMode === 'soft' ? 'pre-wrap' : 'pre';
                            }
                        }
                        if (typeof d.isDirty !== 'undefined') {
                            this.isDirty = d.isDirty;
                            this._updateSaveButton();
                        }
                    }
                }
                window.TextEditorInstance = TextEditorInstance;
                const G = window;
                const ensureTextEditorInstanceManager = () => {
                    if (G['TextEditorInstanceManager']) return true;
                    const InstanceManager = G['InstanceManager'];
                    if (!InstanceManager) {
                        return false;
                    }
                    try {
                        G['TextEditorInstanceManager'] = new InstanceManager({
                            type: 'text-editor',
                            instanceClass: TextEditorInstance,
                            maxInstances: 0,
                            createContainer: function (instanceId) {
                                const editorModalContainer =
                                    document.getElementById('text-editor-container');
                                if (!editorModalContainer) {
                                    console.error('Text editor container not found');
                                    return null;
                                }
                                const container = document.createElement('div');
                                container.id = `${instanceId}-container`;
                                container.className = 'text-editor-instance-container h-full';
                                const domUtils = window.DOMUtils;
                                if (domUtils && typeof domUtils.hide === 'function') {
                                    domUtils.hide(container);
                                } else {
                                    container.classList.add('hidden');
                                }
                                editorModalContainer.appendChild(container);
                                return container;
                            },
                        });
                        console.log('[TextEditorInstance] TextEditorInstanceManager created');
                        return true;
                    } catch (err) {
                        console.error(
                            '[TextEditorInstance] Failed to create TextEditorInstanceManager:',
                            err
                        );
                        return false;
                    }
                };
                if (!ensureTextEditorInstanceManager()) {
                    const initHook = () => {
                        if (ensureTextEditorInstanceManager()) {
                            return;
                        }
                        setTimeout(initHook, 100);
                    };
                    Promise.resolve().then(initHook);
                }
            })();
        },
    });

    // src/ts/windows/preview-window-instance.ts
    var WindowChrome, PreviewWindowInstance, preview_window_instance_default;
    var init_preview_window_instance = __esm({
        'src/ts/windows/preview-window-instance.ts'() {
            'use strict';
            init_base_window_instance();
            WindowChrome = window.WindowChrome;
            PreviewWindowInstance = class extends base_window_instance_default {
                constructor(config) {
                    super(config);
                    this._prevImages = [];
                    this.updateState({
                        zoom: 1,
                        images: [],
                        currentIndex: 0,
                    });
                }
                render() {
                    var _a, _b;
                    if (!this.container) return;
                    this.container.innerHTML = '';
                    const titlebar = WindowChrome.createTitlebar({
                        title: this.title,
                        icon: './img/preview.png',
                        showClose: true,
                        showMinimize: true,
                        showMaximize: false,
                        onClose: () => this.destroy(),
                    });
                    this.container.appendChild(titlebar);
                    const toolbar = WindowChrome.createToolbar([
                        { label: 'Zoom In', icon: '\u{1F50D}+', onClick: () => this.zoomIn() },
                        { label: 'Zoom Out', icon: '\u{1F50D}-', onClick: () => this.zoomOut() },
                        { type: 'separator' },
                        {
                            label: 'Previous',
                            icon: '\u2B05\uFE0F',
                            onClick: () => this.prevImage(),
                        },
                        { label: 'Next', icon: '\u27A1\uFE0F', onClick: () => this.nextImage() },
                    ]);
                    this.container.appendChild(toolbar);
                    const imageArea = document.createElement('div');
                    imageArea.className = 'preview-image-area flex justify-center items-center';
                    imageArea.style.height = 'calc(100% - 80px)';
                    imageArea.style.position = 'relative';
                    imageArea.ondrop = e => this.handleDrop(e);
                    imageArea.ondragover = e => e.preventDefault();
                    const st = this.getState();
                    const images = st.images || [];
                    const idx = (_a = st.currentIndex) != null ? _a : 0;
                    try {
                        const prev = this._prevImages || [];
                        const removed = prev.filter(
                            p => p && p.startsWith('blob:') && !images.includes(p)
                        );
                        removed.forEach(u => {
                            try {
                                URL.revokeObjectURL(u);
                            } catch (e) {}
                        });
                    } catch (e) {}
                    if (images.length > 0 && images[idx]) {
                        const img = document.createElement('img');
                        img.src = images[idx];
                        img.style.maxWidth = '100%';
                        img.style.maxHeight = '100%';
                        img.style.transform = `scale(${(_b = st.zoom) != null ? _b : 1})`;
                        img.style.display = 'block';
                        img.style.visibility = 'hidden';
                        img.draggable = true;
                        img.addEventListener('contextmenu', e => this.showContextMenu(e));
                        img.addEventListener('load', () => {
                            img.style.visibility = 'visible';
                            img.style.opacity = '1';
                        });
                        img.addEventListener('error', () => {});
                        imageArea.appendChild(img);
                    } else {
                        const placeholder = document.createElement('div');
                        placeholder.className = 'text-gray-500 dark:text-gray-400 text-center px-6';
                        placeholder.textContent = 'No image selected';
                        imageArea.appendChild(placeholder);
                    }
                    this.container.appendChild(imageArea);
                    this._prevImages = images.slice();
                    const counter = images.length > 0 ? `${idx + 1} / ${images.length}` : '';
                    const statusBar = WindowChrome.createStatusBar({
                        leftContent: st.path || '',
                        rightContent: `Zoom: ${Math.round((st.zoom || 1) * 100)}% ${counter}`,
                    });
                    this.container.appendChild(statusBar);
                    this.attachKeyboardShortcuts();
                }
                attachKeyboardShortcuts() {
                    if (this.keydownListener) {
                        document.removeEventListener('keydown', this.keydownListener);
                    }
                    this.keydownListener = e => {
                        if (!this.isVisible) return;
                        if (e.key === 'ArrowLeft') {
                            e.preventDefault();
                            this.prevImage();
                        } else if (e.key === 'ArrowRight') {
                            e.preventDefault();
                            this.nextImage();
                        }
                    };
                    document.addEventListener('keydown', this.keydownListener);
                }
                zoomIn() {
                    const st = this.getState();
                    this.updateState({ zoom: Math.min((st.zoom || 1) + 0.1, 3) });
                    this.render();
                }
                zoomOut() {
                    const st = this.getState();
                    this.updateState({ zoom: Math.max((st.zoom || 1) - 0.1, 0.2) });
                    this.render();
                }
                nextImage() {
                    var _a;
                    const st = this.getState();
                    const images = st.images || [];
                    if (images.length === 0) return;
                    const next = (((_a = st.currentIndex) != null ? _a : 0) + 1) % images.length;
                    this.updateState({ currentIndex: next });
                    this.render();
                }
                prevImage() {
                    var _a;
                    const st = this.getState();
                    const images = st.images || [];
                    if (images.length === 0) return;
                    const prev =
                        (((_a = st.currentIndex) != null ? _a : 0) - 1 + images.length) %
                        images.length;
                    this.updateState({ currentIndex: prev });
                    this.render();
                }
                handleDrop(e) {
                    var _a;
                    e.preventDefault();
                    const files = (_a = e.dataTransfer) == null ? void 0 : _a.files;
                    if (files && files.length > 0 && files[0]) {
                        const url = URL.createObjectURL(files[0]);
                        this.updateState({ images: [url], currentIndex: 0 });
                        this.render();
                    }
                }
                showContextMenu(e) {
                    e.preventDefault();
                }
                destroy() {
                    if (this.keydownListener) {
                        document.removeEventListener('keydown', this.keydownListener);
                    }
                    try {
                        (this._prevImages || []).forEach(u => {
                            if (u && u.startsWith('blob:')) {
                                try {
                                    URL.revokeObjectURL(u);
                                } catch (e) {}
                            }
                        });
                    } catch (e) {}
                    super.destroy();
                }
            };
            window.PreviewWindowInstance = PreviewWindowInstance;
            preview_window_instance_default = PreviewWindowInstance;
        },
    });

    // src/ts/windows/preview-instance-manager.ts
    var PreviewInstanceManager, preview_instance_manager_default;
    var init_preview_instance_manager = __esm({
        'src/ts/windows/preview-instance-manager.ts'() {
            'use strict';
            init_preview_window_instance();
            PreviewInstanceManager = class {
                static createInstance(config = {}) {
                    this.instanceCounter++;
                    const instanceId = `${this.type}-${this.instanceCounter}`;
                    const instance = new preview_window_instance_default({
                        id: instanceId,
                        type: this.type,
                        title: config.path ? `Preview: ${config.path}` : 'Preview',
                        initialState: config,
                    });
                    this.instances.set(instanceId, instance);
                    return instance;
                }
                /** Ensure a single initialized instance attached to #preview-container */
                static getOrCreateSingleton() {
                    const existing = this.instances.get(this.singletonId);
                    if (existing && existing.isInitialized) return existing;
                    const containerRoot = document.getElementById('preview-container');
                    if (!containerRoot) {
                        console.error('Preview container #preview-container not found');
                        return null;
                    }
                    let instContainer = containerRoot.querySelector('#preview-instance-container');
                    if (!instContainer) {
                        instContainer = document.createElement('div');
                        instContainer.id = 'preview-instance-container';
                        instContainer.className = 'h-full flex flex-col min-h-0';
                        containerRoot.appendChild(instContainer);
                    }
                    const instance = new preview_window_instance_default({
                        id: this.singletonId,
                        type: this.type,
                        title: 'Preview',
                        initialState: { images: [], currentIndex: 0, zoom: 1 },
                    });
                    try {
                        instance.init(instContainer);
                    } catch (e) {
                        console.error('Failed to initialize Preview instance:', e);
                        return null;
                    }
                    this.instances.set(this.singletonId, instance);
                    return instance;
                }
                /** Open a list of images in the Preview (ensures modal and instance) */
                static openImages(images, startIndex = 0, path) {
                    var _a, _b, _c, _d, _e;
                    if (!Array.isArray(images) || images.length === 0) return;
                    try {
                        const W = window;
                        if (
                            (_b = (_a = W.API) == null ? void 0 : _a.window) == null
                                ? void 0
                                : _b.open
                        )
                            W.API.window.open('preview-modal');
                        else
                            (_d = (_c = W.WindowManager) == null ? void 0 : _c.open) == null
                                ? void 0
                                : _d.call(_c, 'preview-modal');
                    } catch {}
                    try {
                        const containerRoot = document.getElementById('preview-container');
                        if (containerRoot) {
                            const domUtils = window.DOMUtils;
                            if (domUtils && typeof domUtils.show === 'function') {
                                domUtils.show(containerRoot);
                            } else {
                                containerRoot.classList.remove('hidden');
                            }
                            containerRoot.style.pointerEvents = 'auto';
                        }
                    } catch (_) {}
                    const instance = this.getOrCreateSingleton();
                    if (!instance) return;
                    const idx = Math.max(0, Math.min(startIndex, images.length - 1));
                    instance.updateState({ images, currentIndex: idx, path: path || void 0 });
                    instance.render();
                    (_e = instance.show) == null ? void 0 : _e.call(instance);
                }
                static getInstance(instanceId) {
                    return this.instances.get(instanceId);
                }
                static destroyInstance(instanceId) {
                    const instance = this.instances.get(instanceId);
                    if (instance) {
                        instance.destroy();
                        this.instances.delete(instanceId);
                    }
                }
                static destroyAll() {
                    this.instances.forEach(instance => instance.destroy());
                    this.instances.clear();
                }
            };
            PreviewInstanceManager.type = 'preview';
            PreviewInstanceManager.instances = /* @__PURE__ */ new Map();
            PreviewInstanceManager.instanceCounter = 0;
            PreviewInstanceManager.singletonId = 'preview-single';
            window.PreviewInstanceManager = PreviewInstanceManager;
            preview_instance_manager_default = PreviewInstanceManager;
        },
    });

    // src/ts/apps/finder/finder-view.ts
    var ROOT_FOLDER_NAME, _FinderView, FinderView;
    var init_finder_view = __esm({
        'src/ts/apps/finder/finder-view.ts'() {
            'use strict';
            init_base_tab();
            init_virtual_fs();
            init_preview_instance_manager();
            ROOT_FOLDER_NAME = 'Computer';
            _FinderView = class _FinderView extends BaseTab {
                constructor(config) {
                    var _a, _b, _c;
                    super({
                        type: 'finder-view',
                        title: (config == null ? void 0 : config.title) || 'Computer',
                        icon: '\u{1F4BB}',
                        ...config,
                    });
                    this.githubError = false;
                    this.githubErrorMessage = '';
                    // Track scroll position to restore after file open/close
                    this._savedScrollPosition = 0;
                    this.source = (config == null ? void 0 : config.source) || 'computer';
                    this.currentPath = [];
                    this.viewMode = 'list';
                    this.sortBy = 'name';
                    this.sortOrder = 'asc';
                    this.selectedItems = /* @__PURE__ */ new Set();
                    this._renderedItems = [];
                    this._eventHandlersAttached = false;
                    this.sidebarWidth =
                        (_b =
                            (_a = config == null ? void 0 : config.content) == null
                                ? void 0
                                : _a.sidebarWidth) != null
                            ? _b
                            : 192;
                    this.githubRepos = [];
                    this.lastGithubItemsMap = /* @__PURE__ */ new Map();
                    const savedFavorites =
                        ((_c = config == null ? void 0 : config.content) == null
                            ? void 0
                            : _c.favorites) || [];
                    this.favorites = new Set(savedFavorites);
                    this.recentFiles = _FinderView.loadRecentFiles();
                    this.maxRecentFiles = _FinderView.MAX_RECENT_FILES;
                    this.searchTerm = '';
                    this.githubContentCache = /* @__PURE__ */ new Map();
                    this.cacheTTL = 5 * 60 * 1e3;
                    this.dom = {
                        toolbar: null,
                        breadcrumbs: null,
                        content: null,
                        viewListBtn: null,
                        viewGridBtn: null,
                        sidebar: null,
                        resizer: null,
                    };
                }
                createDOM() {
                    const container = document.createElement('div');
                    container.id = `${this.id}-container`;
                    container.className = 'tab-content hidden w-full h-full flex flex-col min-h-0';
                    const isGithub = this.source === 'github';
                    container.innerHTML = `
            <div class="flex-1 flex gap-0 min-h-0 min-w-0 overflow-hidden">
                <aside id="finder-sidebar" class="shrink-0 bg-gray-50 dark:bg-gray-900 border-r border-gray-200 dark:border-gray-700 overflow-y-auto" style="width: ${this.sidebarWidth}px;">
                    <div class="py-2">
                        <div class="px-3 py-1 text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wide" data-i18n="finder.sidebar.favorites">FAVORITEN</div>
                        <button class="finder-sidebar-item" id="finder-sidebar-home" data-sidebar-action="home">
                            <span class="finder-sidebar-icon">\u{1F3E0}</span>
                            <span data-i18n="finder.sidebar.home">Home</span>
                        </button>
                        <button class="finder-sidebar-item finder-sidebar-active" id="finder-sidebar-computer" data-sidebar-action="computer">
                            <span class="finder-sidebar-icon">\u{1F4BB}</span>
                            <span data-i18n="finder.sidebar.computer">Computer</span>
                        </button>
                        <button class="finder-sidebar-item" id="finder-sidebar-recent" data-sidebar-action="recent">
                            <span class="finder-sidebar-icon">\u{1F552}</span>
                            <span data-i18n="finder.sidebar.recent">Zuletzt verwendet</span>
                        </button>
                        <div class="px-3 py-1 mt-4 text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wide" data-i18n="finder.sidebar.locations">ORTE</div>
                        <button class="finder-sidebar-item" id="finder-sidebar-github" data-sidebar-action="github">
                            <span class="finder-sidebar-icon">\u{1F4C2}</span>
                            <span data-i18n="finder.sidebar.github">GitHub Projekte</span>
                        </button>
                        <button class="finder-sidebar-item" id="finder-sidebar-starred" data-sidebar-action="starred">
                            <span class="finder-sidebar-icon">\u2B50</span>
                            <span data-i18n="finder.sidebar.starred">Markiert</span>
                        </button>
                    </div>
                </aside>
                <div class="finder-resizer shrink-0 w-1 md:w-1.5 bg-gray-200 dark:bg-gray-700 hover:bg-blue-400 cursor-col-resize" role="separator" aria-orientation="vertical" title="Gr\xF6\xDFe \xE4ndern"></div>
                <div class="flex-1 flex flex-col min-h-0 min-w-0">
                    <div class="finder-toolbar px-4 py-2 border-b border-gray-200 dark:border-gray-700 flex items-center gap-2">
                        <!-- Back / Root like old Finder -->
                        <button class="finder-toolbar-btn" data-action="navigate-up" data-i18n-title="finder.toolbar.back" title="Zur\xFCck">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 12H5M12 19l-7-7 7-7" /></svg>
                        </button>
                        <button class="finder-toolbar-btn" data-action="navigate-root" data-i18n-title="finder.toolbar.forward" title="Nach vorn">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12h14M12 5l7 7-7 7" /></svg>
                        </button>
                        <!-- Breadcrumbs centered/left grow -->
                        <div class="flex-1 mx-2 min-w-0">
                            <div class="breadcrumbs text-sm text-gray-600 dark:text-gray-400 flex items-center gap-1 overflow-hidden"></div>
                        </div>
                        <!-- Optional: sort menu next to view controls -->
                        <div class="relative hidden md:block">
                            <button class="finder-toolbar-btn" data-action="toggle-sort" title="Sortierung">\u21C5</button>
                            <div class="finder-sort-menu hidden absolute right-0 mt-1 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded shadow-lg z-10" style="width: 180px;">
                                <button class="w-full px-3 py-2 text-left text-sm hover:bg-gray-100 dark:hover:bg-gray-700" data-sort="name" data-i18n="context.finder.sortByName">Nach Name</button>
                                <button class="w-full px-3 py-2 text-left text-sm hover:bg-gray-100 dark:hover:bg-gray-700" data-sort="date" data-i18n="context.finder.sortByDate">Nach Datum</button>
                                <button class="w-full px-3 py-2 text-left text-sm hover:bg-gray-100 dark:hover:bg-gray-700" data-sort="size" data-i18n="context.finder.sortBySize">Nach Gr\xF6\xDFe</button>
                                <div class="border-t border-gray-200 dark:border-gray-700 my-1"></div>
                                <button class="w-full px-3 py-2 text-left text-sm hover:bg-gray-100 dark:hover:bg-gray-700" data-order="asc">\u2191 Aufsteigend</button>
                                <button class="w-full px-3 py-2 text-left text-sm hover:bg-gray-100 dark:hover:bg-gray-700" data-order="desc">\u2193 Absteigend</button>
                            </div>
                        </div>
                        <button class="finder-toolbar-btn" data-action="toggle-favorite" title="Zu Favoriten" style="display: none;">\u2B50</button>
                        <div class="flex gap-1">
                            <button class="finder-toolbar-btn" data-action="view-list" data-i18n-title="finder.toolbar.listView" title="Listenansicht">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M3 4h18v2H3V4m0 7h18v2H3v-2m0 7h18v2H3v-2Z" /></svg>
                            </button>
                            <button class="finder-toolbar-btn" data-action="view-grid" data-i18n-title="finder.toolbar.gridView" title="Rasteransicht">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M3 3h8v8H3V3m10 0h8v8h-8V3M3 13h8v8H3v-8m10 0h8v8h-8v-8Z" /></svg>
                            </button>
                        </div>
                        <input type="text" class="finder-search px-3 py-1 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500 flex-shrink-0 w-28 sm:w-40 md:w-56 lg:w-72 xl:w-80" data-i18n-placeholder="finder.toolbar.search" placeholder="Suchen" />
                    </div>
                    <div class="finder-content flex-1 overflow-auto bg-white dark:bg-gray-800 min-w-0" data-finder-content></div>
                </div>
            </div>
        `;
                    this.element = container;
                    this.dom.toolbar = container.querySelector('.finder-toolbar');
                    this.dom.breadcrumbs = container.querySelector('.breadcrumbs');
                    this.dom.content = container.querySelector('.finder-content');
                    this.dom.sidebar = container.querySelector('#finder-sidebar');
                    this.dom.resizer = container.querySelector('.finder-resizer');
                    this.dom.viewListBtn = null;
                    this.dom.viewGridBtn = null;
                    this._attachEvents();
                    this._attachSidebarEvents();
                    this._attachResizeHandlers();
                    this._setupContentEventHandlers();
                    this._renderAll();
                    const w = window;
                    if (w.appI18n) {
                        w.appI18n.applyTranslations(container);
                    }
                    return container;
                }
                _attachResizeHandlers() {
                    var _a;
                    const sidebar = this.dom.sidebar;
                    const resizer = this.dom.resizer;
                    const contentArea =
                        (_a = this.element) == null
                            ? void 0
                            : _a.querySelector('.flex-1.flex.gap-0.min-h-0.overflow-hidden');
                    if (!sidebar || !resizer) return;
                    const minWidth = 160;
                    const maxWidth = 480;
                    let startX = 0;
                    let startWidth = 0;
                    let dragging = false;
                    const onMouseMove = e => {
                        if (!dragging) return;
                        const dx = e.clientX - startX;
                        let newWidth = Math.max(minWidth, Math.min(startWidth + dx, maxWidth));
                        const container = this.element;
                        if (container) {
                            const total = container.clientWidth;
                            const minContent = 360;
                            newWidth = Math.min(newWidth, Math.max(total - minContent, minWidth));
                        }
                        sidebar.style.width = `${newWidth}px`;
                        this.sidebarWidth = newWidth;
                    };
                    const stopDragging = () => {
                        if (!dragging) return;
                        dragging = false;
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', stopDragging);
                        document.body.classList.remove('select-none');
                        this._persistState();
                    };
                    resizer.addEventListener('mousedown', e => {
                        e.preventDefault();
                        dragging = true;
                        startX = e.clientX;
                        startWidth = sidebar.getBoundingClientRect().width;
                        document.addEventListener('mousemove', onMouseMove);
                        document.addEventListener('mouseup', stopDragging);
                        document.body.classList.add('select-none');
                    });
                }
                _attachEvents() {
                    if (!this.element) return;
                    const upBtn = this.element.querySelector('[data-action="navigate-up"]');
                    const rootBtn = this.element.querySelector('[data-action="navigate-root"]');
                    const listBtn = this.element.querySelector('[data-action="view-list"]');
                    const gridBtn = this.element.querySelector('[data-action="view-grid"]');
                    const searchInput = this.element.querySelector('.finder-search');
                    const sortToggleBtn = this.element.querySelector('[data-action="toggle-sort"]');
                    const sortMenu = this.element.querySelector('.finder-sort-menu');
                    const favoriteBtn = this.element.querySelector(
                        '[data-action="toggle-favorite"]'
                    );
                    upBtn == null
                        ? void 0
                        : upBtn.addEventListener('click', () => this.navigateUp());
                    rootBtn == null
                        ? void 0
                        : rootBtn.addEventListener('click', () => this.goRoot());
                    listBtn == null
                        ? void 0
                        : listBtn.addEventListener('click', () => this.setViewMode('list'));
                    gridBtn == null
                        ? void 0
                        : gridBtn.addEventListener('click', () => this.setViewMode('grid'));
                    searchInput == null
                        ? void 0
                        : searchInput.addEventListener('input', e => {
                              this.searchTerm = e.target.value;
                              this.renderContent();
                          });
                    sortToggleBtn == null
                        ? void 0
                        : sortToggleBtn.addEventListener('click', () => {
                              sortMenu == null ? void 0 : sortMenu.classList.toggle('hidden');
                          });
                    sortMenu == null
                        ? void 0
                        : sortMenu.querySelectorAll('[data-sort]').forEach(btn => {
                              btn.addEventListener('click', () => {
                                  const sortBy = btn.dataset.sort;
                                  this.setSortBy(sortBy);
                                  sortMenu.classList.add('hidden');
                              });
                          });
                    sortMenu == null
                        ? void 0
                        : sortMenu.querySelectorAll('[data-order]').forEach(btn => {
                              btn.addEventListener('click', () => {
                                  const order = btn.dataset.order;
                                  this.setSortOrder(order);
                                  sortMenu.classList.add('hidden');
                              });
                          });
                    document.addEventListener('click', e => {
                        if (
                            !(sortToggleBtn == null ? void 0 : sortToggleBtn.contains(e.target)) &&
                            !(sortMenu == null ? void 0 : sortMenu.contains(e.target))
                        ) {
                            sortMenu == null ? void 0 : sortMenu.classList.add('hidden');
                        }
                    });
                    favoriteBtn == null
                        ? void 0
                        : favoriteBtn.addEventListener('click', () => {
                              if (this.currentPath.length > 0) {
                                  this.toggleFavorite(this.currentPath.join('/'));
                              }
                          });
                }
                _attachSidebarEvents() {
                    if (!this.element) return;
                    const sidebarButtons = this.element.querySelectorAll('[data-sidebar-action]');
                    sidebarButtons.forEach(btn => {
                        btn.addEventListener('click', () => {
                            const action = btn.dataset.sidebarAction;
                            if (action === 'home') {
                                this.source = 'computer';
                                this.currentPath = ['home', 'marvin'];
                                this._persistState();
                                this._renderAll();
                            } else if (action === 'computer') {
                                this.source = 'computer';
                                this.goRoot();
                            } else if (action === 'github') {
                                this.source = 'github';
                                this.goRoot();
                            } else if (action === 'recent') {
                                this.source = 'recent';
                                this.goRoot();
                            } else if (action === 'starred') {
                                this.source = 'starred';
                                this.goRoot();
                            }
                            this._updateSidebarActiveHighlight();
                        });
                    });
                }
                _setupContentEventHandlers() {
                    var _a, _b;
                    if (this._eventHandlersAttached) {
                        return;
                    }
                    const resolveItemEl = evt => {
                        const node = evt.target;
                        let el = null;
                        if (node && node.closest) {
                            el = node.closest('[data-item-index]');
                        } else if (node && node.parentElement) {
                            el = node.parentElement.closest('[data-item-index]');
                        }
                        return el;
                    };
                    (_a = this.dom.content) == null
                        ? void 0
                        : _a.addEventListener('click', e => {
                              const itemEl = resolveItemEl(e);
                              if (!itemEl) return;
                              const idx = parseInt(itemEl.dataset.itemIndex || '-1', 10);
                              const item = this._renderedItems[idx];
                              if (!item) return;
                              this._selectItem(item.name);
                          });
                    (_b = this.dom.content) == null
                        ? void 0
                        : _b.addEventListener('dblclick', e => {
                              const itemEl = resolveItemEl(e);
                              if (!itemEl) return;
                              const idx = parseInt(itemEl.dataset.itemIndex || '-1', 10);
                              const item = this._renderedItems[idx];
                              if (!item) return;
                              void this.openItem(item.name, item.type);
                          });
                    this._eventHandlersAttached = true;
                }
                _renderAll() {
                    this._saveScrollPosition();
                    this.renderBreadcrumbs();
                    this.renderContent();
                    this._updateSidebarActiveHighlight();
                    this._restoreScrollPosition();
                    requestAnimationFrame(() => {
                        this._restoreScrollPosition();
                    });
                    setTimeout(() => {
                        this._restoreScrollPosition();
                    }, 0);
                }
                renderBreadcrumbs() {
                    if (!this.dom.breadcrumbs) return;
                    this._updateTabLabel();
                    const parts = [];
                    const viewLabel = this.source === 'github' ? 'GitHub' : 'Computer';
                    parts.push(
                        `<button class="finder-breadcrumb-item" data-action="goRoot">${viewLabel}</button>`
                    );
                    this.currentPath.forEach((part, index) => {
                        if (this.source === 'computer' && index === 0 && part === ROOT_FOLDER_NAME)
                            return;
                        const pathUpToHere = this.currentPath.slice(0, index + 1).join('/');
                        parts.push('<span class="finder-breadcrumb-separator">\u203A</span>');
                        parts.push(
                            `<button class="finder-breadcrumb-item" data-action="goto" data-path="${pathUpToHere}">${part}</button>`
                        );
                    });
                    this.dom.breadcrumbs.innerHTML = parts.join('');
                    this.dom.breadcrumbs
                        .querySelectorAll('button[data-action="goto"]')
                        .forEach(btn => {
                            btn.addEventListener('click', () => {
                                const path = btn.dataset.path || '';
                                const parts2 = path.split('/').filter(Boolean);
                                this.navigateToPath(parts2);
                            });
                        });
                    const rootBtn = this.dom.breadcrumbs.querySelector(
                        'button[data-action="goRoot"]'
                    );
                    if (rootBtn) rootBtn.addEventListener('click', () => this.goRoot());
                }
                /**
                 * Synchronisiert den aktiven Sidebar-Eintrag mit der aktuellen Quelle/Route.
                 * Regeln:
                 * - source=github  GitHub aktiv
                 * - source=recent  Zuletzt verwendet aktiv
                 * - source=starred  Markiert aktiv
                 * - source=computer  Wenn Pfad mit 'home' beginnt  Home aktiv, sonst Computer
                 */
                _updateSidebarActiveHighlight() {
                    if (!this.element) return;
                    const sidebarButtons = this.element.querySelectorAll('[data-sidebar-action]');
                    sidebarButtons.forEach(b => b.classList.remove('finder-sidebar-active'));
                    let toActivate = null;
                    switch (this.source) {
                        case 'github':
                            toActivate = '#finder-sidebar-github';
                            break;
                        case 'recent':
                            toActivate = '#finder-sidebar-recent';
                            break;
                        case 'starred':
                            toActivate = '#finder-sidebar-starred';
                            break;
                        case 'computer':
                        default: {
                            const atHome =
                                this.currentPath.length > 0 && this.currentPath[0] === 'home';
                            toActivate = atHome
                                ? '#finder-sidebar-home'
                                : '#finder-sidebar-computer';
                            break;
                        }
                    }
                    if (toActivate) {
                        const el = this.element.querySelector(toActivate);
                        el == null ? void 0 : el.classList.add('finder-sidebar-active');
                    }
                }
                renderContent() {
                    if (!this.dom.content) return;
                    let items = [];
                    if (this.source === 'github') {
                        void this.renderGithubContent();
                        return;
                    } else if (this.source === 'recent') {
                        items = this.getRecentItems();
                    } else if (this.source === 'starred') {
                        items = this.getFavoriteItems();
                    } else {
                        items = this.getComputerItems();
                    }
                    const filtered = this.filterItems(items, this.searchTerm);
                    const sorted = this.source === 'recent' ? filtered : this.sortItems(filtered);
                    switch (this.viewMode) {
                        case 'list':
                            this.renderListView(sorted);
                            break;
                        case 'grid':
                            this.renderGridView(sorted);
                            break;
                    }
                }
                getComputerItems() {
                    const path = this.currentPath.length === 0 ? '/' : this.currentPath;
                    const items = VirtualFS.list(path);
                    return Object.entries(items).map(([name, item]) => ({
                        name,
                        type: item.type,
                        icon: item.icon || (item.type === 'folder' ? '\u{1F4C1}' : '\u{1F4C4}'),
                        size: item.size || 0,
                        modified: item.modified || /* @__PURE__ */ new Date().toISOString(),
                    }));
                }
                sortItems(items) {
                    const sorted = [...items];
                    sorted.sort((a, b) => {
                        if (a.type === 'folder' && b.type !== 'folder') return -1;
                        if (a.type !== 'folder' && b.type === 'folder') return 1;
                        let comparison = 0;
                        switch (this.sortBy) {
                            case 'name':
                                comparison = a.name.localeCompare(b.name);
                                break;
                            case 'size':
                                comparison = (a.size || 0) - (b.size || 0);
                                break;
                            case 'date': {
                                const aTime = a.modified ? Date.parse(a.modified) : 0;
                                const bTime = b.modified ? Date.parse(b.modified) : 0;
                                comparison = bTime - aTime;
                                break;
                            }
                            case 'type':
                                comparison = (a.type || '').localeCompare(b.type || '');
                                break;
                        }
                        return this.sortOrder === 'asc' ? comparison : -comparison;
                    });
                    return sorted;
                }
                renderListView(items) {
                    this._renderedItems = items;
                    const rows = items
                        .map(
                            (item, i) => `
            <tr class="finder-list-item ${this.selectedItems.has(item.name) ? 'bg-blue-100 dark:bg-blue-900' : ''}" data-item-index="${i}" data-item-name="${item.name}" data-item-type="${item.type}"${item.path ? ` data-item-path="${item.path}"` : ''}>
                <td class="pr-2">
                  <div class="flex items-center gap-2 min-w-0">
                    <span class="finder-item-icon shrink-0">${item.icon || ''}</span>
                    <span class="truncate block min-w-0">${item.name}</span>
                  </div>
                </td>
                <td class="text-right whitespace-nowrap pl-2 pr-2">${this.formatSize(item.size)}</td>
                <td class="text-right text-gray-500 dark:text-gray-400 whitespace-nowrap pl-2">${this.formatDate(item.modified)}</td>
            </tr>
        `
                        )
                        .join('');
                    this.dom.content.innerHTML = `
            <div class="p-2">
                <table class="finder-list-table table-fixed w-full">
                    <colgroup>
                        <col />
                        <col class="w-28" />
                        <col class="w-40" />
                    </colgroup>
                    <thead>
                        <tr class="text-left">
                            <th class="font-medium">Name</th>
                            <th class="text-right font-medium">Gr\xF6\xDFe</th>
                            <th class="text-right font-medium">Ge\xE4ndert</th>
                        </tr>
                    </thead>
                    <tbody>${rows}</tbody>
                </table>
            </div>
        `;
                }
                renderGridView(items) {
                    this._renderedItems = items;
                    const tiles = items
                        .map(
                            (item, i) => `
            <div class="finder-grid-item ${this.selectedItems.has(item.name) ? 'ring-2 ring-blue-500 ring-offset-2 dark:ring-offset-gray-900 bg-blue-100/60 dark:bg-blue-900/40' : ''} min-w-0 p-3 rounded" data-item-index="${i}" data-item-name="${item.name}" data-item-type="${item.type}"${item.path ? ` data-item-path="${item.path}"` : ''}>
                <div class="finder-grid-icon text-2xl mb-2">${item.icon || ''}</div>
                <div class="finder-grid-name truncate text-sm">${item.name}</div>
            </div>
        `
                        )
                        .join('');
                    this.dom.content.innerHTML = `
            <div class="finder-grid-container grid grid-cols-[repeat(auto-fill,minmax(160px,1fr))] gap-3 p-3">${tiles}</div>
        `;
                }
                formatSize(size) {
                    if (!size) return '-';
                    const units = ['B', 'KB', 'MB', 'GB'];
                    let idx = 0;
                    let val = size;
                    while (val > 1024 && idx < units.length - 1) {
                        val /= 1024;
                        idx++;
                    }
                    return `${val.toFixed(1)} ${units[idx]}`;
                }
                formatDate(d) {
                    if (!d) return '-';
                    try {
                        const dt = new Date(d);
                        return dt.toLocaleString();
                    } catch {
                        return d;
                    }
                }
                _selectItem(name) {
                    const wasSelected = this.selectedItems.has(name);
                    this.selectedItems.clear();
                    if (!wasSelected) {
                        this.selectedItems.add(name);
                    }
                    if (this.dom.content) {
                        const allItems = this.dom.content.querySelectorAll('[data-item-name]');
                        allItems.forEach(el => {
                            const itemName = el.dataset.itemName;
                            const isSelected = this.selectedItems.has(itemName || '');
                            if (this.viewMode === 'list') {
                                if (isSelected) {
                                    el.classList.add('bg-blue-100', 'dark:bg-blue-900');
                                } else {
                                    el.classList.remove('bg-blue-100', 'dark:bg-blue-900');
                                }
                            } else {
                                if (isSelected) {
                                    el.classList.add(
                                        'ring-2',
                                        'ring-blue-500',
                                        'ring-offset-2',
                                        'dark:ring-offset-gray-900',
                                        'bg-blue-100/60',
                                        'dark:bg-blue-900/40'
                                    );
                                } else {
                                    el.classList.remove(
                                        'ring-2',
                                        'ring-blue-500',
                                        'ring-offset-2',
                                        'dark:ring-offset-gray-900',
                                        'bg-blue-100/60',
                                        'dark:bg-blue-900/40'
                                    );
                                }
                            }
                        });
                    }
                }
                async openItem(name, type) {
                    if (type === 'folder') {
                        this.navigateToFolder(name);
                    } else {
                        if (this.source === 'recent') {
                            const item = this._renderedItems.find(i => i.name === name);
                            if (item == null ? void 0 : item.path) {
                                this.navigateToRecentFile(item.path);
                                return;
                            }
                        }
                        if (this.source !== 'recent') {
                            this.addToRecent(name);
                        }
                        this._saveScrollPosition();
                        this._selectItem(name);
                        const ext = (name.split('.').pop() || '').toLowerCase();
                        const textExts = /* @__PURE__ */ new Set([
                            'md',
                            'txt',
                            'js',
                            'ts',
                            'json',
                            'html',
                            'htm',
                            'css',
                            'py',
                            'java',
                            'c',
                            'cpp',
                            'h',
                            'cs',
                            'rs',
                            'go',
                            'rb',
                            'php',
                            'yml',
                            'yaml',
                            'xml',
                            'sh',
                            'bash',
                        ]);
                        const imageExts = /* @__PURE__ */ new Set([
                            'jpg',
                            'jpeg',
                            'png',
                            'gif',
                            'webp',
                            'svg',
                            'bmp',
                            'ico',
                            'tiff',
                        ]);
                        const pdfExts = /* @__PURE__ */ new Set(['pdf']);
                        const openInTextEditor = (fileName, content, meta) => {
                            var _a, _b;
                            try {
                                const W = window;
                                let editorWindow = null;
                                if (
                                    W.WindowRegistry &&
                                    typeof W.WindowRegistry.getWindowsByType === 'function'
                                ) {
                                    const existing =
                                        W.WindowRegistry.getWindowsByType('text-editor');
                                    if (existing && existing.length > 0) {
                                        editorWindow = existing[0];
                                    }
                                }
                                if (
                                    !editorWindow &&
                                    W.TextEditorWindow &&
                                    typeof W.TextEditorWindow.create === 'function'
                                ) {
                                    editorWindow = W.TextEditorWindow.create();
                                }
                                if (
                                    editorWindow &&
                                    typeof editorWindow.createDocument === 'function'
                                ) {
                                    const existingTabs = Array.from(editorWindow.tabs.values());
                                    const existingTab = existingTabs.find(
                                        tab => tab.title === fileName
                                    );
                                    if (existingTab) {
                                        editorWindow.setActiveTab(existingTab.id);
                                        (_a = editorWindow.bringToFront) == null
                                            ? void 0
                                            : _a.call(editorWindow);
                                    } else {
                                        const newDoc = editorWindow.createDocument(
                                            fileName,
                                            content
                                        );
                                        if (newDoc && newDoc.id) {
                                            editorWindow.setActiveTab(newDoc.id);
                                        }
                                        (_b = editorWindow.bringToFront) == null
                                            ? void 0
                                            : _b.call(editorWindow);
                                    }
                                    return true;
                                }
                                if (
                                    W.TextEditorSystem &&
                                    typeof W.TextEditorSystem.loadRemoteFile === 'function'
                                ) {
                                    W.TextEditorSystem.loadRemoteFile({
                                        content,
                                        fileName,
                                        repo: meta == null ? void 0 : meta.repo,
                                        path: meta == null ? void 0 : meta.path,
                                    });
                                    return true;
                                }
                            } catch (e) {
                                console.warn('[FinderView] Failed to open in text editor:', e);
                            }
                            return false;
                        };
                        if (this.source === 'computer') {
                            try {
                                const pathParts =
                                    this.currentPath.length > 0
                                        ? [...this.currentPath, name]
                                        : [name];
                                const content = VirtualFS.readFile(pathParts);
                                if (content !== null && textExts.has(ext)) {
                                    openInTextEditor(name, content);
                                    return;
                                }
                            } catch (e) {
                                console.warn('[FinderView] VirtualFS read failed:', e);
                            }
                        }
                        if (this.source === 'github') {
                            const API2 = this.getAPI();
                            const username = this.getGithubUsername();
                            const repo = this.currentPath[0];
                            const subPath = this.currentPath.slice(1).concat(name).join('/');
                            const maybe = this.lastGithubItemsMap.get(name);
                            if (maybe && maybe.download_url) {
                                try {
                                    if (imageExts.has(ext)) {
                                        const url = maybe.download_url;
                                        try {
                                            const resp = await fetch(url);
                                            if (resp.ok) {
                                                const blob = await resp.blob();
                                                const obj = URL.createObjectURL(blob);
                                                if (
                                                    preview_instance_manager_default &&
                                                    typeof preview_instance_manager_default.openImages ===
                                                        'function'
                                                ) {
                                                    preview_instance_manager_default.openImages(
                                                        [obj],
                                                        0,
                                                        subPath
                                                    );
                                                } else {
                                                    window.open(url, '_blank');
                                                }
                                                return;
                                            } else {
                                                window.open(url, '_blank');
                                                this._renderAll();
                                                return;
                                            }
                                        } catch (efetch) {
                                            console.warn(
                                                '[FinderView] fetch of download_url failed, falling back to open:',
                                                efetch
                                            );
                                            window.open(url, '_blank');
                                            this._renderAll();
                                            return;
                                        }
                                        this._renderAll();
                                        return;
                                    }
                                    if (pdfExts.has(ext)) {
                                        window.open(maybe.download_url, '_blank');
                                        this._renderAll();
                                        return;
                                    }
                                } catch (eurl) {
                                    console.warn(
                                        '[FinderView] failed to open maybe.download_url:',
                                        eurl
                                    );
                                }
                            }
                            try {
                                if (maybe && maybe.content) {
                                    const raw =
                                        maybe.encoding === 'base64'
                                            ? atob((maybe.content || '').replace(/\n/g, ''))
                                            : maybe.content;
                                    if (textExts.has(ext)) {
                                        openInTextEditor(name, raw, { repo, path: subPath });
                                        return;
                                    }
                                    try {
                                        if (imageExts.has(ext)) {
                                            const b64 =
                                                maybe.encoding === 'base64'
                                                    ? (maybe.content || '').replace(/\n/g, '')
                                                    : '';
                                            if (b64) {
                                                const bytes = atob(b64);
                                                const arr = new Uint8Array(bytes.length);
                                                for (let i = 0; i < bytes.length; i++)
                                                    arr[i] = bytes.charCodeAt(i);
                                                const mimeMap = {
                                                    jpg: 'image/jpeg',
                                                    jpeg: 'image/jpeg',
                                                    png: 'image/png',
                                                    gif: 'image/gif',
                                                    webp: 'image/webp',
                                                    svg: 'image/svg+xml',
                                                    bmp: 'image/bmp',
                                                    ico: 'image/x-icon',
                                                    tiff: 'image/tiff',
                                                };
                                                const mime =
                                                    mimeMap[ext] || 'application/octet-stream';
                                                const blob = new Blob([arr], { type: mime });
                                                const url = URL.createObjectURL(blob);
                                                if (
                                                    preview_instance_manager_default &&
                                                    typeof preview_instance_manager_default.openImages ===
                                                        'function'
                                                ) {
                                                    preview_instance_manager_default.openImages(
                                                        [url],
                                                        0,
                                                        subPath
                                                    );
                                                } else {
                                                    window.open(url, '_blank');
                                                }
                                                return;
                                            }
                                        }
                                        if (pdfExts.has(ext)) {
                                            const b64 =
                                                maybe.encoding === 'base64'
                                                    ? (maybe.content || '').replace(/\n/g, '')
                                                    : '';
                                            if (b64) {
                                                const bytes = atob(b64);
                                                const arr = new Uint8Array(bytes.length);
                                                for (let i = 0; i < bytes.length; i++)
                                                    arr[i] = bytes.charCodeAt(i);
                                                const blob = new Blob([arr], {
                                                    type: 'application/pdf',
                                                });
                                                const url = URL.createObjectURL(blob);
                                                window.open(url, '_blank');
                                                return;
                                            }
                                        }
                                    } catch (eimg) {
                                        console.warn(
                                            '[FinderView] failed to open embedded object:',
                                            eimg
                                        );
                                    }
                                }
                                if (API2 && typeof API2.fetchRepoContents === 'function') {
                                    this.dom.content.innerHTML =
                                        '<div class="p-4 text-sm opacity-80">Lade Datei\u2026</div>';
                                    const fileObj = await API2.fetchRepoContents(
                                        username,
                                        repo,
                                        subPath
                                    );
                                    if (fileObj && fileObj.download_url) {
                                        try {
                                            if (imageExts.has(ext)) {
                                                const url = fileObj.download_url;
                                                try {
                                                    const resp = await fetch(url);
                                                    if (resp.ok) {
                                                        const blob = await resp.blob();
                                                        const obj = URL.createObjectURL(blob);
                                                        preview_instance_manager_default.openImages(
                                                            [obj],
                                                            0,
                                                            subPath
                                                        );
                                                        this._renderAll();
                                                        return;
                                                    }
                                                } catch (ef) {
                                                    console.warn(
                                                        '[FinderView] failed to fetch image download_url:',
                                                        ef
                                                    );
                                                }
                                                window.open(fileObj.download_url, '_blank');
                                                this._renderAll();
                                                return;
                                            }
                                            if (pdfExts.has(ext)) {
                                                window.open(fileObj.download_url, '_blank');
                                                this._renderAll();
                                                return;
                                            }
                                        } catch (eurl) {
                                            console.warn(
                                                '[FinderView] failed to open download_url:',
                                                eurl
                                            );
                                        }
                                    }
                                    if (
                                        fileObj &&
                                        fileObj.content &&
                                        fileObj.encoding === 'base64'
                                    ) {
                                        const rawBase64 = (fileObj.content || '').replace(
                                            /\n/g,
                                            ''
                                        );
                                        const rawText = atob(rawBase64);
                                        if (textExts.has(ext)) {
                                            openInTextEditor(name, rawText, {
                                                repo,
                                                path: subPath,
                                            });
                                            this._renderAll();
                                            return;
                                        }
                                        try {
                                            if (imageExts.has(ext)) {
                                                const bytes = atob(rawBase64);
                                                const arr = new Uint8Array(bytes.length);
                                                for (let i = 0; i < bytes.length; i++)
                                                    arr[i] = bytes.charCodeAt(i);
                                                const mimeMap = {
                                                    jpg: 'image/jpeg',
                                                    jpeg: 'image/jpeg',
                                                    png: 'image/png',
                                                    gif: 'image/gif',
                                                    webp: 'image/webp',
                                                    svg: 'image/svg+xml',
                                                    bmp: 'image/bmp',
                                                    ico: 'image/x-icon',
                                                    tiff: 'image/tiff',
                                                };
                                                const mime =
                                                    mimeMap[ext] || 'application/octet-stream';
                                                const blob = new Blob([arr], { type: mime });
                                                const url = URL.createObjectURL(blob);
                                                if (
                                                    preview_instance_manager_default &&
                                                    typeof preview_instance_manager_default.openImages ===
                                                        'function'
                                                ) {
                                                    preview_instance_manager_default.openImages(
                                                        [url],
                                                        0,
                                                        subPath
                                                    );
                                                } else {
                                                    window.open(url, '_blank');
                                                }
                                                this._renderAll();
                                                return;
                                            }
                                            if (pdfExts.has(ext)) {
                                                const bytes = atob(rawBase64);
                                                const arr = new Uint8Array(bytes.length);
                                                for (let i = 0; i < bytes.length; i++)
                                                    arr[i] = bytes.charCodeAt(i);
                                                const blob = new Blob([arr], {
                                                    type: 'application/pdf',
                                                });
                                                const url = URL.createObjectURL(blob);
                                                window.open(url, '_blank');
                                                this._renderAll();
                                                return;
                                            }
                                        } catch (e2) {
                                            console.warn(
                                                '[FinderView] Failed to open binary file:',
                                                e2
                                            );
                                        }
                                    } else {
                                        const raw = fileObj ? fileObj.content || '' : '';
                                        if (textExts.has(ext)) {
                                            openInTextEditor(name, raw, { repo, path: subPath });
                                            this._renderAll();
                                            return;
                                        }
                                    }
                                }
                            } catch (e) {
                                console.warn('[FinderView] Failed to load GitHub file:', e);
                                this._renderAll();
                            }
                        }
                    }
                }
                /**
                 * Navigate to a recent file's original location
                 */
                navigateToRecentFile(fullPath) {
                    const parts = fullPath.split('/').filter(Boolean);
                    if (parts.length === 0) return;
                    const fileName = parts[parts.length - 1];
                    if (!fileName) return;
                    const folderParts = parts.slice(0, -1);
                    this.source = 'computer';
                    this.currentPath = folderParts;
                    this._persistState();
                    this._renderAll();
                    this._selectItem(fileName);
                }
                navigateToFolder(name) {
                    if (this.source === 'github') {
                        this.currentPath = [...this.currentPath, name];
                        this._persistState();
                        this._renderAll();
                        return;
                    }
                    const targetPath =
                        this.currentPath.length === 0 ? name : [...this.currentPath, name];
                    const folder = VirtualFS.getFolder(targetPath);
                    if (folder) {
                        this.currentPath = [...this.currentPath, name];
                        this._persistState();
                        this._renderAll();
                    }
                }
                navigateUp() {
                    if (this.currentPath.length === 0) return;
                    this.currentPath = this.currentPath.slice(0, -1);
                    this._persistState();
                    this._renderAll();
                }
                goRoot() {
                    this.currentPath = [];
                    this._persistState();
                    this._renderAll();
                }
                navigateToPath(parts) {
                    this.currentPath = parts;
                    this._persistState();
                    this._renderAll();
                }
                setViewMode(mode) {
                    this.viewMode = mode;
                    this.updateContentState({ viewMode: this.viewMode });
                    this.renderContent();
                }
                setSortBy(sortBy) {
                    this.sortBy = sortBy;
                    this._persistState();
                    this.renderContent();
                }
                setSortOrder(order) {
                    this.sortOrder = order;
                    this._persistState();
                    this.renderContent();
                }
                // --- Favorites System ---
                toggleFavorite(path) {
                    if (this.favorites.has(path)) {
                        this.favorites.delete(path);
                    } else {
                        this.favorites.add(path);
                    }
                    this._persistState();
                    this.renderContent();
                }
                getFavoriteItems() {
                    const items = [];
                    for (const path of this.favorites) {
                        const parts = path.split('/');
                        const name = parts[parts.length - 1] || 'Unknown';
                        items.push({
                            name,
                            type: 'folder',
                            icon: '\u2B50',
                            modified: /* @__PURE__ */ new Date().toISOString(),
                        });
                    }
                    return items;
                }
                /**
                 * Load recent files from global storage
                 */
                static loadRecentFiles() {
                    try {
                        const stored = localStorage.getItem(_FinderView.RECENT_FILES_KEY);
                        if (stored) {
                            return JSON.parse(stored);
                        }
                    } catch (e) {
                        console.warn('[FinderView] Failed to load recent files:', e);
                    }
                    return _FinderView.getDefaultRecentFiles();
                }
                /**
                 * Save recent files to global storage
                 */
                static saveRecentFiles(files) {
                    try {
                        localStorage.setItem(_FinderView.RECENT_FILES_KEY, JSON.stringify(files));
                    } catch (e) {
                        console.warn('[FinderView] Failed to save recent files:', e);
                    }
                }
                /**
                 * Get default recent files (with examples)
                 */
                static getDefaultRecentFiles() {
                    const now = /* @__PURE__ */ new Date().toISOString();
                    const yesterday = new Date(Date.now() - 864e5).toISOString();
                    const twoDaysAgo = new Date(Date.now() - 1728e5).toISOString();
                    return [
                        {
                            name: 'README.md',
                            path: 'home/marvin/README.md',
                            icon: '\u{1F4DD}',
                            modified: now,
                        },
                        {
                            name: 'notes.txt',
                            path: 'home/marvin/Documents/notes.txt',
                            icon: '\u{1F4DD}',
                            modified: yesterday,
                        },
                        {
                            name: 'project-plan.md',
                            path: 'home/marvin/Documents/project-plan.md',
                            icon: '\u{1F4DD}',
                            modified: twoDaysAgo,
                        },
                    ];
                }
                addToRecent(name) {
                    var _a;
                    const pathParts = this.source === 'computer' ? this.currentPath : [];
                    const fullPath = pathParts.length > 0 ? pathParts.join('/') + '/' + name : name;
                    const ext =
                        ((_a = name.split('.').pop()) == null ? void 0 : _a.toLowerCase()) || '';
                    let icon = '\u{1F4C4}';
                    if (['md', 'txt'].includes(ext)) icon = '\u{1F4DD}';
                    else if (['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(ext))
                        icon = '\u{1F5BC}\uFE0F';
                    else if (['pdf'].includes(ext)) icon = '\uFFFD';
                    else if (['zip', 'tar', 'gz'].includes(ext)) icon = '\uFFFD';
                    const recentFile = {
                        name,
                        path: fullPath,
                        icon,
                        modified: /* @__PURE__ */ new Date().toISOString(),
                    };
                    const recentFiles = _FinderView.loadRecentFiles();
                    const filtered = recentFiles.filter(f => f.path !== fullPath);
                    filtered.unshift(recentFile);
                    const limited = filtered.slice(0, _FinderView.MAX_RECENT_FILES);
                    _FinderView.saveRecentFiles(limited);
                    this.recentFiles = limited;
                    this._persistState();
                }
                getRecentItems() {
                    const recentFiles = _FinderView.loadRecentFiles();
                    return recentFiles.map(rf => ({
                        name: rf.name,
                        type: 'file',
                        icon: rf.icon,
                        modified: rf.modified,
                        // Store path in a data attribute for navigation
                        path: rf.path,
                    }));
                }
                // --- Search Function ---
                filterItems(items, searchTerm) {
                    if (!searchTerm || searchTerm.trim() === '') {
                        return items;
                    }
                    const term = searchTerm.toLowerCase();
                    return items.filter(item => item.name.toLowerCase().includes(term));
                }
                // --- State Persistence ---
                _persistState() {
                    var _a, _b;
                    this.contentState = {
                        currentPath: this.currentPath,
                        viewMode: this.viewMode,
                        sortBy: this.sortBy,
                        sortOrder: this.sortOrder,
                        favorites: Array.from(this.favorites),
                        recentFiles: this.recentFiles,
                        sidebarWidth: this.sidebarWidth,
                    };
                    this.metadata.modified = Date.now();
                    if (this.parentWindow) {
                        (_b = (_a = this.parentWindow)._saveState) == null ? void 0 : _b.call(_a);
                    }
                }
                /**
                 * Save current scroll position
                 */
                _saveScrollPosition() {
                    if (this.dom.content) {
                        this._savedScrollPosition = this.dom.content.scrollTop;
                    }
                }
                /**
                 * Restore saved scroll position
                 */
                _restoreScrollPosition() {
                    if (this.dom.content && this._savedScrollPosition > 0) {
                        requestAnimationFrame(() => {
                            if (this.dom.content) {
                                this.dom.content.scrollTop = this._savedScrollPosition;
                            }
                        });
                    }
                }
                /**
                 * Override show to restore scroll position
                 */
                show() {
                    super.show();
                    this._restoreScrollPosition();
                }
                /**
                 * Override hide to save scroll position
                 */
                hide() {
                    this._saveScrollPosition();
                    super.hide();
                }
                serialize() {
                    return {
                        ...super.serialize(),
                        source: this.source,
                        currentPath: this.currentPath,
                        viewMode: this.viewMode,
                        sortBy: this.sortBy,
                        sortOrder: this.sortOrder,
                        favorites: Array.from(this.favorites),
                        recentFiles: this.recentFiles,
                    };
                }
                static deserialize(state) {
                    var _a, _b, _c;
                    const view = new _FinderView({
                        id: state.id,
                        title: state.title || (state.source === 'github' ? 'GitHub' : 'Computer'),
                        icon: state.icon || (state.source === 'github' ? '\u{1F4E6}' : '\u{1F4BB}'),
                        source: state.source || 'computer',
                        content: {
                            ...state.contentState,
                            favorites:
                                state.favorites ||
                                ((_a = state.contentState) == null ? void 0 : _a.favorites) ||
                                [],
                            recentFiles:
                                state.recentFiles ||
                                ((_b = state.contentState) == null ? void 0 : _b.recentFiles) ||
                                [],
                            sidebarWidth:
                                state.sidebarWidth ||
                                ((_c = state.contentState) == null ? void 0 : _c.sidebarWidth) ||
                                192,
                        },
                    });
                    view.currentPath = state.currentPath || [];
                    view.viewMode = state.viewMode || 'list';
                    view.sortBy = state.sortBy || 'name';
                    view.sortOrder = state.sortOrder || 'asc';
                    return view;
                }
                // --- GitHub Integration ---
                getGithubUsername() {
                    const w = window;
                    return w.GITHUB_USERNAME || 'Marormur';
                }
                getAPI() {
                    const w = window;
                    return w.GitHubAPI || null;
                }
                async renderGithubContent() {
                    if (!this.dom.content) return;
                    const API2 = this.getAPI();
                    const username = this.getGithubUsername();
                    this.dom.content.innerHTML =
                        '<div class="p-4 text-sm opacity-80">Lade GitHub\u2026</div>';
                    if (!API2) {
                        this.dom.content.innerHTML =
                            '<div class="p-4 text-sm text-red-500">GitHubAPI nicht geladen</div>';
                        return;
                    }
                    try {
                        if (this.currentPath.length === 0) {
                            const cacheKey = 'repos';
                            let repos;
                            const cached = this._readGithubCache(cacheKey);
                            if (cached) {
                                repos = cached;
                            } else {
                                const apiCached = API2.readCache('repos');
                                repos =
                                    apiCached != null
                                        ? apiCached
                                        : await API2.fetchUserRepos(username);
                                if (!apiCached) API2.writeCache('repos', '', '', repos);
                                this._writeGithubCache(cacheKey, repos);
                            }
                            this.githubRepos = Array.isArray(repos) ? repos : [];
                            const items = this.githubRepos.map(repo => ({
                                name: repo.name,
                                type: 'folder',
                                icon: '\u{1F4E6}',
                            }));
                            this.lastGithubItemsMap.clear();
                            items.forEach(it => this.lastGithubItemsMap.set(it.name, it));
                            const filtered = this.filterItems(items, this.searchTerm);
                            this.renderListView(this.sortItems(filtered));
                        } else {
                            const repo = this.currentPath[0];
                            const subPath = this.currentPath.slice(1).join('/');
                            const cacheKey = `${repo}/${subPath}`;
                            let contents;
                            const cached = this._readGithubCache(cacheKey);
                            if (cached) {
                                contents = cached;
                            } else {
                                const apiCached = API2.readCache('contents', repo, subPath);
                                contents =
                                    apiCached != null
                                        ? apiCached
                                        : await API2.fetchRepoContents(username, repo, subPath);
                                if (!apiCached)
                                    API2.writeCache('contents', repo, subPath, contents);
                                this._writeGithubCache(cacheKey, contents);
                            }
                            const items = (Array.isArray(contents) ? contents : []).map(it => {
                                var _a;
                                return {
                                    name: it.name,
                                    type: it.type === 'dir' ? 'folder' : 'file',
                                    icon: it.type === 'dir' ? '\u{1F4C1}' : '\u{1F4C4}',
                                    size: (_a = it.size) != null ? _a : 0,
                                    modified: it.git_url ? void 0 : void 0,
                                };
                            });
                            this.lastGithubItemsMap.clear();
                            (Array.isArray(contents) ? contents : []).forEach(it =>
                                this.lastGithubItemsMap.set(it.name, it)
                            );
                            const filtered = this.filterItems(items, this.searchTerm);
                            this.renderListView(this.sortItems(filtered));
                        }
                    } catch (e) {
                        this.githubError = true;
                        this.githubErrorMessage =
                            (e == null ? void 0 : e.message) || 'Unbekannter Fehler';
                        this.dom.content.innerHTML = `<div class="p-4 text-sm text-red-500">GitHub Fehler: ${this.githubErrorMessage}</div>`;
                    }
                }
                // --- GitHub Cache Helpers ---
                /**
                 * Kleines InMemoryTTLCache pro FinderView. Verhindert bermige ReRenders
                 * und beschleunigt Navigieren zwischen Ordnern/Repos.
                 */
                _readGithubCache(key) {
                    const cached = this.githubContentCache.get(key);
                    if (!cached) return null;
                    const now = Date.now();
                    if (now - cached.timestamp > this.cacheTTL) {
                        this.githubContentCache.delete(key);
                        return null;
                    }
                    return cached.data;
                }
                /** Schreibt einen Eintrag in den InMemoryCache. */
                _writeGithubCache(key, data) {
                    this.githubContentCache.set(key, {
                        data,
                        timestamp: Date.now(),
                    });
                }
                /**
                 * Ermittelt den sichtbaren TabTitel: Am Root z. B. GitHub/Computer,
                 * ansonsten der letzte Pfadteil. Dadurch entspricht der Tab immer dem Kontext.
                 */
                _updateTabLabel() {
                    const w = window;
                    const t2 = (key, fb) =>
                        w.appI18n ? w.appI18n.translate(key, {}, { fallback: fb }) : fb;
                    let label = '';
                    const atRoot = this.currentPath.length === 0;
                    switch (this.source) {
                        case 'computer':
                            label = atRoot
                                ? t2('finder.sidebar.computer', 'Computer')
                                : this.currentPath[this.currentPath.length - 1];
                            break;
                        case 'github':
                            label = atRoot
                                ? 'GitHub'
                                : this.currentPath[this.currentPath.length - 1] || 'GitHub';
                            break;
                        case 'recent':
                            label = t2('finder.sidebar.recent', 'Zuletzt verwendet');
                            break;
                        case 'starred':
                            label = t2('finder.sidebar.starred', 'Markiert');
                            break;
                        default:
                            label = this.title || 'Finder';
                    }
                    if (this.title !== label) {
                        this.setTitle(label);
                    }
                }
            };
            // --- Recent Files System (Global Shared) ---
            _FinderView.RECENT_FILES_KEY = 'finder-recent-files';
            _FinderView.MAX_RECENT_FILES = 20;
            FinderView = _FinderView;
            window.FinderView = FinderView;
        },
    });

    // src/ts/apps/finder/finder-window.ts
    var FinderWindow;
    var init_finder_window = __esm({
        'src/ts/apps/finder/finder-window.ts'() {
            'use strict';
            init_base_window();
            FinderWindow = class _FinderWindow extends BaseWindow {
                constructor(config) {
                    super({
                        type: 'finder',
                        title: 'Finder',
                        ...config,
                    });
                }
                createDOM() {
                    const windowEl = super.createDOM();
                    const baseTabBar = windowEl.querySelector('.window-tab-bar');
                    if (baseTabBar) {
                        baseTabBar.remove();
                    }
                    if (this.contentElement) {
                        this.contentElement.remove();
                    }
                    const tabBar = document.createElement('div');
                    tabBar.id = `${this.id}-tabs`;
                    tabBar.className = 'window-tab-bar';
                    windowEl.appendChild(tabBar);
                    this.contentElement = document.createElement('div');
                    this.contentElement.id = `${this.id}-container`;
                    this.contentElement.className = 'flex-1 overflow-hidden flex';
                    windowEl.appendChild(this.contentElement);
                    return windowEl;
                }
                show() {
                    super.show();
                    this._renderTabs();
                }
                _renderTabs() {
                    this._doRenderTabs();
                }
                _doRenderTabs() {
                    const W = window;
                    if (!W.WindowTabs || !this.element) {
                        return;
                    }
                    const tabBar = this.element.querySelector(`#${this.id}-tabs`);
                    if (!tabBar) {
                        return;
                    }
                    tabBar.style.display = '';
                    const makeInst = tab => ({
                        instanceId: tab.id,
                        title: tab.title,
                        metadata: { tabLabel: tab.title },
                        __tab: tab,
                        show: () => tab.show(),
                        hide: () => tab.hide(),
                    });
                    const adapter = {
                        getAllInstances: () => Array.from(this.tabs.values()).map(makeInst),
                        getActiveInstance: () => {
                            const activeId = this.activeTabId;
                            const t2 = activeId ? this.tabs.get(activeId) : null;
                            return t2 ? makeInst(t2) : null;
                        },
                        getAllInstanceIds: () => Array.from(this.tabs.keys()),
                        getInstance: id => {
                            const t2 = this.tabs.get(id) || null;
                            return t2 ? makeInst(t2) : null;
                        },
                        setActiveInstance: id => this.setActiveTab(id),
                        createInstance: cfg => {
                            const view = W.FinderView
                                ? new W.FinderView({
                                      title: (cfg == null ? void 0 : cfg.title) || `Computer`,
                                      source: 'computer',
                                  })
                                : null;
                            if (view) {
                                this.addTab(view);
                                this.setActiveTab(view.id);
                                return makeInst(view);
                            }
                            return null;
                        },
                        destroyInstance: id => this.removeTab(id),
                        getInstanceCount: () => this.tabs.size,
                        reorderInstances: newOrder => {
                            const old = this.tabs;
                            const rebuilt = /* @__PURE__ */ new Map();
                            newOrder.forEach(id => {
                                const t2 = old.get(id);
                                if (t2) rebuilt.set(id, t2);
                            });
                            old.forEach((t2, id) => {
                                if (!rebuilt.has(id)) rebuilt.set(id, t2);
                            });
                            this.tabs = rebuilt;
                            this._renderTabs();
                        },
                        detachInstance: id => {
                            const t2 = this.detachTab(id);
                            return t2 ? makeInst(t2) : null;
                        },
                        adoptInstance: inst => {
                            const tab = inst.__tab || inst;
                            this.addTab(tab);
                            this.setActiveTab(tab.id);
                            return makeInst(tab);
                        },
                    };
                    if (this.tabController) {
                        this.tabController.destroy();
                    }
                    this.tabController = W.WindowTabs.create(adapter, tabBar, {
                        addButton: true,
                        onCreateInstanceTitle: () => `Tab ${this.tabs.size + 1}`,
                    });
                }
                createView(title) {
                    const W = window;
                    if (!W.FinderView) {
                        console.error('FinderView class not loaded');
                        return null;
                    }
                    const view = new W.FinderView({
                        title: title || `Computer`,
                        source: 'computer',
                    });
                    this.addTab(view);
                    return view;
                }
                createGithubView(title) {
                    const W = window;
                    if (!W.FinderView) {
                        console.error('FinderView class not loaded');
                        return null;
                    }
                    const view = new W.FinderView({
                        title: title || `GitHub`,
                        source: 'github',
                        icon: '\u{1F4E6}',
                    });
                    this.addTab(view);
                    return view;
                }
                static create(config) {
                    const window2 = new _FinderWindow(config);
                    window2.createView('Computer');
                    const W = globalThis;
                    if (W.WindowRegistry) W.WindowRegistry.registerWindow(window2);
                    window2.show();
                    return window2;
                }
                /**
                 * Focus existing Finder window or create new one (macOS-like Dock behavior)
                 * - If no Finder window exists, create a new one
                 * - If Finder windows exist, focus the most recently active one
                 */
                static focusOrCreate(config) {
                    const W = globalThis;
                    if (!W.WindowRegistry) {
                        return _FinderWindow.create(config);
                    }
                    const finderWindows = W.WindowRegistry.getWindowsByType('finder');
                    if (finderWindows.length === 0) {
                        return _FinderWindow.create(config);
                    }
                    let mostRecentWindow = finderWindows[0];
                    for (const win of finderWindows) {
                        if (win.zIndex > mostRecentWindow.zIndex) {
                            mostRecentWindow = win;
                        }
                    }
                    mostRecentWindow.bringToFront();
                    return mostRecentWindow;
                }
            };
            window.FinderWindow = FinderWindow;
        },
    });

    // src/ts/services/multi-window-session.ts
    var _MultiWindowSessionManager, MultiWindowSessionManager, multiWindowSessionManager;
    var init_multi_window_session = __esm({
        'src/ts/services/multi-window-session.ts'() {
            'use strict';
            init_window_registry();
            init_terminal_window();
            init_text_editor_window();
            init_finder_window();
            init_terminal_session();
            init_text_editor_document();
            init_finder_view();
            _MultiWindowSessionManager = class _MultiWindowSessionManager {
                constructor() {
                    // 2 seconds debounce
                    this.autoSaveTimer = null;
                    this.isRestoring = false;
                    this.initialized = false;
                }
                /**
                 * Initialize session manager
                 */
                init() {
                    if (this.initialized) return;
                    console.log('[MultiWindowSessionManager] Initializing...');
                    window.addEventListener('blur', () => {
                        this.saveSession({ immediate: true });
                    });
                    window.addEventListener('beforeunload', () => {
                        this.saveSessionImmediate();
                    });
                    document.addEventListener('visibilitychange', () => {
                        if (document.hidden) {
                            this.saveSession({ immediate: true });
                        }
                    });
                    this.initialized = true;
                    console.log('[MultiWindowSessionManager] Initialized');
                }
                /**
                 * Save current session to localStorage
                 */
                saveSession(options = {}) {
                    console.log('[MultiWindowSessionManager] saveSession called:', {
                        immediate: options.immediate,
                        isRestoring: this.isRestoring,
                    });
                    if (this.isRestoring) {
                        console.log('[MultiWindowSessionManager] Skipping save during restore');
                        return;
                    }
                    if (options.immediate) {
                        this.saveSessionImmediate();
                    } else {
                        this.scheduleAutoSave();
                    }
                }
                /**
                 * Save session immediately (bypasses debounce)
                 */
                saveSessionImmediate() {
                    console.log('[MultiWindowSessionManager] saveSessionImmediate called');
                    if (this.autoSaveTimer !== null) {
                        clearTimeout(this.autoSaveTimer);
                        this.autoSaveTimer = null;
                    }
                    try {
                        console.log('[MultiWindowSessionManager] Creating session snapshot...');
                        const session = this.createSession();
                        console.log('[MultiWindowSessionManager] Session created:', {
                            windows: session.windows.length,
                            totalTabs: session.windows.reduce((sum, w) => sum + w.tabs.length, 0),
                        });
                        const serialized = JSON.stringify(session);
                        console.log(
                            '[MultiWindowSessionManager] Session serialized, length:',
                            serialized.length
                        );
                        localStorage.setItem(_MultiWindowSessionManager.STORAGE_KEY, serialized);
                        console.log('[MultiWindowSessionManager] Session saved to localStorage');
                        console.log('[MultiWindowSessionManager] Session saved:', {
                            windows: session.windows.length,
                            totalTabs: session.windows.reduce((sum, w) => sum + w.tabs.length, 0),
                            isRestoring: this.isRestoring,
                        });
                    } catch (error) {
                        console.error('[MultiWindowSessionManager] Failed to save session:', error);
                        if (error instanceof Error) {
                            console.error('[MultiWindowSessionManager] Error stack:', error.stack);
                        }
                    }
                }
                /**
                 * Schedule auto-save (debounced)
                 */
                scheduleAutoSave() {
                    if (this.autoSaveTimer !== null) {
                        clearTimeout(this.autoSaveTimer);
                    }
                    this.autoSaveTimer = window.setTimeout(() => {
                        this.saveSessionImmediate();
                    }, _MultiWindowSessionManager.AUTO_SAVE_DELAY);
                }
                /**
                 * Create session object from current state
                 */
                createSession() {
                    const windows = window_registry_default.getAllWindows();
                    return {
                        version: _MultiWindowSessionManager.VERSION,
                        timestamp: Date.now(),
                        windows: windows.map(window2 => this.serializeWindow(window2)),
                        metadata: {
                            theme: this.getCurrentTheme(),
                            language: this.getCurrentLanguage(),
                        },
                    };
                }
                /**
                 * Serialize a window and all its tabs
                 */
                serializeWindow(window2) {
                    const tabs = Array.from(window2.tabs.values());
                    return {
                        id: window2.id,
                        type: window2.type,
                        position: { ...window2.position },
                        zIndex: window2.zIndex,
                        isMinimized: window2.isMinimized,
                        isMaximized: window2.isMaximized,
                        activeTabId: window2.activeTabId,
                        tabs: tabs.map(tab => this.serializeTab(tab)),
                        metadata: window2.metadata,
                    };
                }
                /**
                 * Serialize a tab
                 */
                serializeTab(tab) {
                    var _a, _b;
                    if (typeof tab.serialize === 'function') {
                        return tab.serialize();
                    }
                    return {
                        id: tab.id,
                        type: tab.type,
                        title: tab.title,
                        icon: tab.icon,
                        contentState: tab.contentState || {},
                        created: ((_a = tab.metadata) == null ? void 0 : _a.created) || Date.now(),
                        modified:
                            ((_b = tab.metadata) == null ? void 0 : _b.modified) || Date.now(),
                    };
                }
                /**
                 * Restore session from localStorage
                 */
                async restoreSession() {
                    console.log(
                        '[MultiWindowSessionManager] restoreSession() called, setting isRestoring=true'
                    );
                    this.isRestoring = true;
                    try {
                        const sessionData = localStorage.getItem(
                            _MultiWindowSessionManager.STORAGE_KEY
                        );
                        if (sessionData) {
                            console.log(
                                '[MultiWindowSessionManager] Found session data, parsing...'
                            );
                            const session = JSON.parse(sessionData);
                            console.log('[MultiWindowSessionManager] Session parsed:', {
                                windows: session.windows.length,
                                windowTypes: session.windows.map(w => w.type),
                            });
                            this.migrateSessionPaths(session);
                            await this.restoreMultiWindowSession(session);
                            console.log(
                                '[MultiWindowSessionManager] Session restored successfully'
                            );
                            return true;
                        }
                        const legacyV1Data = localStorage.getItem(
                            _MultiWindowSessionManager.LEGACY_STORAGE_KEY_V1
                        );
                        if (legacyV1Data) {
                            console.log(
                                '[MultiWindowSessionManager] Migrating legacy v1 session...'
                            );
                            const rawSession = JSON.parse(legacyV1Data);
                            const session = this.normalizeLegacyV1Session(rawSession);
                            this.migrateSessionPaths(session);
                            await this.restoreMultiWindowSession(session);
                            localStorage.removeItem(
                                _MultiWindowSessionManager.LEGACY_STORAGE_KEY_V1
                            );
                            this.saveSessionImmediate();
                            return true;
                        }
                        const legacyData = localStorage.getItem(
                            _MultiWindowSessionManager.LEGACY_STORAGE_KEY
                        );
                        if (legacyData) {
                            console.log('[MultiWindowSessionManager] Migrating legacy session...');
                            const legacySession = JSON.parse(legacyData);
                            await this.migrateLegacySession(legacySession);
                            return true;
                        }
                        console.log('[MultiWindowSessionManager] No session to restore');
                        return false;
                    } catch (error) {
                        console.error(
                            '[MultiWindowSessionManager] Failed to restore session:',
                            error
                        );
                        return false;
                    } finally {
                        console.log(
                            '[MultiWindowSessionManager] restoreSession() complete, setting isRestoring=false'
                        );
                        this.isRestoring = false;
                    }
                }
                /**
                 * Restore multi-window session
                 */
                async restoreMultiWindowSession(session) {
                    var _a;
                    console.log('[MultiWindowSessionManager] Restoring session:', {
                        version: session.version,
                        windows: session.windows.length,
                        timestamp: new Date(session.timestamp),
                    });
                    const MAX_WINDOWS_PER_TYPE = 3;
                    const MAX_TOTAL_WINDOWS = 10;
                    if (session.windows.length > MAX_TOTAL_WINDOWS) {
                        console.warn(
                            `[MultiWindowSessionManager] Session has ${session.windows.length} windows (max ${MAX_TOTAL_WINDOWS}). Clearing corrupted session.`
                        );
                        localStorage.removeItem(_MultiWindowSessionManager.STORAGE_KEY);
                        return;
                    }
                    const typeCount = /* @__PURE__ */ new Map();
                    session.windows.forEach(w => {
                        const count = typeCount.get(w.type) || 0;
                        typeCount.set(w.type, count + 1);
                    });
                    for (const [type, count] of typeCount.entries()) {
                        if (count > MAX_WINDOWS_PER_TYPE) {
                            console.warn(
                                `[MultiWindowSessionManager] Session has ${count} ${type} windows (max ${MAX_WINDOWS_PER_TYPE}). Clearing corrupted session.`
                            );
                            localStorage.removeItem(_MultiWindowSessionManager.STORAGE_KEY);
                            return;
                        }
                    }
                    const windowsByType = /* @__PURE__ */ new Map();
                    const filteredWindows = session.windows.filter(w => {
                        const count = windowsByType.get(w.type) || 0;
                        if (count >= MAX_WINDOWS_PER_TYPE) {
                            console.warn(
                                `[MultiWindowSessionManager] Skipping ${w.type} window (limit ${MAX_WINDOWS_PER_TYPE} reached)`
                            );
                            return false;
                        }
                        windowsByType.set(w.type, count + 1);
                        return true;
                    });
                    const sortedWindows = filteredWindows.sort((a, b) => a.zIndex - b.zIndex);
                    for (const windowData of sortedWindows) {
                        await this.restoreWindow(windowData);
                    }
                    if (session.metadata) {
                        this.restoreMetadata(session.metadata);
                    }
                    console.log('[MultiWindowSessionManager] Session restored successfully');
                    const W = window;
                    (_a = W.updateDockIndicators) == null ? void 0 : _a.call(W);
                }
                /**
                 * Restore a single window with its tabs
                 */
                async restoreWindow(data) {
                    try {
                        const window2 = this.createWindowByType(data.type, data);
                        if (!window2) {
                            console.error(
                                `[MultiWindowSessionManager] Unknown window type: ${data.type}`
                            );
                            return null;
                        }
                        for (const tabData of data.tabs) {
                            const tab = this.restoreTab(tabData);
                            if (tab) {
                                window2.addTab(tab);
                            }
                        }
                        if (data.activeTabId && window2.tabs.has(data.activeTabId)) {
                            window2.setActiveTab(data.activeTabId);
                        } else if (window2.tabs.size > 0) {
                            const firstTabId = Array.from(window2.tabs.keys())[0];
                            if (firstTabId) window2.setActiveTab(firstTabId);
                        }
                        window2.show();
                        window_registry_default.registerWindow(window2);
                        setTimeout(() => {
                            if (window2.element) {
                                window2.element.style.zIndex = String(data.zIndex);
                                if (data.position && !data.isMaximized) {
                                    window2.element.style.left = `${data.position.x}px`;
                                    window2.element.style.top = `${data.position.y}px`;
                                    window2.element.style.width = `${data.position.width}px`;
                                    window2.element.style.height = `${data.position.height}px`;
                                    window2.position = { ...data.position };
                                }
                                if (data.isMinimized) {
                                    window2.minimize();
                                } else if (data.isMaximized && !window2.isMaximized) {
                                    window2.toggleMaximize();
                                }
                            }
                        }, 0);
                        return window2;
                    } catch (error) {
                        console.error(
                            '[MultiWindowSessionManager] Failed to restore window:',
                            error
                        );
                        return null;
                    }
                }
                /**
                 * Create window by type
                 */
                createWindowByType(type, data) {
                    const config = {
                        id: data.id,
                        type,
                        position: data.position,
                        metadata: data.metadata,
                    };
                    switch (type) {
                        case 'terminal':
                            return new TerminalWindow(config);
                        case 'text-editor':
                            return new TextEditorWindow(config);
                        case 'finder':
                            return new FinderWindow(config);
                        default:
                            return null;
                    }
                }
                /**
                 * Restore a single tab
                 */
                restoreTab(data) {
                    try {
                        switch (data.type) {
                            case 'terminal-session':
                                return TerminalSession.deserialize(data);
                            case 'text-editor-document':
                                return TextEditorDocument.deserialize(data);
                            case 'finder-view':
                                return FinderView.deserialize(data);
                            default:
                                console.warn(
                                    `[MultiWindowSessionManager] Unknown tab type: ${data.type}`
                                );
                                return null;
                        }
                    } catch (error) {
                        console.error('[MultiWindowSessionManager] Failed to restore tab:', error);
                        return null;
                    }
                }
                /**
                 * Migrate legacy path formats (Computer/Home  /home/marvin)
                 */
                migrateLegacyPath(path) {
                    if (!path) return '/home/marvin';
                    if (path.startsWith('/')) return path;
                    if (path === 'Computer' || path === '~') {
                        return '/home/marvin';
                    }
                    if (path.startsWith('Computer/Home')) {
                        const subPath = path.slice('Computer/Home'.length);
                        return subPath ? `/home/marvin${subPath}` : '/home/marvin';
                    }
                    if (path.startsWith('Computer/')) {
                        const subPath = path.slice('Computer/'.length);
                        return `/home/marvin/${subPath}`;
                    }
                    if (path.startsWith('~/')) {
                        return '/home/marvin/' + path.slice(2);
                    }
                    return `/home/marvin/${path}`;
                }
                /**
                 * Migrate paths in session data
                 */
                migrateSessionPaths(session) {
                    var _a, _b;
                    if (!session || !session.windows) return;
                    for (const window2 of session.windows) {
                        const tabsArray = window2.tabs || window2.sessions || [];
                        for (const tab of tabsArray) {
                            if (tab.vfsCwd) {
                                const migrated = this.migrateLegacyPath(tab.vfsCwd);
                                console.log(
                                    `[MultiWindowSessionManager] Migrating path: ${tab.vfsCwd} \u2192 ${migrated}`
                                );
                                tab.vfsCwd = migrated;
                            }
                            if (tab.currentPath && !tab.vfsCwd) {
                                const migrated = this.migrateLegacyPath(tab.currentPath);
                                console.log(
                                    `[MultiWindowSessionManager] Migrating currentPath: ${tab.currentPath} \u2192 ${migrated}`
                                );
                                tab.vfsCwd = migrated;
                                tab.currentPath = migrated;
                            }
                            if ((_a = tab.contentState) == null ? void 0 : _a.vfsCwd) {
                                const migrated = this.migrateLegacyPath(tab.contentState.vfsCwd);
                                tab.contentState.vfsCwd = migrated;
                            }
                            if ((_b = tab.contentState) == null ? void 0 : _b.currentPath) {
                                const migrated = this.migrateLegacyPath(
                                    tab.contentState.currentPath
                                );
                                tab.contentState.currentPath = migrated;
                            }
                        }
                    }
                }
                /**
                 * Normalize legacy session format to current format
                 * Handles old format with windowId/sessions instead of id/tabs
                 */
                normalizeLegacyV1Session(session) {
                    const normalized = {
                        version: _MultiWindowSessionManager.VERSION,
                        timestamp: session.timestamp || Date.now(),
                        windows: [],
                        metadata: session.metadata || {},
                    };
                    for (const window2 of session.windows || []) {
                        const windowData = {
                            id: window2.id || window2.windowId || `window-${Date.now()}`,
                            type: window2.type || session.windowType || 'terminal',
                            position: window2.position || {
                                x: 100,
                                y: 100,
                                width: 800,
                                height: 600,
                            },
                            zIndex: window2.zIndex || 100,
                            isMinimized: window2.isMinimized || false,
                            isMaximized: window2.isMaximized || false,
                            activeTabId: window2.activeTabId || null,
                            tabs: [],
                            metadata: window2.metadata || {},
                        };
                        const tabsSource = window2.tabs || window2.sessions || [];
                        for (const tab of tabsSource) {
                            const tabData = {
                                id: tab.id || tab.sessionId || `tab-${Date.now()}-${Math.random()}`,
                                type: tab.type || 'terminal-session',
                                title: tab.title || 'Terminal',
                                icon: tab.icon,
                                contentState: tab.contentState || {},
                                created: tab.created || Date.now(),
                                modified: tab.modified || Date.now(),
                            };
                            if (tab.vfsCwd) tabData.vfsCwd = tab.vfsCwd;
                            if (tab.currentPath) tabData.currentPath = tab.currentPath;
                            if (tab.commandHistory) tabData.commandHistory = tab.commandHistory;
                            windowData.tabs.push(tabData);
                        }
                        if (!windowData.activeTabId && windowData.tabs.length > 0) {
                            const firstTab = windowData.tabs[0];
                            if (firstTab) {
                                windowData.activeTabId = firstTab.id;
                            }
                        }
                        normalized.windows.push(windowData);
                    }
                    return normalized;
                }
                /**
                 * Migrate legacy single-window session to multi-window format
                 */
                async migrateLegacySession(legacy) {
                    console.log('[MultiWindowSessionManager] Starting legacy migration...');
                    const instances = legacy.instances || {};
                    if (instances['terminal'] && instances['terminal'].length > 0) {
                        const termWindow = TerminalWindow.create();
                        for (const sessionData of instances['terminal']) {
                            try {
                                const session = TerminalSession.deserialize(sessionData);
                                termWindow.addTab(session);
                            } catch (error) {
                                console.error(
                                    '[MultiWindowSessionManager] Failed to migrate terminal session:',
                                    error
                                );
                            }
                        }
                        if (termWindow.tabs.size > 0) {
                            const firstTabId = Array.from(termWindow.tabs.keys())[0];
                            if (firstTabId) termWindow.setActiveTab(firstTabId);
                        }
                    }
                    if (instances['text-editor'] && instances['text-editor'].length > 0) {
                        const editorWindow = TextEditorWindow.create();
                        for (const docData of instances['text-editor']) {
                            try {
                                const doc = TextEditorDocument.deserialize(docData);
                                editorWindow.addTab(doc);
                            } catch (error) {
                                console.error(
                                    '[MultiWindowSessionManager] Failed to migrate text editor document:',
                                    error
                                );
                            }
                        }
                        if (editorWindow.tabs.size > 0) {
                            const firstTabId = Array.from(editorWindow.tabs.keys())[0];
                            if (firstTabId) editorWindow.setActiveTab(firstTabId);
                        }
                    }
                    if (instances['finder'] && instances['finder'].length > 0) {
                        const finderWindow = FinderWindow.create();
                        for (const viewData of instances['finder']) {
                            try {
                                const view = FinderView.deserialize(viewData);
                                finderWindow.addTab(view);
                            } catch (error) {
                                console.error(
                                    '[MultiWindowSessionManager] Failed to migrate finder view:',
                                    error
                                );
                            }
                        }
                        if (finderWindow.tabs.size > 0) {
                            const firstTabId = Array.from(finderWindow.tabs.keys())[0];
                            if (firstTabId) finderWindow.setActiveTab(firstTabId);
                        }
                    }
                    this.saveSessionImmediate();
                    localStorage.removeItem(_MultiWindowSessionManager.LEGACY_STORAGE_KEY);
                    console.log('[MultiWindowSessionManager] Legacy migration completed');
                }
                /**
                 * Export session as JSON string
                 */
                exportSession() {
                    const session = this.createSession();
                    return JSON.stringify(session, null, 2);
                }
                /**
                 * Import session from JSON string
                 */
                async importSession(jsonString) {
                    try {
                        const session = JSON.parse(jsonString);
                        if (session.version !== _MultiWindowSessionManager.VERSION) {
                            console.warn(
                                '[MultiWindowSessionManager] Version mismatch, attempting import anyway'
                            );
                        }
                        window_registry_default.closeAllWindows();
                        await this.restoreMultiWindowSession(session);
                        return true;
                    } catch (error) {
                        console.error(
                            '[MultiWindowSessionManager] Failed to import session:',
                            error
                        );
                        return false;
                    }
                }
                /**
                 * Clear current session
                 */
                clearSession() {
                    localStorage.removeItem(_MultiWindowSessionManager.STORAGE_KEY);
                    console.log('[MultiWindowSessionManager] Session cleared');
                }
                /**
                 * Get current theme preference
                 */
                getCurrentTheme() {
                    return localStorage.getItem('theme-preference') || 'auto';
                }
                /**
                 * Get current language preference
                 */
                getCurrentLanguage() {
                    return localStorage.getItem('language-preference') || 'de';
                }
                /**
                 * Restore session metadata
                 */
                restoreMetadata(metadata) {
                    console.log('[MultiWindowSessionManager] Session metadata:', metadata);
                }
                /**
                 * Get session info (for debugging)
                 */
                getSessionInfo() {
                    const sessionData = localStorage.getItem(
                        _MultiWindowSessionManager.STORAGE_KEY
                    );
                    if (!sessionData) return null;
                    try {
                        const session = JSON.parse(sessionData);
                        return {
                            version: session.version,
                            timestamp: new Date(session.timestamp),
                            windowCount: session.windows.length,
                            tabCount: session.windows.reduce((sum, w) => sum + w.tabs.length, 0),
                            windows: session.windows.map(w => ({
                                type: w.type,
                                tabs: w.tabs.length,
                                activeTab: w.activeTabId,
                                position: w.position,
                            })),
                        };
                    } catch {
                        return null;
                    }
                }
                /**
                 * Debug log current session state
                 */
                debugLog() {
                    const info = this.getSessionInfo();
                    console.log('[MultiWindowSessionManager] Current session:', info);
                }
            };
            _MultiWindowSessionManager.STORAGE_KEY = 'multi-window-session';
            _MultiWindowSessionManager.LEGACY_STORAGE_KEY = 'windowInstancesSession';
            // Old SessionManager key
            _MultiWindowSessionManager.LEGACY_STORAGE_KEY_V1 = 'multiWindowSession_v1';
            // Legacy multi-window session key
            _MultiWindowSessionManager.VERSION = '1.0.0';
            _MultiWindowSessionManager.AUTO_SAVE_DELAY = 2e3;
            MultiWindowSessionManager = _MultiWindowSessionManager;
            multiWindowSessionManager = new MultiWindowSessionManager();
            window.MultiWindowSessionManager = multiWindowSessionManager;
        },
    });

    // src/ts/services/session-manager.ts
    var require_session_manager = __commonJS({
        'src/ts/services/session-manager.ts'() {
            'use strict';
            init_storage_utils();
            console.log('SessionManager loaded');
            (() => {
                'use strict';
                const SESSION_STORAGE_KEY = 'windowInstancesSession';
                const SESSION_VERSION = '1.0';
                const DEFAULT_DEBOUNCE_MS = 750;
                const MAX_STORAGE_SIZE = 5 * 1024 * 1024;
                let saveTimer = null;
                let debounceDelay = DEFAULT_DEBOUNCE_MS;
                let pendingSaveTypes = /* @__PURE__ */ new Set();
                let quotaExceeded = false;
                let saveInProgress = false;
                function estimateSize(data) {
                    try {
                        return JSON.stringify(data).length * 2;
                    } catch {
                        return 0;
                    }
                }
                function checkStorageQuota(dataSize) {
                    if (quotaExceeded) {
                        return false;
                    }
                    return dataSize < MAX_STORAGE_SIZE;
                }
                function readSession() {
                    try {
                        const parsed = getJSON(SESSION_STORAGE_KEY, null);
                        if (!parsed || typeof parsed !== 'object') return null;
                        if (parsed.version !== SESSION_VERSION) {
                            console.warn(
                                `SessionManager: Version mismatch (stored: ${parsed.version}, expected: ${SESSION_VERSION})`
                            );
                            return null;
                        }
                        return parsed;
                    } catch (err) {
                        console.warn('SessionManager: Failed to read session:', err);
                        return null;
                    }
                }
                function writeSession(session) {
                    const size = estimateSize(session);
                    if (!checkStorageQuota(size)) {
                        if (!quotaExceeded) {
                            console.error(
                                'SessionManager: Storage quota exceeded. Auto-save disabled.'
                            );
                            console.error(
                                `Attempted to save ${(size / 1024).toFixed(2)}KB, limit is ${(MAX_STORAGE_SIZE / 1024).toFixed(2)}KB`
                            );
                            quotaExceeded = true;
                        }
                        return false;
                    }
                    try {
                        setJSON(SESSION_STORAGE_KEY, session);
                        quotaExceeded = false;
                        return true;
                    } catch (err) {
                        if (err instanceof Error && err.name === 'QuotaExceededError') {
                            console.error('SessionManager: Storage quota exceeded:', err);
                            quotaExceeded = true;
                        } else {
                            console.error('SessionManager: Failed to write session:', err);
                        }
                        return false;
                    }
                }
                function clearSession() {
                    try {
                        remove(SESSION_STORAGE_KEY);
                        console.log('SessionManager: Session cleared');
                    } catch (err) {
                        console.warn('SessionManager: Failed to clear session:', err);
                    }
                }
                function getInstanceManagers() {
                    const managers = /* @__PURE__ */ new Map();
                    const w = window;
                    const knownManagers = ['TerminalInstanceManager', 'TextEditorInstanceManager'];
                    knownManagers.forEach(key => {
                        const manager = w[key];
                        if (manager && typeof manager === 'object') {
                            const mgr = manager;
                            const type =
                                typeof mgr.type === 'string'
                                    ? mgr.type
                                    : key.replace('InstanceManager', '').toLowerCase();
                            managers.set(type, manager);
                        }
                    });
                    return managers;
                }
                function serializeAllInstances() {
                    const result = {};
                    const active = {};
                    const managers = getInstanceManagers();
                    managers.forEach((manager, type) => {
                        const mgr = manager;
                        if (typeof mgr.serializeAll === 'function') {
                            try {
                                const instances = mgr.serializeAll.call(mgr);
                                if (Array.isArray(instances)) {
                                    result[type] = instances;
                                }
                            } catch (err) {
                                console.error(
                                    `SessionManager: Failed to serialize instances for type "${type}":`,
                                    err
                                );
                            }
                        }
                        try {
                            if (typeof mgr.getActiveInstance === 'function') {
                                const activeInst = mgr.getActiveInstance.call(mgr);
                                active[type] =
                                    (activeInst == null ? void 0 : activeInst.instanceId) || null;
                            } else {
                                active[type] = null;
                            }
                        } catch {
                            active[type] = null;
                        }
                    });
                    return { instances: result, active };
                }
                function performSave() {
                    if (saveInProgress) {
                        console.warn('SessionManager: Save already in progress, skipping');
                        return;
                    }
                    saveInProgress = true;
                    try {
                        const { instances, active } = serializeAllInstances();
                        const zIndexManager = window.__zIndexManager;
                        const windowStack =
                            zIndexManager && typeof zIndexManager.getWindowStack === 'function'
                                ? zIndexManager.getWindowStack()
                                : [];
                        const session = {
                            version: SESSION_VERSION,
                            timestamp: Date.now(),
                            instances,
                            active,
                            windowStack,
                        };
                        const success = writeSession(session);
                        if (success) {
                            const instanceCount = Object.values(instances).reduce(
                                (sum, arr) => sum + arr.length,
                                0
                            );
                            console.log(
                                `SessionManager: Saved ${instanceCount} instances across ${Object.keys(instances).length} types`
                            );
                        }
                        pendingSaveTypes.clear();
                    } catch (err) {
                        console.error('SessionManager: Save failed:', err);
                    } finally {
                        saveInProgress = false;
                    }
                }
                function scheduleSave(instanceType) {
                    if (instanceType) {
                        pendingSaveTypes.add(instanceType);
                    }
                    if (saveTimer !== null) {
                        clearTimeout(saveTimer);
                    }
                    saveTimer = window.setTimeout(() => {
                        saveTimer = null;
                        performSave();
                    }, debounceDelay);
                }
                function saveAll(options = {}) {
                    if (options.immediate) {
                        if (saveTimer !== null) {
                            clearTimeout(saveTimer);
                            saveTimer = null;
                        }
                        performSave();
                    } else {
                        scheduleSave();
                    }
                }
                function saveInstanceType(instanceType, options = {}) {
                    if (options.immediate) {
                        if (saveTimer !== null) {
                            clearTimeout(saveTimer);
                            saveTimer = null;
                        }
                        performSave();
                    } else {
                        scheduleSave(instanceType);
                    }
                }
                function restoreSession() {
                    const session = readSession();
                    try {
                        console.info('[SessionManager] restoreSession invoked');
                        console.debug('[SessionManager] raw session:', session);
                    } catch {}
                    if (!session) {
                        console.log('SessionManager: No session to restore');
                        return false;
                    }
                    const managers = getInstanceManagers();
                    try {
                        console.info(
                            '[SessionManager] discovered managers:',
                            Array.from(managers.keys())
                        );
                    } catch {}
                    let restoredCount = 0;
                    const activeMap = session.active || {};
                    Object.entries(session.instances).forEach(([type, instances]) => {
                        const manager = managers.get(type);
                        if (!manager) {
                            console.warn(`SessionManager: No manager found for type "${type}"`);
                            return;
                        }
                        const mgr = manager;
                        if (typeof mgr.deserializeAll === 'function') {
                            try {
                                mgr.deserializeAll(instances);
                                restoredCount += instances.length;
                                console.log(
                                    `SessionManager: Restored ${instances.length} "${type}" instances`
                                );
                                const activeId = activeMap[type] || null;
                                if (activeId && typeof mgr.setActiveInstance === 'function') {
                                    try {
                                        mgr.setActiveInstance(activeId);
                                    } catch (e) {
                                        console.warn(
                                            `SessionManager: Failed to set active instance for ${type}:`,
                                            e
                                        );
                                    }
                                }
                            } catch (err) {
                                console.error(
                                    `SessionManager: Failed to restore instances for type "${type}":`,
                                    err
                                );
                            }
                        }
                    });
                    const windowStack = session.windowStack || [];
                    if (windowStack.length > 0) {
                        const zIndexManager = window.__zIndexManager;
                        if (
                            zIndexManager &&
                            typeof zIndexManager.restoreWindowStack === 'function'
                        ) {
                            try {
                                zIndexManager.restoreWindowStack(windowStack);
                                console.log(
                                    `SessionManager: Restored z-index order for ${windowStack.length} windows`
                                );
                            } catch (err) {
                                console.warn(
                                    'SessionManager: Failed to restore window z-index order:',
                                    err
                                );
                            }
                        }
                    }
                    console.log(`SessionManager: Restored ${restoredCount} instances total`);
                    return restoredCount > 0;
                }
                function setDebounceDelay(ms) {
                    if (ms < 100 || ms > 5e3) {
                        console.warn(
                            `SessionManager: Invalid debounce delay ${ms}ms, must be 100-5000ms`
                        );
                        return;
                    }
                    debounceDelay = ms;
                    console.log(`SessionManager: Debounce delay set to ${ms}ms`);
                }
                function getDebounceDelay() {
                    return debounceDelay;
                }
                function clear() {
                    if (saveTimer !== null) {
                        clearTimeout(saveTimer);
                        saveTimer = null;
                    }
                    pendingSaveTypes.clear();
                    clearSession();
                    quotaExceeded = false;
                }
                function getStats() {
                    const session = readSession();
                    if (!session) {
                        return {
                            hasSession: false,
                            instanceCount: 0,
                            types: [],
                            timestamp: null,
                            sizeBytes: 0,
                        };
                    }
                    const instanceCount = Object.values(session.instances).reduce(
                        (sum, arr) => sum + arr.length,
                        0
                    );
                    const types = Object.keys(session.instances);
                    const sizeBytes = estimateSize(session);
                    return {
                        hasSession: true,
                        instanceCount,
                        types,
                        timestamp: session.timestamp,
                        sizeBytes,
                        quotaExceeded,
                    };
                }
                function getStorageInfo() {
                    const stats = getStats();
                    return {
                        hasSession: stats.hasSession,
                        instanceCount: stats.instanceCount,
                        types: stats.types,
                        timestamp: stats.timestamp,
                        sizeBytes: stats.sizeBytes,
                        quotaExceeded: stats.quotaExceeded,
                    };
                }
                function exportSession() {
                    performSave();
                    const session = readSession();
                    if (!session) {
                        console.warn('SessionManager: No session to export');
                        return null;
                    }
                    try {
                        const json = JSON.stringify(session, null, 2);
                        console.log(
                            `SessionManager: Exported session (${(json.length / 1024).toFixed(2)}KB)`
                        );
                        return json;
                    } catch (err) {
                        console.error('SessionManager: Failed to export session:', err);
                        return null;
                    }
                }
                function importSession(json) {
                    if (!json || typeof json !== 'string') {
                        console.error(
                            'SessionManager: Invalid import data (must be non-empty string)'
                        );
                        return false;
                    }
                    let session;
                    try {
                        session = JSON.parse(json);
                    } catch (err) {
                        console.error('SessionManager: Failed to parse import JSON:', err);
                        return false;
                    }
                    if (!session || typeof session !== 'object') {
                        console.error('SessionManager: Invalid session data (must be object)');
                        return false;
                    }
                    if (!session.version || typeof session.version !== 'string') {
                        console.error('SessionManager: Missing or invalid version field');
                        return false;
                    }
                    if (session.version !== SESSION_VERSION) {
                        console.warn(
                            `SessionManager: Version mismatch (imported: ${session.version}, current: ${SESSION_VERSION})`
                        );
                        console.error(
                            'SessionManager: Cannot import session from different version'
                        );
                        return false;
                    }
                    if (!session.instances || typeof session.instances !== 'object') {
                        console.error('SessionManager: Missing or invalid instances field');
                        return false;
                    }
                    const success = writeSession(session);
                    if (!success) {
                        console.error('SessionManager: Failed to save imported session to storage');
                        return false;
                    }
                    const restored = restoreSession();
                    if (!restored) {
                        console.warn(
                            'SessionManager: Imported session saved but restoration failed'
                        );
                        return false;
                    }
                    console.log('SessionManager: Successfully imported and restored session');
                    return true;
                }
                function init() {
                    console.log('SessionManager: Initializing auto-save system');
                    window.addEventListener('blur', () => {
                        saveAll({ immediate: true });
                    });
                    document.addEventListener('visibilitychange', () => {
                        if (document.hidden) {
                            saveAll({ immediate: true });
                        }
                    });
                    console.log(`SessionManager: Initialized with ${debounceDelay}ms debounce`);
                }
                function registerManager(_type, _manager) {
                    console.log(
                        `SessionManager: registerManager() is deprecated - using auto-discovery`
                    );
                }
                function unregisterManager(_type) {}
                const SessionManager = {
                    init,
                    saveAll,
                    saveAllSessions: saveAll,
                    // Alias for backwards compatibility with tests
                    saveInstanceType,
                    restoreSession,
                    clear,
                    setDebounceDelay,
                    getDebounceDelay,
                    getStats,
                    getStorageInfo,
                    exportSession,
                    importSession,
                    registerManager,
                    // Legacy compatibility
                    unregisterManager,
                    // Legacy compatibility
                };
                window.SessionManager = SessionManager;
            })();
        },
    });

    // src/ts/windows/window-tabs.ts
    var require_window_tabs = __commonJS({
        'src/ts/windows/window-tabs.ts'() {
            'use strict';
            (function () {
                'use strict';
                let draggedTab = null;
                let draggedInstanceId = null;
                let draggedManager = null;
                let draggedInstanceObj = null;
                function createTabEl(instance, isActive) {
                    var _a;
                    const tab = document.createElement('button');
                    tab.type = 'button';
                    tab.className = [
                        'wt-tab',
                        'px-3 py-1 text-sm rounded-t-md border border-b-0',
                        'transition-colors whitespace-nowrap flex items-center gap-2',
                        isActive
                            ? 'bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 border-gray-300 dark:border-gray-700'
                            : 'bg-gray-200/70 dark:bg-gray-800/70 text-gray-700 dark:text-gray-300 border-gray-300 dark:border-gray-700 hover:bg-gray-200 dark:hover:bg-gray-800',
                    ].join(' ');
                    tab.dataset.instanceId = instance.instanceId;
                    tab.draggable = true;
                    const title = document.createElement('span');
                    title.className = 'wt-tab-title';
                    const tabLabel = (_a = instance.metadata) == null ? void 0 : _a.tabLabel;
                    title.textContent = tabLabel || instance.title || instance.instanceId;
                    tab.appendChild(title);
                    const close = document.createElement('span');
                    close.className = 'wt-tab-close ml-1 text-xs opacity-70 hover:opacity-100';
                    close.textContent = '\xD7';
                    close.setAttribute('aria-label', 'Tab schlie\xDFen');
                    close.title = 'Tab schlie\xDFen';
                    tab.appendChild(close);
                    return tab;
                }
                function renderTabs(container, manager, options, onSelect, onClose, onNew) {
                    var _a;
                    container.innerHTML = '';
                    const bar = document.createElement('div');
                    bar.className = 'window-tabs flex items-center gap-1 px-2 pt-2 select-none';
                    bar.addEventListener('dragover', e => {
                        if (draggedInstanceId) {
                            e.preventDefault();
                            if (e.dataTransfer) e.dataTransfer.dropEffect = 'move';
                        }
                    });
                    bar.addEventListener('drop', e => {
                        if (!draggedInstanceId) return;
                        e.preventDefault();
                        e.stopPropagation();
                        if (
                            draggedManager &&
                            draggedManager !== manager &&
                            manager.adoptInstance &&
                            draggedManager.detachInstance
                        ) {
                            const inst = draggedManager.detachInstance(draggedInstanceId);
                            if (inst) {
                                const adopted = manager.adoptInstance(inst);
                                if (adopted == null ? void 0 : adopted.instanceId) {
                                    manager.setActiveInstance(adopted.instanceId);
                                }
                            }
                        }
                    });
                    const instances = manager.getAllInstances();
                    const active = manager.getActiveInstance();
                    const activeId =
                        (_a = active == null ? void 0 : active.instanceId) != null ? _a : null;
                    console.log(
                        '[WindowTabs] Rendering tabs for instance IDs:',
                        instances.map(i => i.instanceId)
                    );
                    instances.forEach(inst => {
                        const tab = createTabEl(inst, inst.instanceId === activeId);
                        tab.addEventListener('click', e => {
                            const target = e.target;
                            if (target.closest('.wt-tab-close')) {
                                onClose(inst.instanceId);
                            } else {
                                onSelect(inst.instanceId);
                            }
                        });
                        tab.addEventListener('auxclick', e => {
                            if (e.button === 1) {
                                onClose(inst.instanceId);
                            }
                        });
                        tab.addEventListener('dragstart', e => {
                            draggedTab = tab;
                            draggedInstanceId = inst.instanceId;
                            draggedManager = manager;
                            draggedInstanceObj = inst;
                            if (e.dataTransfer) {
                                e.dataTransfer.effectAllowed = 'move';
                                e.dataTransfer.setData('text/plain', inst.instanceId || '');
                            }
                            tab.style.opacity = '0.5';
                        });
                        tab.addEventListener('dragend', () => {
                            tab.style.opacity = '1';
                            draggedTab = null;
                            draggedInstanceId = null;
                            draggedManager = null;
                            draggedInstanceObj = null;
                            const allTabs = bar.querySelectorAll('.wt-tab');
                            allTabs.forEach(t2 => {
                                t2.classList.remove('border-l-4', 'border-l-blue-500');
                            });
                        });
                        tab.addEventListener('dragover', e => {
                            e.preventDefault();
                            if (e.dataTransfer) {
                                e.dataTransfer.dropEffect = 'move';
                            }
                            if (tab === draggedTab) {
                                return;
                            }
                            const allTabs = bar.querySelectorAll('.wt-tab');
                            allTabs.forEach(t2 => {
                                t2.classList.remove('border-l-4', 'border-l-blue-500');
                            });
                            tab.classList.add('border-l-4', 'border-l-blue-500');
                        });
                        tab.addEventListener('dragleave', () => {
                            tab.classList.remove('border-l-4', 'border-l-blue-500');
                        });
                        tab.addEventListener('drop', e => {
                            e.preventDefault();
                            e.stopPropagation();
                            tab.classList.remove('border-l-4', 'border-l-blue-500');
                            if (!draggedInstanceId || draggedInstanceId === inst.instanceId) {
                                return;
                            }
                            const currentOrder = manager.getAllInstanceIds();
                            const draggedIdx = currentOrder.indexOf(draggedInstanceId);
                            const targetIdx = currentOrder.indexOf(inst.instanceId);
                            if (draggedIdx === -1 || targetIdx === -1) {
                                return;
                            }
                            const newOrder = [...currentOrder];
                            newOrder.splice(draggedIdx, 1);
                            const newTargetIdx = newOrder.indexOf(inst.instanceId);
                            newOrder.splice(newTargetIdx, 0, draggedInstanceId);
                            if (manager.reorderInstances) {
                                manager.reorderInstances(newOrder);
                                renderTabs(container, manager, options, onSelect, onClose, onNew);
                            }
                        });
                        bar.appendChild(tab);
                    });
                    if (options.addButton !== false) {
                        const addBtn = document.createElement('button');
                        addBtn.type = 'button';
                        addBtn.className =
                            'wt-add px-2 py-1 text-sm rounded-md border bg-gray-100 dark:bg-gray-800 border-gray-300 dark:border-gray-700 hover:bg-gray-200 dark:hover:bg-gray-700';
                        addBtn.textContent = '+';
                        addBtn.title = 'Neue Instanz';
                        addBtn.addEventListener('click', () => {
                            var _a2;
                            if (onNew) {
                                onNew();
                            } else {
                                const title =
                                    (_a2 = options.onCreateInstanceTitle) == null
                                        ? void 0
                                        : _a2.call(options);
                                manager.createInstance({ title });
                            }
                        });
                        bar.appendChild(addBtn);
                    }
                    container.appendChild(bar);
                    const underline = document.createElement('div');
                    underline.className = 'h-px bg-gray-300 dark:bg-gray-700';
                    container.appendChild(underline);
                }
                function wrapManager(manager, onChange) {
                    const createOrig = manager.createInstance.bind(manager);
                    const destroyOrig = manager.destroyInstance.bind(manager);
                    const setActiveOrig = manager.setActiveInstance.bind(manager);
                    manager.createInstance = cfg => {
                        const inst = createOrig(cfg);
                        onChange();
                        return inst;
                    };
                    manager.destroyInstance = id => {
                        destroyOrig(id);
                        onChange();
                    };
                    manager.setActiveInstance = id => {
                        setActiveOrig(id);
                        onChange();
                    };
                    return manager;
                }
                function createController(manager, mountEl, options = {}) {
                    const wrapped = wrapManager(manager, () => controller.refresh());
                    const controller = {
                        el: mountEl,
                        refresh() {
                            renderTabs(
                                mountEl,
                                wrapped,
                                options,
                                id => wrapped.setActiveInstance(id),
                                id => wrapped.destroyInstance(id)
                            );
                        },
                        destroy() {
                            mountEl.innerHTML = '';
                        },
                        setTitle(instanceId, title) {
                            const inst = wrapped.getInstance(instanceId);
                            if (inst) {
                                inst.metadata = { ...(inst.metadata || {}), tabLabel: title };
                                this.refresh();
                            }
                        },
                    };
                    controller.refresh();
                    return controller;
                }
                document.addEventListener('dragover', e => {
                    if (draggedInstanceId) {
                        e.preventDefault();
                    }
                });
                document.addEventListener('drop', e => {
                    var _a, _b;
                    if (!draggedInstanceId || !draggedManager) return;
                    const tgt = e.target;
                    if (tgt.closest('.window-tabs')) return;
                    e.preventDefault();
                    e.stopPropagation();
                    if (!draggedManager.detachInstance) return;
                    const inst = draggedManager.detachInstance(draggedInstanceId);
                    if (!inst) return;
                    const tab = inst.__tab || inst;
                    const ttype = (tab && tab.type) || '';
                    const W = window;
                    let NewWinCtor = null;
                    if (ttype.includes('terminal')) NewWinCtor = W.TerminalWindow;
                    else if (ttype.includes('text-editor')) NewWinCtor = W.TextEditorWindow;
                    else if (ttype.includes('finder')) NewWinCtor = W.FinderWindow;
                    if (!NewWinCtor) return;
                    const newWin = new NewWinCtor({
                        title: (
                            ((_a = tab == null ? void 0 : tab.parentWindow) == null
                                ? void 0
                                : _a.type) || ''
                        ).toString(),
                    });
                    if (typeof newWin.show === 'function') newWin.show();
                    if (W.WindowRegistry) W.WindowRegistry.registerWindow(newWin);
                    if (typeof newWin.addTab === 'function') {
                        newWin.addTab(tab);
                        (_b = newWin.setActiveTab) == null ? void 0 : _b.call(newWin, tab.id);
                    }
                });
                const WindowTabs = {
                    /**
                     * Create a window tabs bar bound to a specific InstanceManager.
                     */
                    create(manager, mountEl, options) {
                        return createController(manager, mountEl, options);
                    },
                };
                window.WindowTabs = WindowTabs;
            })();
        },
    });

    // src/ts/apps/terminal/terminal-instance.ts
    var require_terminal_instance = __commonJS({
        'src/ts/apps/terminal/terminal-instance.ts'() {
            'use strict';
            console.log('TerminalInstance (TS) loaded');
            (() => {
                'use strict';
                var _a, _b, _c;
                const Base = window.BaseWindowInstance;
                class TerminalInstance extends Base {
                    constructor(config) {
                        super({
                            ...config,
                            type: 'terminal',
                        });
                        this.outputElement = null;
                        this.inputElement = null;
                        this.commandHistory = [];
                        this.historyIndex = -1;
                        this.currentPath = '~';
                        this.fileSystem = {
                            '~': {
                                type: 'directory',
                                contents: {
                                    Desktop: { type: 'directory', contents: {} },
                                    Documents: {
                                        type: 'directory',
                                        contents: {
                                            'readme.txt': {
                                                type: 'file',
                                                content: 'Willkommen im Terminal!',
                                            },
                                        },
                                    },
                                    Downloads: { type: 'directory', contents: {} },
                                    'welcome.txt': {
                                        type: 'file',
                                        content:
                                            'Willkommen auf Marvins Portfolio-Website!\n\nGib "help" ein, um eine Liste verf\xFCgbarer Befehle zu sehen.',
                                    },
                                },
                            },
                        };
                    }
                    // No override of _initializeState to avoid type modifier conflicts
                    render() {
                        if (!this.container) return;
                        const html = `
                <div class="terminal-wrapper h-full flex flex-col bg-gray-900 text-green-400 font-mono text-sm">
                    <div class="terminal-output flex-1 overflow-y-auto p-4 space-y-1" data-terminal-output>
                    </div>
                    <div class="terminal-input-line flex items-center px-4 py-2 border-t border-gray-700">
                        <span class="terminal-prompt text-blue-400">guest@marvin:${this.currentPath}$</span>
                        <input
                            type="text"
                            class="flex-1 ml-2 bg-transparent outline-none text-green-400 terminal-input"
                            autocomplete="off"
                            spellcheck="false"
                            aria-label="Terminal input"
                            data-terminal-input
                        />
                    </div>
                </div>
            `;
                        this.container.innerHTML = html;
                        this.outputElement = this.container.querySelector('[data-terminal-output]');
                        this.inputElement = this.container.querySelector('[data-terminal-input]');
                        try {
                            this.showWelcomeMessage();
                        } catch {}
                        if (this.inputElement && typeof this.inputElement.focus === 'function') {
                            this.inputElement.focus();
                        }
                    }
                    attachEventListeners() {
                        if (!this.inputElement) return;
                        this.inputElement.addEventListener('keydown', e => {
                            if (e.key === 'Enter') {
                                e.preventDefault();
                                const command = this.inputElement.value.trim();
                                if (command) {
                                    this.executeCommand(command);
                                    this.commandHistory.push(command);
                                    this.historyIndex = this.commandHistory.length;
                                    this.updateState({ commandHistory: this.commandHistory });
                                }
                                this.inputElement.value = '';
                                this.inputElement.focus();
                            } else if (e.key === 'Tab') {
                                e.preventDefault();
                                this.handleTabCompletion();
                            } else if (e.key === 'ArrowUp') {
                                e.preventDefault();
                                if (this.historyIndex > 0) {
                                    this.historyIndex--;
                                    const historyEntry = this.commandHistory[this.historyIndex];
                                    if (historyEntry !== void 0) {
                                        this.inputElement.value = historyEntry;
                                    }
                                }
                            } else if (e.key === 'ArrowDown') {
                                e.preventDefault();
                                if (this.historyIndex < this.commandHistory.length - 1) {
                                    this.historyIndex++;
                                    const historyEntry = this.commandHistory[this.historyIndex];
                                    if (historyEntry !== void 0) {
                                        this.inputElement.value = historyEntry;
                                    }
                                } else {
                                    this.historyIndex = this.commandHistory.length;
                                    this.inputElement.value = '';
                                }
                            }
                        });
                    }
                    showWelcomeMessage() {
                        this.addOutput(
                            'Willkommen im Terminal! Gib "help" ein f\xFCr verf\xFCgbare Befehle.',
                            'info'
                        );
                    }
                    handleTabCompletion() {
                        if (!this.inputElement) return;
                        const input = this.inputElement.value;
                        const [partialCmd, ...args] = input.split(' ');
                        if (partialCmd === void 0) return;
                        const availableCommands = [
                            'help',
                            'clear',
                            'ls',
                            'pwd',
                            'cd',
                            'cat',
                            'echo',
                            'date',
                            'whoami',
                        ];
                        if (args.length === 0) {
                            const matches = availableCommands.filter(cmd =>
                                cmd.startsWith(partialCmd)
                            );
                            if (matches.length === 1) {
                                const match = matches[0];
                                if (match !== void 0) {
                                    this.inputElement.value = match + ' ';
                                }
                            } else if (matches.length > 1) {
                                this.addOutput(
                                    `guest@marvin:${this.currentPath}$ ${input}`,
                                    'command'
                                );
                                this.addOutput(matches.join('  '), 'info');
                                const commonPrefix = this.findCommonPrefix(matches);
                                if (commonPrefix.length > partialCmd.length) {
                                    this.inputElement.value = commonPrefix;
                                }
                            }
                        } else {
                            if (partialCmd === 'cd' || partialCmd === 'cat') {
                                this.completePathArgument(partialCmd, args[0] || '');
                            }
                        }
                    }
                    findCommonPrefix(strings) {
                        if (!strings.length) return '';
                        const firstString = strings[0];
                        if (strings.length === 1) return firstString != null ? firstString : '';
                        if (firstString === void 0) return '';
                        let prefix = firstString;
                        for (let i = 1; i < strings.length; i++) {
                            const currentString = strings[i];
                            if (currentString === void 0) continue;
                            while (currentString.indexOf(prefix) !== 0) {
                                prefix = prefix.substring(0, prefix.length - 1);
                                if (!prefix) return '';
                            }
                        }
                        return prefix;
                    }
                    completePathArgument(cmd, partial) {
                        const currentDir = this.resolvePath(this.currentPath);
                        if (!currentDir || currentDir.type !== 'directory') return;
                        const items = Object.keys(currentDir.contents);
                        let matches;
                        if (cmd === 'cd') {
                            matches = items.filter(
                                item =>
                                    currentDir.contents[item].type === 'directory' &&
                                    item.startsWith(partial)
                            );
                        } else {
                            matches = items.filter(
                                item =>
                                    currentDir.contents[item].type === 'file' &&
                                    item.startsWith(partial)
                            );
                        }
                        if (matches.length === 1) {
                            const match = matches[0];
                            if (match !== void 0) {
                                this.inputElement.value = `${cmd} ${match}`;
                            }
                        } else if (matches.length > 1) {
                            this.addOutput(
                                `guest@marvin:${this.currentPath}$ ${this.inputElement.value}`,
                                'command'
                            );
                            const formatted = matches.map(item => {
                                const itemObj = currentDir.contents[item];
                                if (!itemObj) return item;
                                const prefix =
                                    itemObj.type === 'directory' ? '\u{1F4C1} ' : '\u{1F4C4} ';
                                return prefix + item;
                            });
                            this.addOutput(formatted.join('  '), 'info');
                            const commonPrefix = this.findCommonPrefix(matches);
                            if (commonPrefix.length > partial.length) {
                                this.inputElement.value = `${cmd} ${commonPrefix}`;
                            }
                        }
                    }
                    executeCommand(command) {
                        this.addOutput(`guest@marvin:${this.currentPath}$ ${command}`, 'command');
                        const [cmd, ...args] = command.split(' ');
                        if (cmd === void 0) return;
                        const commands = {
                            help: () => this.showHelp(),
                            clear: () => this.clearOutput(),
                            ls: () => this.listDirectory(args[0]),
                            pwd: () => this.printWorkingDirectory(),
                            cd: () => this.changeDirectory(args[0]),
                            cat: () => this.catFile(args[0]),
                            echo: () => this.echo(args.join(' ')),
                            date: () => this.showDate(),
                            whoami: () => this.addOutput('guest', 'output'),
                        };
                        const commandFn = commands[cmd];
                        if (commandFn !== void 0) {
                            commandFn();
                        } else {
                            this.addOutput(
                                `Befehl nicht gefunden: ${cmd}. Gib "help" ein f\xFCr verf\xFCgbare Befehle.`,
                                'error'
                            );
                        }
                    }
                    addOutput(text, type = 'output') {
                        if (!this.outputElement) return;
                        const line = document.createElement('div');
                        line.className = `terminal-line terminal-${type}`;
                        const colorMap = {
                            command: 'text-blue-400',
                            output: 'text-green-400',
                            error: 'text-red-400',
                            info: 'text-yellow-400',
                        };
                        line.className += ` ${colorMap[type] || 'text-green-400'}`;
                        line.textContent = text;
                        this.outputElement.appendChild(line);
                        this.outputElement.scrollTop = this.outputElement.scrollHeight;
                    }
                    clearOutput() {
                        if (this.outputElement) this.outputElement.innerHTML = '';
                    }
                    showHelp() {
                        const helpText = [
                            'Verf\xFCgbare Befehle:',
                            '  help         - Zeige diese Hilfe',
                            '  clear        - L\xF6sche Ausgabe',
                            '  ls [path]    - Liste Dateien (optional mit Pfad)',
                            '  pwd          - Zeige aktuelles Verzeichnis',
                            '  cd <dir>     - Wechsle Verzeichnis (., .., ~, relative/absolute Pfade)',
                            '  cat <file>   - Zeige Dateiinhalt (auch mit Pfad: cat ./file oder cat dir/file)',
                            '  echo <text>  - Gebe Text aus',
                            '  date         - Zeige Datum/Zeit',
                            '  whoami       - Zeige Benutzername',
                            '',
                            'Pfad-Beispiele:',
                            '  .            - Aktuelles Verzeichnis',
                            '  ..           - \xDCbergeordnetes Verzeichnis',
                            '  ~            - Home-Verzeichnis',
                            '  ./file       - Datei im aktuellen Verzeichnis',
                            '  ../file      - Datei im \xFCbergeordneten Verzeichnis',
                            '  dir/subdir   - Unterverzeichnis (relativ)',
                            '',
                            'Tipps:',
                            '  \u2191/\u2193          - Durchsuche Befehlshistorie',
                            '  Tab          - Vervollst\xE4ndige Befehle und Pfade',
                        ];
                        helpText.forEach(l => this.addOutput(l, 'info'));
                    }
                    listDirectory(path) {
                        const targetPath = path ? this.normalizePath(path) : this.currentPath;
                        const targetDir = this.resolvePath(targetPath);
                        if (!targetDir) {
                            this.addOutput(
                                `Verzeichnis nicht gefunden: ${path || targetPath}`,
                                'error'
                            );
                            return;
                        }
                        if (targetDir.type !== 'directory') {
                            this.addOutput(`${path || targetPath} ist kein Verzeichnis`, 'error');
                            return;
                        }
                        const items = Object.keys(targetDir.contents);
                        if (items.length === 0) this.addOutput('(leer)', 'output');
                        else {
                            items.forEach(item => {
                                const itemObj = targetDir.contents[item];
                                if (!itemObj) return;
                                const prefix =
                                    itemObj.type === 'directory' ? '\u{1F4C1} ' : '\u{1F4C4} ';
                                this.addOutput(prefix + item, 'output');
                            });
                        }
                    }
                    printWorkingDirectory() {
                        this.addOutput(this.currentPath, 'output');
                    }
                    changeDirectory(path) {
                        if (!path) {
                            this.currentPath = '~';
                            this.updatePrompt();
                            return;
                        }
                        const newPath = this.normalizePath(path);
                        const resolved = this.resolvePath(newPath);
                        if (!resolved) {
                            this.addOutput(`Verzeichnis nicht gefunden: ${path}`, 'error');
                            return;
                        }
                        if (resolved.type !== 'directory') {
                            this.addOutput(`${path} ist kein Verzeichnis`, 'error');
                            return;
                        }
                        this.currentPath = newPath;
                        this.updatePrompt();
                        this.updateState({ currentPath: this.currentPath });
                    }
                    catFile(filename) {
                        var _a2, _b2;
                        if (!filename) {
                            this.addOutput('Dateiname fehlt', 'error');
                            return;
                        }
                        if (filename.includes('/')) {
                            const normalizedPath = this.normalizePath(filename);
                            const pathParts = normalizedPath.split('/').filter(p => p !== '');
                            const fileName = pathParts.pop();
                            const dirPath = pathParts.length > 0 ? pathParts.join('/') : '~';
                            const dir = this.resolvePath(dirPath);
                            if (!dir) {
                                this.addOutput(`Verzeichnis nicht gefunden: ${dirPath}`, 'error');
                                return;
                            }
                            const file = (_a2 = dir.contents) == null ? void 0 : _a2[fileName];
                            if (!file) this.addOutput(`Datei nicht gefunden: ${filename}`, 'error');
                            else if (file.type !== 'file')
                                this.addOutput(`${filename} ist keine Datei`, 'error');
                            else this.addOutput(file.content, 'output');
                        } else {
                            const currentDir = this.resolvePath(this.currentPath);
                            const file =
                                (_b2 = currentDir == null ? void 0 : currentDir.contents) == null
                                    ? void 0
                                    : _b2[filename];
                            if (!file) this.addOutput(`Datei nicht gefunden: ${filename}`, 'error');
                            else if (file.type !== 'file')
                                this.addOutput(`${filename} ist keine Datei`, 'error');
                            else this.addOutput(file.content, 'output');
                        }
                    }
                    echo(text) {
                        this.addOutput(text, 'output');
                    }
                    showDate() {
                        this.addOutput(/* @__PURE__ */ new Date().toString(), 'output');
                    }
                    updatePrompt() {
                        var _a2;
                        const prompt =
                            (_a2 = this.container) == null
                                ? void 0
                                : _a2.querySelector('.terminal-prompt');
                        if (prompt) {
                            prompt.textContent = `guest@marvin:${this.currentPath}$`;
                        }
                    }
                    resolvePath(path) {
                        if (!path) return null;
                        const normalizedPath = this.normalizePath(path);
                        const homeNode = this.fileSystem['~'];
                        if (normalizedPath === '~') return homeNode != null ? homeNode : null;
                        if (homeNode === void 0) return null;
                        let current = homeNode;
                        const parts = normalizedPath
                            .replace(/^~\/?/, '')
                            .split('/')
                            .filter(p => p);
                        for (const part of parts) {
                            if (current.type !== 'directory') return null;
                            if (!current.contents || !current.contents[part]) return null;
                            const nextNode = current.contents[part];
                            if (nextNode === void 0) return null;
                            current = nextNode;
                        }
                        return current;
                    }
                    normalizePath(path) {
                        if (!path || path === '~') return '~';
                        if (path === '.') return this.currentPath;
                        if (path === './') return this.currentPath;
                        let workingPath;
                        if (path.startsWith('~')) workingPath = path;
                        else if (path.startsWith('/')) workingPath = '~' + path;
                        else
                            workingPath =
                                this.currentPath === '~'
                                    ? `~/${path}`
                                    : `${this.currentPath}/${path}`;
                        const parts = workingPath.split('/').filter(p => p !== '' && p !== '.');
                        const resolved = [];
                        for (const part of parts) {
                            if (part === '..') {
                                if (resolved.length > 0 && resolved[resolved.length - 1] !== '~') {
                                    resolved.pop();
                                }
                            } else {
                                resolved.push(part);
                            }
                        }
                        if (resolved.length === 0 || (resolved.length === 1 && resolved[0] === '~'))
                            return '~';
                        if (resolved[0] !== '~') resolved.unshift('~');
                        return resolved.join('/');
                    }
                    parentPath(path) {
                        const parts = path.split('/').filter(Boolean);
                        parts.pop();
                        return parts.length > 0 ? '/' + parts.join('/') : '~';
                    }
                    serialize() {
                        const baseSerialize = Base.prototype.serialize;
                        const baseObj = baseSerialize.call(this);
                        return {
                            ...baseObj,
                            currentPath: this.currentPath,
                            commandHistory: this.commandHistory,
                            fileSystem: this.fileSystem,
                        };
                    }
                    deserialize(data) {
                        const baseDeserialize = Base.prototype.deserialize;
                        baseDeserialize.call(this, data);
                        const d = data;
                        if (d.currentPath) {
                            this.currentPath = d.currentPath;
                            this.updatePrompt();
                        }
                        if (d.commandHistory) {
                            this.commandHistory = d.commandHistory;
                            this.historyIndex = this.commandHistory.length;
                        }
                        if (d.fileSystem) {
                            this.fileSystem = d.fileSystem;
                        }
                    }
                    focus() {
                        const baseFocus = Base.prototype.focus;
                        baseFocus.call(this);
                        if (this.inputElement) this.inputElement.focus();
                    }
                }
                window.TerminalInstance = TerminalInstance;
                const G = window;
                const InstanceManager = G['InstanceManager'];
                if (InstanceManager) {
                    G['TerminalInstanceManager'] = new InstanceManager({
                        type: 'terminal',
                        instanceClass: TerminalInstance,
                        maxInstances: 0,
                        createContainer: function (instanceId) {
                            const terminalModalContainer =
                                document.getElementById('terminal-container');
                            if (!terminalModalContainer) {
                                console.error('Terminal container not found');
                                return null;
                            }
                            const container = document.createElement('div');
                            container.id = `${instanceId}-container`;
                            container.className = 'terminal-instance-container h-full';
                            const domUtils = window.DOMUtils;
                            if (domUtils && typeof domUtils.hide === 'function') {
                                domUtils.hide(container);
                            } else {
                                container.classList.add('hidden');
                            }
                            terminalModalContainer.appendChild(container);
                            return container;
                        },
                    });
                    try {
                        console.debug('TerminalInstanceManager created', {
                            type: (_a = G['TerminalInstanceManager']) == null ? void 0 : _a.type,
                            instanceCount:
                                (_c =
                                    (_b = G['TerminalInstanceManager']) == null
                                        ? void 0
                                        : _b.getInstanceCount) == null
                                    ? void 0
                                    : _c.call(_b),
                        });
                    } catch (error) {
                        console.debug('TerminalInstanceManager created (debug log failed)', error);
                    }
                }
            })();
        },
    });

    // src/ts/apps/text-editor/text-editor.ts
    var require_text_editor = __commonJS({
        'src/ts/apps/text-editor/text-editor.ts'() {
            'use strict';
            init_storage_utils();
            var TextEditorSystem = {
                container: null,
                editor: null,
                statusBar: null,
                saveButton: null,
                fileInput: null,
                wrapMode: 'off',
                currentRemoteFile: null,
                statusState: null,
                wordCountDisplay: null,
                lineColDisplay: null,
                findReplacePanel: null,
                findInput: null,
                replaceInput: null,
                toastContainer: null,
                /**
                 * Initialize text editor in container
                 * @param {HTMLElement|string} containerOrId - Container element or ID
                 */
                init(containerOrId) {
                    const container =
                        typeof containerOrId === 'string'
                            ? document.getElementById(containerOrId)
                            : containerOrId;
                    if (!container) {
                        console.error('Text editor container not found:', containerOrId);
                        return;
                    }
                    this.container = container;
                    this.render();
                    this.cacheElements();
                    this.loadWrapPreference();
                    this.attachListeners();
                    this.loadSavedContent();
                    this.syncSaveButtonState();
                    if (window.ActionBus) {
                        this.registerActions();
                    }
                },
                /**
                 * Render text editor UI
                 */
                render() {
                    if (!this.container) return;
                    this.container.innerHTML = `
                <div class="dialog-content flex flex-col h-full" style="background: var(--editor-body-bg, #fafafa); color: var(--editor-text, #111827);">
                    <!-- File Operations Toolbar -->
                    <div id="text-toolbar" class="flex-none" style="background: var(--editor-toolbar-bg, #f5f5f5); padding: 8px 12px; border-bottom: 1px solid var(--editor-toolbar-border, #d1d5db); display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                        <button type="button" data-action="textEditor:clear" class="text-editor-btn" data-i18n="textEditor.toolbar.clear" data-i18n-title="textEditor.toolbar.clear">Neu</button>
                        <button type="button" data-action="textEditor:open" class="text-editor-btn" data-i18n="textEditor.toolbar.open" data-i18n-title="textEditor.toolbar.open">\xD6ffnen</button>
                        <button type="button" data-action="textEditor:save" class="text-editor-btn" id="text-save-button" data-i18n="textEditor.toolbar.save" data-i18n-title="textEditor.toolbar.save">Speichern</button>
                        <div style="width: 1px; height: 20px; background: var(--editor-toolbar-border, #d1d5db); margin: 0 4px;"></div>
                        <button type="button" data-action="textEditor:bold" class="text-editor-btn" data-i18n-title="textEditor.toolbar.bold" style="font-weight: bold;">B</button>
                        <button type="button" data-action="textEditor:italic" class="text-editor-btn" data-i18n-title="textEditor.toolbar.italic" style="font-style: italic;">I</button>
                        <button type="button" data-action="textEditor:underline" class="text-editor-btn" data-i18n-title="textEditor.toolbar.underline" style="text-decoration: underline;">U</button>
                        <button type="button" data-action="textEditor:strikethrough" class="text-editor-btn" data-i18n-title="textEditor.toolbar.strikeThrough" style="text-decoration: line-through;">S</button>
                        <div style="width: 1px; height: 20px; background: var(--editor-toolbar-border, #d1d5db); margin: 0 4px;"></div>
                        <button type="button" data-action="textEditor:heading1" class="text-editor-btn" data-i18n-title="textEditor.toolbar.heading1">H1</button>
                        <button type="button" data-action="textEditor:heading2" class="text-editor-btn" data-i18n-title="textEditor.toolbar.heading2">H2</button>
                        <button type="button" data-action="textEditor:heading3" class="text-editor-btn" data-i18n-title="textEditor.toolbar.heading3">H3</button>
                        <div style="width: 1px; height: 20px; background: var(--editor-toolbar-border, #d1d5db); margin: 0 4px;"></div>
                        <button type="button" data-action="textEditor:unorderedList" class="text-editor-btn" data-i18n-title="textEditor.toolbar.unorderedList">\u2022 List</button>
                        <button type="button" data-action="textEditor:orderedList" class="text-editor-btn" data-i18n-title="textEditor.toolbar.orderedList">1. List</button>
                        <div style="width: 1px; height: 20px; background: var(--editor-toolbar-border, #d1d5db); margin: 0 4px;"></div>
                        <button type="button" data-action="textEditor:alignLeft" class="text-editor-btn" data-i18n-title="textEditor.toolbar.alignLeft">\u21E4</button>
                        <button type="button" data-action="textEditor:alignCenter" class="text-editor-btn" data-i18n-title="textEditor.toolbar.alignCenter">\u2261</button>
                        <button type="button" data-action="textEditor:alignRight" class="text-editor-btn" data-i18n-title="textEditor.toolbar.alignRight">\u21E5</button>
                        <div style="width: 1px; height: 20px; background: var(--editor-toolbar-border, #d1d5db); margin: 0 4px;"></div>
                        <button type="button" data-action="textEditor:insertLink" class="text-editor-btn" data-i18n-title="textEditor.toolbar.insertLink">\u{1F517}</button>
                        <button type="button" data-action="textEditor:findReplace" class="text-editor-btn" data-i18n-title="textEditor.toolbar.findReplace">\u{1F50D}</button>
                        <input type="file" id="text-file-input"
                            accept=".txt,.md,.markdown,.html,.htm,.css,.scss,.js,.jsx,.ts,.tsx,.json,.yml,.yaml,.xml,.csv,.tsv,.ini,.cfg,.conf,.env,.gitignore,.log,.c,.h,.cpp,.hpp,.java,.kt,.swift,.cs,.py,.rb,.php,.rs,.go,.sh,.bash,.zsh,.fish,.ps1,.bat"
                            style="display:none">
                    </div>
                    <!-- Find and Replace Panel (Hidden by default) -->
                    <div id="find-replace-panel" class="flex-none" style="background: var(--editor-toolbar-bg, #f5f5f5); padding: 8px 12px; border-bottom: 1px solid var(--editor-toolbar-border, #d1d5db); display: none; gap: 8px; align-items: center; flex-wrap: wrap;">
                        <input type="text" id="find-input" data-i18n-placeholder="textEditor.findReplace.find" placeholder="Find..." style="padding: 4px 8px; border: 1px solid var(--editor-toolbar-border, #d1d5db); border-radius: 4px; background: var(--editor-surface-bg, #ffffff); color: var(--editor-text, #111827); font-size: 13px;">
                        <input type="text" id="replace-input" data-i18n-placeholder="textEditor.findReplace.replace" placeholder="Replace..." style="padding: 4px 8px; border: 1px solid var(--editor-toolbar-border, #d1d5db); border-radius: 4px; background: var(--editor-surface-bg, #ffffff); color: var(--editor-text, #111827); font-size: 13px;">
                        <button type="button" data-action="textEditor:findNext" class="text-editor-btn" data-i18n="textEditor.findReplace.next" data-i18n-title="textEditor.findReplace.next" style="font-size: 12px;">Next</button>
                        <button type="button" data-action="textEditor:replaceOne" class="text-editor-btn" data-i18n="textEditor.findReplace.replaceOne" data-i18n-title="textEditor.findReplace.replaceOne" style="font-size: 12px;">Replace</button>
                        <button type="button" data-action="textEditor:replaceAll" class="text-editor-btn" data-i18n="textEditor.findReplace.replaceAll" data-i18n-title="textEditor.findReplace.replaceAll" style="font-size: 12px;">Replace All</button>
                        <button type="button" data-action="textEditor:closeFindReplace" class="text-editor-btn" data-i18n="textEditor.findReplace.close" data-i18n-title="textEditor.findReplace.close" style="font-size: 12px;">\u2715</button>
                    </div>
                    <div id="text-file-status" class="flex-none" style="padding: 8px 16px; border-bottom: 1px solid var(--editor-toolbar-border, #d1d5db); background: var(--editor-body-bg, #fafafa); color: var(--editor-text, #111827); font-size: 14px; opacity: 0.75; display: none;"></div>
                    <textarea id="text-editor-textarea" spellcheck="false" wrap="off" class="flex-1 w-full resize-none p-4 border-0 outline-none"
                        style="background: var(--editor-surface-bg, #ffffff); color: inherit; font-family: 'SFMono-Regular', Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size: 14px; line-height: 1.6; tab-size: 4;"
                        title="textarea"></textarea>
                    <!-- Status Bar with Word Count -->
                    <div id="word-count-bar" class="flex-none" style="background: var(--editor-toolbar-bg, #f5f5f5); padding: 6px 12px; border-top: 1px solid var(--editor-toolbar-border, #d1d5db); font-size: 12px; color: var(--editor-text, #111827); opacity: 0.75; display: flex; justify-content: space-between;">
                        <span id="word-count-display" data-i18n="textEditor.status.wordCount" data-i18n-params='{"words":0,"chars":0}'>Words: 0 | Characters: 0</span>
                        <span id="line-col-display" data-i18n="textEditor.status.position" data-i18n-params='{"line":1,"col":1}'>Line 1, Col 1</span>
                    </div>
                </div>
            `;
                    this.updateCSSVariables();
                    if (window.appI18n && typeof window.appI18n.applyTranslations === 'function') {
                        window.appI18n.applyTranslations();
                    }
                },
                /**
                 * Update CSS variables for dark mode
                 */
                updateCSSVariables() {
                    if (!this.container) return;
                    const isDark = document.documentElement.classList.contains('dark');
                    this.container.style.setProperty(
                        '--editor-body-bg',
                        isDark ? '#0f172a' : '#fafafa'
                    );
                    this.container.style.setProperty(
                        '--editor-text',
                        isDark ? '#e5e7eb' : '#111827'
                    );
                    this.container.style.setProperty(
                        '--editor-toolbar-bg',
                        isDark ? '#1f2937' : '#f5f5f5'
                    );
                    this.container.style.setProperty(
                        '--editor-toolbar-border',
                        isDark ? '#374151' : '#d1d5db'
                    );
                    this.container.style.setProperty(
                        '--editor-toolbar-button-bg',
                        isDark ? '#111827' : '#ffffff'
                    );
                    this.container.style.setProperty(
                        '--editor-toolbar-button-hover',
                        isDark ? '#1f2937' : '#e5e7eb'
                    );
                    this.container.style.setProperty(
                        '--editor-toolbar-button-border',
                        isDark ? '#475569' : '#d1d5db'
                    );
                    this.container.style.setProperty(
                        '--editor-surface-bg',
                        isDark ? '#111827' : '#ffffff'
                    );
                    const buttons = this.container.querySelectorAll('.text-editor-btn');
                    buttons.forEach(btn => {
                        btn.style.margin = '0';
                        btn.style.padding = '6px 12px';
                        btn.style.fontSize = '14px';
                        btn.style.border = `1px solid ${isDark ? '#475569' : '#d1d5db'}`;
                        btn.style.background = isDark ? '#111827' : '#ffffff';
                        btn.style.cursor = 'pointer';
                        btn.style.color = 'inherit';
                        btn.style.borderRadius = '6px';
                    });
                },
                /**
                 * Cache DOM elements
                 */
                cacheElements() {
                    if (!this.container) return;
                    this.editor = this.container.querySelector('#text-editor-textarea');
                    this.statusBar = this.container.querySelector('#text-file-status');
                    this.saveButton = this.container.querySelector('#text-save-button');
                    this.fileInput = this.container.querySelector('#text-file-input');
                    this.wordCountDisplay = this.container.querySelector('#word-count-display');
                    this.lineColDisplay = this.container.querySelector('#line-col-display');
                    this.findReplacePanel = this.container.querySelector('#find-replace-panel');
                    this.findInput = this.container.querySelector('#find-input');
                    this.replaceInput = this.container.querySelector('#replace-input');
                },
                /**
                 * Load wrap mode preference
                 */
                loadWrapPreference() {
                    const storedWrapMode = getString('textEditorWrapMode');
                    this.wrapMode = storedWrapMode === 'soft' ? 'soft' : 'off';
                    this.applyWrapMode(this.wrapMode);
                },
                /**
                 * Apply wrap mode
                 * @param {string} mode - Wrap mode (soft|off)
                 */
                applyWrapMode(mode) {
                    if (!this.editor) return;
                    const effective = mode != null ? mode : this.wrapMode;
                    const normalized = effective === 'soft' ? 'soft' : 'off';
                    this.wrapMode = normalized;
                    this.editor.wrap = normalized;
                    this.editor.style.whiteSpace = normalized === 'soft' ? 'pre-wrap' : 'pre';
                    try {
                        setString('textEditorWrapMode', normalized);
                    } catch (err) {
                        console.warn('Wrap preference could not be stored:', err);
                    }
                },
                /**
                 * Toggle wrap mode
                 */
                toggleWrapMode() {
                    const next = this.wrapMode === 'soft' ? 'off' : 'soft';
                    this.applyWrapMode(next);
                    this.setStatusPlain(
                        next === 'soft' ? 'Zeilenumbruch aktiviert' : 'Zeilenumbruch deaktiviert'
                    );
                    this.focusEditor();
                },
                /**
                 * Attach event listeners
                 */
                attachListeners() {
                    if (!this.editor || !this.fileInput) return;
                    this.editor.addEventListener('input', () => {
                        this.handleEditorInput();
                        this.updateWordCount();
                    });
                    this.editor.addEventListener('click', () => {
                        this.updateCursorPosition();
                    });
                    this.editor.addEventListener('keyup', () => {
                        this.updateCursorPosition();
                    });
                    this.fileInput.addEventListener('change', event => {
                        this.handleFileSelect(event);
                    });
                    const themeObserver = new MutationObserver(() => {
                        this.updateCSSVariables();
                    });
                    themeObserver.observe(document.documentElement, {
                        attributes: true,
                        attributeFilter: ['class'],
                    });
                    window.addEventListener('languagePreferenceChange', () => {
                        this.updateDocumentTitle();
                        this.applyStatusState();
                    });
                    this.updateWordCount();
                    this.updateCursorPosition();
                },
                /**
                 * Register actions with ActionBus
                 */
                registerActions() {
                    if (!window.ActionBus) return;
                    window.ActionBus.registerAll({
                        'textEditor:clear': () => this.clearEditor(),
                        'textEditor:open': () => this.openFile(),
                        'textEditor:save': () => this.saveFile(),
                        'textEditor:toggleWrap': () => this.toggleWrapMode(),
                        'textEditor:undo': () => this.execCommand('undo'),
                        'textEditor:redo': () => this.execCommand('redo'),
                        'textEditor:cut': () => this.execCommand('cut'),
                        'textEditor:copy': () => this.execCommand('copy'),
                        'textEditor:paste': () => this.handlePaste(),
                        'textEditor:selectAll': () => this.selectAll(),
                        // New formatting actions
                        'textEditor:bold': () => this.wrapSelection('**', '**'),
                        'textEditor:italic': () => this.wrapSelection('*', '*'),
                        'textEditor:underline': () => this.wrapSelection('<u>', '</u>'),
                        'textEditor:strikethrough': () => this.wrapSelection('~~', '~~'),
                        'textEditor:heading1': () => this.insertHeading(1),
                        'textEditor:heading2': () => this.insertHeading(2),
                        'textEditor:heading3': () => this.insertHeading(3),
                        'textEditor:unorderedList': () => this.insertList('unordered'),
                        'textEditor:orderedList': () => this.insertList('ordered'),
                        'textEditor:alignLeft': () => this.alignText('left'),
                        'textEditor:alignCenter': () => this.alignText('center'),
                        'textEditor:alignRight': () => this.alignText('right'),
                        'textEditor:insertLink': () => this.insertLink(),
                        'textEditor:findReplace': () => this.toggleFindReplace(),
                        'textEditor:findNext': () => this.findNext(),
                        'textEditor:replaceOne': () => this.replaceOne(),
                        'textEditor:replaceAll': () => this.replaceAll(),
                        'textEditor:closeFindReplace': () => this.closeFindReplace(),
                    });
                },
                /**
                 * Handle editor input
                 */
                handleEditorInput() {
                    if (!this.editor) return;
                    try {
                        setString('textEditorContent', this.editor.value);
                    } catch (err) {
                        console.warn('Could not save editor content to localStorage:', err);
                    }
                    this.syncSaveButtonState();
                },
                /**
                 * Handle file selection
                 */
                handleFileSelect(event) {
                    var _a;
                    const input = event.target;
                    const file =
                        (_a = input == null ? void 0 : input.files) == null ? void 0 : _a[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = e => {
                        var _a2;
                        const content = (_a2 = e.target) == null ? void 0 : _a2.result;
                        if (typeof content === 'string' && this.editor) {
                            this.editor.value = content;
                            this.updateWordCount();
                            this.updateCursorPosition();
                        }
                        this.currentRemoteFile = { fileName: file.name, content: '' };
                        this.updateDocumentTitle();
                        this.setStatusPlain(file.name);
                        this.syncSaveButtonState();
                        this.focusEditor();
                    };
                    reader.readAsText(file);
                    if (input) {
                        input.value = '';
                    }
                },
                /**
                 * Load saved content from localStorage
                 */
                loadSavedContent() {
                    if (!this.editor) return;
                    try {
                        const saved = getString('textEditorContent');
                        if (saved) {
                            this.editor.value = saved;
                            this.updateWordCount();
                            this.updateCursorPosition();
                        }
                    } catch (err) {
                        console.warn('Could not load saved content:', err);
                    }
                },
                /**
                 * Sync save button state
                 */
                syncSaveButtonState() {
                    if (!this.saveButton || !this.editor) return;
                    this.saveButton.disabled = this.editor.value.length === 0;
                },
                /**
                 * Focus editor
                 */
                focusEditor() {
                    if (this.editor) {
                        this.editor.focus();
                    }
                },
                /**
                 * Clear editor
                 */
                clearEditor() {
                    if (!this.editor) return;
                    this.editor.value = '';
                    this.updateWordCount();
                    this.updateCursorPosition();
                    remove('textEditorContent');
                    this.currentRemoteFile = null;
                    this.updateDocumentTitle();
                    this.clearStatus();
                    this.syncSaveButtonState();
                    this.focusEditor();
                },
                /**
                 * Open file picker
                 */
                openFile() {
                    if (this.fileInput) {
                        this.fileInput.click();
                    }
                },
                /**
                 * Save file
                 */
                saveFile() {
                    if (!this.editor) return;
                    const content = this.editor.value;
                    const blob = new Blob([content], {
                        type: 'text/plain;charset=utf-8',
                    });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const firstLine = content.split('\n')[0] || 'text';
                    const sanitized =
                        firstLine
                            .trim()
                            .substring(0, 20)
                            .replace(/[^a-zA-Z0-9-_]/g, '') || 'text';
                    a.download = `${sanitized}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                },
                /**
                 * Execute document command
                 * @param {string} command - Command to execute
                 */
                execCommand(command) {
                    this.focusEditor();
                    try {
                        if (!document.execCommand(command)) {
                            this.setStatusPlain(`Command ${command} not available`);
                        }
                    } catch (err) {
                        console.warn(`Command ${command} failed:`, err);
                        this.setStatusPlain(`Command ${command} failed`);
                    }
                },
                /**
                 * Handle paste operation
                 */
                handlePaste(e) {
                    this.focusEditor();
                    if (navigator.clipboard && typeof navigator.clipboard.readText === 'function') {
                        navigator.clipboard
                            .readText()
                            .then(text => {
                                if (text && this.editor) {
                                    this.insertTextAtCursor(text);
                                }
                            })
                            .catch(() => {
                                this.execCommand('paste');
                            });
                    } else {
                        this.execCommand('paste');
                    }
                },
                /**
                 * Select all text
                 */
                selectAll() {
                    this.focusEditor();
                    if (this.editor) {
                        this.editor.select();
                    }
                },
                /**
                 * Insert text at cursor position
                 * @param {string} text - Text to insert
                 */
                insertTextAtCursor(text) {
                    if (!this.editor || typeof text !== 'string') return;
                    const start =
                        typeof this.editor.selectionStart === 'number'
                            ? this.editor.selectionStart
                            : this.editor.value.length;
                    const end =
                        typeof this.editor.selectionEnd === 'number'
                            ? this.editor.selectionEnd
                            : start;
                    this.editor.setRangeText(text, start, end, 'end');
                    this.editor.dispatchEvent(new Event('input', { bubbles: true }));
                },
                /**
                 * Update document title
                 */
                updateDocumentTitle() {
                    const titleKey =
                        this.currentRemoteFile && this.currentRemoteFile.fileName
                            ? 'textEditor.documentTitleWithFile'
                            : 'textEditor.documentTitle';
                    const params =
                        this.currentRemoteFile && this.currentRemoteFile.fileName
                            ? { fileName: this.currentRemoteFile.fileName }
                            : void 0;
                    const { text } = this.resolveTranslation(titleKey, params);
                    document.title = text;
                },
                /**
                 * Format file label for display
                 * @param {Object} meta - File metadata
                 * @returns {string} Formatted label
                 */
                formatFileLabel(meta = {}) {
                    const parts = [];
                    if (meta.repo) parts.push(meta.repo);
                    if (meta.path) {
                        parts.push(meta.path);
                    } else if (meta.fileName) {
                        parts.push(meta.fileName);
                    }
                    return parts.join(' / ');
                },
                /**
                 * Set plain text status
                 * @param {string} text - Status text
                 */
                setStatusPlain(text) {
                    if (!text) {
                        this.clearStatus();
                        return;
                    }
                    this.statusState = { type: 'plain', text };
                    this.applyStatusState();
                },
                /**
                 * Set localized status
                 * @param {string} key - Translation key
                 * @param {Object} params - Translation parameters
                 */
                setStatusLocalized(key, params) {
                    this.statusState = {
                        type: 'i18n',
                        key,
                        params: params || void 0,
                    };
                    this.applyStatusState();
                },
                /**
                 * Clear status
                 */
                clearStatus() {
                    this.statusState = null;
                    this.applyStatusState();
                },
                /**
                 * Apply status state to UI
                 */
                applyStatusState() {
                    if (!this.statusBar) return;
                    if (!this.statusState) {
                        this.statusBar.textContent = '';
                        this.statusBar.style.display = 'none';
                        this.statusBar.removeAttribute('data-i18n');
                        this.statusBar.removeAttribute('data-i18n-params');
                        return;
                    }
                    if (this.statusState.type === 'i18n') {
                        const { text, translated } = this.resolveTranslation(
                            this.statusState.key,
                            this.statusState.params
                        );
                        this.statusBar.textContent = text;
                        if (translated) {
                            this.statusBar.setAttribute('data-i18n', this.statusState.key);
                            if (this.statusState.params) {
                                this.statusBar.setAttribute(
                                    'data-i18n-params',
                                    JSON.stringify(this.statusState.params)
                                );
                            } else {
                                this.statusBar.removeAttribute('data-i18n-params');
                            }
                            if (
                                window.appI18n &&
                                typeof window.appI18n.applyTranslations === 'function'
                            ) {
                                window.appI18n.applyTranslations();
                            }
                        } else {
                            this.statusBar.removeAttribute('data-i18n');
                            this.statusBar.removeAttribute('data-i18n-params');
                        }
                    } else {
                        this.statusBar.removeAttribute('data-i18n');
                        this.statusBar.removeAttribute('data-i18n-params');
                        this.statusBar.textContent = this.statusState.text;
                    }
                    this.statusBar.style.display = 'block';
                },
                /**
                 * Resolve translation
                 * @param {string} key - Translation key
                 * @param {Object} params - Translation parameters
                 * @returns {Object} Resolved translation
                 */
                resolveTranslation(key, params) {
                    if (!key) return { text: '', translated: false };
                    const fallbackMessages = {
                        'textEditor.documentTitle': () => 'Texteditor',
                        'textEditor.documentTitleWithFile': p => {
                            const fileName = p && p.fileName ? p.fileName : '';
                            return fileName ? `Texteditor \u2013 ${fileName}` : 'Texteditor';
                        },
                        'textEditor.status.loading': () => 'Lade Datei \u2026',
                        'textEditor.status.loadingWithLabel': p => {
                            const label = p && p.label ? p.label : '';
                            return label ? `${label} (l\xE4dt \u2026)` : 'Lade Datei \u2026';
                        },
                        'textEditor.status.loadError': () => 'Datei konnte nicht geladen werden.',
                        'textEditor.status.rateLimit': () =>
                            'GitHub Rate Limit erreicht. Bitte versuche es sp\xE4ter erneut.',
                        'textEditor.status.wordCount': p => {
                            const words = p && typeof p.words === 'number' ? p.words : 0;
                            const chars = p && typeof p.chars === 'number' ? p.chars : 0;
                            return `Words: ${words} | Characters: ${chars}`;
                        },
                        'textEditor.status.position': p => {
                            const line = p && typeof p.line === 'number' ? p.line : 1;
                            const col = p && typeof p.col === 'number' ? p.col : 1;
                            return `Line ${line}, Col ${col}`;
                        },
                        'textEditor.findReplace.noMatch': () => 'No match found',
                        'textEditor.findReplace.replacedCount': p => {
                            const count = p && typeof p.count === 'number' ? p.count : 0;
                            return `Replaced ${count} occurrence(s)`;
                        },
                    };
                    try {
                        if (window.appI18n && typeof window.appI18n.translate === 'function') {
                            const translated = window.appI18n.translate(key);
                            if (translated && translated !== key) {
                                return { text: translated, translated: true };
                            }
                        }
                    } catch (err) {
                        console.warn('Translation failed, falling back:', err);
                    }
                    const fallbackFn = fallbackMessages[key];
                    if (typeof fallbackFn === 'function') {
                        return { text: fallbackFn(params || {}), translated: false };
                    }
                    return { text: key, translated: false };
                },
                // ==================== Public API for Finder Integration ====================
                /**
                 * Load remote file into editor
                 * @param {Object} payload - File payload
                 * @param {string} payload.content - File content
                 * @param {string} [payload.fileName] - File name
                 * @param {string} [payload.repo] - Repository name
                 * @param {string} [payload.path] - File path
                 */
                loadRemoteFile(payload) {
                    if (typeof payload.content !== 'string') {
                        console.warn('Invalid payload for loadRemoteFile:', payload);
                        return;
                    }
                    const remotePayload = {
                        content: payload.content,
                        fileName: payload.fileName,
                        repo: payload.repo,
                        path: payload.path,
                    };
                    if (this.editor) {
                        this.editor.value = remotePayload.content;
                        this.updateWordCount();
                        this.updateCursorPosition();
                    }
                    this.currentRemoteFile = remotePayload;
                    const label = this.formatFileLabel(remotePayload);
                    this.updateDocumentTitle();
                    this.setStatusPlain(label);
                    try {
                        setString('textEditorContent', remotePayload.content);
                    } catch (err) {
                        console.warn('Could not save to localStorage:', err);
                    }
                    this.syncSaveButtonState();
                    this.focusEditor();
                },
                /**
                 * Show loading state
                 * @param {Object} payload - Loading payload
                 * @param {string} [payload.fileName] - File name
                 * @param {string} [payload.repo] - Repository name
                 * @param {string} [payload.path] - File path
                 */
                showLoading(payload = {}) {
                    const label = this.formatFileLabel(payload);
                    if (label) {
                        this.setStatusLocalized('textEditor.status.loadingWithLabel', {
                            label,
                        });
                    } else {
                        this.setStatusLocalized('textEditor.status.loading');
                    }
                },
                /**
                 * Show load error
                 * @param {Object} payload - Error payload
                 * @param {string} [payload.message] - Error message
                 * @param {string} [payload.fileName] - File name
                 * @param {string} [payload.repo] - Repository name
                 * @param {string} [payload.path] - File path
                 */
                showLoadError(payload = {}) {
                    const label = this.formatFileLabel(payload);
                    const fallback = this.resolveTranslation('textEditor.status.loadError');
                    const message = payload && payload.message ? payload.message : fallback.text;
                    if (label) {
                        this.setStatusPlain(`${label} \u2014 ${message}`);
                    } else {
                        this.setStatusPlain(message);
                    }
                },
                /**
                 * Handle menu action
                 * @param {string} action - Action name
                 */
                handleMenuAction(action) {
                    if (!action) return;
                    const actionMap = {
                        'file:new': 'textEditor:clear',
                        'file:open': 'textEditor:open',
                        'file:save': 'textEditor:save',
                        'edit:undo': 'textEditor:undo',
                        'edit:redo': 'textEditor:redo',
                        'edit:cut': 'textEditor:cut',
                        'edit:copy': 'textEditor:copy',
                        'edit:paste': 'textEditor:paste',
                        'edit:selectAll': 'textEditor:selectAll',
                        'view:toggleWrap': 'textEditor:toggleWrap',
                    };
                    const mappedAction = actionMap[action];
                    if (mappedAction && window.ActionBus) {
                        window.ActionBus.execute(mappedAction);
                    } else {
                        console.warn('Unknown menu action:', action);
                    }
                },
                // ==================== New Formatting Methods ====================
                /**
                 * Wrap selected text with prefix and suffix
                 * @param {string} prefix - Text to insert before selection
                 * @param {string} suffix - Text to insert after selection
                 */
                wrapSelection(prefix, suffix) {
                    if (!this.editor) return;
                    const start = this.editor.selectionStart;
                    const end = this.editor.selectionEnd;
                    const selectedText = this.editor.value.substring(start, end);
                    const wrappedText = prefix + selectedText + suffix;
                    this.editor.setRangeText(wrappedText, start, end, 'select');
                    this.editor.dispatchEvent(new Event('input', { bubbles: true }));
                    this.focusEditor();
                },
                /**
                 * Insert heading at current line
                 * @param {number} level - Heading level (1-3)
                 */
                insertHeading(level) {
                    if (!this.editor) return;
                    const start = this.editor.selectionStart;
                    const text = this.editor.value;
                    const lineStart = text.lastIndexOf('\n', start - 1) + 1;
                    let lineEnd = text.indexOf('\n', start);
                    if (lineEnd === -1) lineEnd = text.length;
                    const currentLine = text.substring(lineStart, lineEnd);
                    const prefix = '#'.repeat(level) + ' ';
                    const headingMatch = currentLine.match(/^#+\s/);
                    let newLine;
                    if (headingMatch) {
                        newLine = prefix + currentLine.substring(headingMatch[0].length);
                    } else {
                        newLine = prefix + currentLine;
                    }
                    this.editor.setRangeText(newLine, lineStart, lineEnd, 'end');
                    this.editor.dispatchEvent(new Event('input', { bubbles: true }));
                    this.focusEditor();
                },
                /**
                 * Insert list at current line or for selected lines
                 * @param {string} type - List type ('ordered' or 'unordered')
                 */
                insertList(type) {
                    if (!this.editor) return;
                    const start = this.editor.selectionStart;
                    const end = this.editor.selectionEnd;
                    const text = this.editor.value;
                    const lineStart = text.lastIndexOf('\n', start - 1) + 1;
                    let lineEnd = text.indexOf('\n', end);
                    if (lineEnd === -1) lineEnd = text.length;
                    const selectedLines = text.substring(lineStart, lineEnd).split('\n');
                    const prefix = type === 'ordered' ? null : '- ';
                    const newLines = selectedLines.map((line, index) => {
                        const cleanLine = line.replace(/^(?:\d+\.\s|-\s|\*\s)/, '');
                        if (type === 'ordered') {
                            return `${index + 1}. ${cleanLine}`;
                        }
                        return `${prefix}${cleanLine}`;
                    });
                    const newText = newLines.join('\n');
                    this.editor.setRangeText(newText, lineStart, lineEnd, 'end');
                    this.editor.dispatchEvent(new Event('input', { bubbles: true }));
                    this.focusEditor();
                },
                /**
                 * Align text (add HTML alignment tags)
                 * @param {string} alignment - Alignment type ('left', 'center', 'right')
                 */
                alignText(alignment) {
                    if (!this.editor) return;
                    const start = this.editor.selectionStart;
                    const end = this.editor.selectionEnd;
                    const text = this.editor.value;
                    const lineStart = text.lastIndexOf('\n', start - 1) + 1;
                    let lineEnd = text.indexOf('\n', end);
                    if (lineEnd === -1) lineEnd = text.length;
                    const selectedText = text.substring(lineStart, lineEnd);
                    const alignedText = `<div style="text-align: ${alignment};">
${selectedText}
</div>`;
                    this.editor.setRangeText(alignedText, lineStart, lineEnd, 'end');
                    this.editor.dispatchEvent(new Event('input', { bubbles: true }));
                    this.focusEditor();
                },
                /**
                 * Insert link at cursor or wrap selection
                 */
                insertLink() {
                    if (!this.editor) return;
                    const start = this.editor.selectionStart;
                    const end = this.editor.selectionEnd;
                    const selectedText = this.editor.value.substring(start, end);
                    const urlLabel =
                        this.resolveTranslation('textEditor.insertLink.enterUrl').text ||
                        'Enter URL:';
                    this.showInputModal(urlLabel, 'https://example.com', 'https://').then(url => {
                        var _a, _b;
                        if (!url) return;
                        const linkText = selectedText || 'link text';
                        const markdown = `[${linkText}](${url})`;
                        (_a = this.editor) == null
                            ? void 0
                            : _a.setRangeText(markdown, start, end, 'end');
                        (_b = this.editor) == null
                            ? void 0
                            : _b.dispatchEvent(new Event('input', { bubbles: true }));
                        this.focusEditor();
                    });
                },
                /**
                 * Update word and character count
                 */
                updateWordCount() {
                    if (!this.editor || !this.wordCountDisplay) return;
                    const text = this.editor.value;
                    const chars = text.length;
                    const trimmedText = text.trim();
                    const words = trimmedText === '' ? 0 : trimmedText.split(/\s+/).length;
                    const wc = this.resolveTranslation('textEditor.status.wordCount', {
                        words,
                        chars,
                    });
                    if (wc.translated) {
                        this.wordCountDisplay.textContent = wc.text;
                        return;
                    }
                    this.wordCountDisplay.textContent = `Words: ${words} | Characters: ${chars}`;
                },
                /**
                 * Update cursor position display
                 */
                updateCursorPosition() {
                    if (!this.editor || !this.lineColDisplay) return;
                    const text = this.editor.value;
                    const pos = this.editor.selectionStart;
                    const textBeforeCursor = text.substring(0, pos);
                    const lines = textBeforeCursor.split('\n');
                    const line = lines.length;
                    const lastLine = lines[lines.length - 1] || '';
                    const col = lastLine.length + 1;
                    const posMsg = this.resolveTranslation('textEditor.status.position', {
                        line,
                        col,
                    });
                    if (posMsg.translated) {
                        this.lineColDisplay.textContent = posMsg.text;
                        return;
                    }
                    this.lineColDisplay.textContent = `Line ${line}, Col ${col}`;
                },
                /**
                 * Toggle find and replace panel
                 */
                toggleFindReplace() {
                    if (!this.findReplacePanel) return;
                    if (this.findReplacePanel.style.display === 'none') {
                        this.findReplacePanel.style.display = 'flex';
                        if (this.findInput) {
                            this.findInput.focus();
                        }
                    } else {
                        this.findReplacePanel.style.display = 'none';
                        this.focusEditor();
                    }
                },
                /**
                 * Close find and replace panel
                 */
                closeFindReplace() {
                    if (!this.findReplacePanel) return;
                    this.findReplacePanel.style.display = 'none';
                    this.focusEditor();
                },
                /**
                 * Find next occurrence
                 */
                findNext() {
                    if (!this.editor || !this.findInput) return;
                    const searchText = this.findInput.value;
                    if (!searchText) return;
                    const text = this.editor.value;
                    const start = this.editor.selectionEnd;
                    const index = text.indexOf(searchText, start);
                    if (index !== -1) {
                        this.editor.setSelectionRange(index, index + searchText.length);
                        this.editor.focus();
                    } else {
                        const firstIndex = text.indexOf(searchText);
                        if (firstIndex !== -1) {
                            this.editor.setSelectionRange(
                                firstIndex,
                                firstIndex + searchText.length
                            );
                            this.editor.focus();
                        } else {
                            const message =
                                this.resolveTranslation('textEditor.findReplace.noMatch').text ||
                                'No match found';
                            this.showToast(message, 'info');
                        }
                    }
                },
                /**
                 * Replace one occurrence
                 */
                replaceOne() {
                    if (!this.editor || !this.findInput || !this.replaceInput) return;
                    const searchText = this.findInput.value;
                    const replaceText = this.replaceInput.value;
                    if (!searchText) return;
                    const start = this.editor.selectionStart;
                    const end = this.editor.selectionEnd;
                    const selectedText = this.editor.value.substring(start, end);
                    if (selectedText === searchText) {
                        this.editor.setRangeText(replaceText, start, end, 'end');
                        this.editor.dispatchEvent(new Event('input', { bubbles: true }));
                        this.findNext();
                    } else {
                        this.findNext();
                    }
                },
                /**
                 * Replace all occurrences
                 */
                replaceAll() {
                    if (!this.editor || !this.findInput || !this.replaceInput) return;
                    const searchText = this.findInput.value;
                    const replaceText = this.replaceInput.value;
                    if (!searchText) return;
                    const text = this.editor.value;
                    const parts = text.split(searchText);
                    const count = parts.length - 1;
                    if (count > 0) {
                        const newText = parts.join(replaceText);
                        this.editor.value = newText;
                        this.editor.dispatchEvent(new Event('input', { bubbles: true }));
                        const message =
                            this.resolveTranslation('textEditor.findReplace.replacedCount', {
                                count,
                            }).text || `Replaced ${count} occurrence(s)`;
                        this.showToast(message, 'success');
                    } else {
                        const message =
                            this.resolveTranslation('textEditor.findReplace.noMatch').text ||
                            'No match found';
                        this.showToast(message, 'info');
                    }
                    this.focusEditor();
                },
                /**
                 * Show toast notification
                 * @param {string} message - Message to display
                 * @param {string} type - Toast type: 'info', 'success', 'error'
                 * @param {number} duration - Display duration in ms (default: 3000)
                 */
                showToast(message, type = 'info', duration = 3e3) {
                    if (!this.container) return;
                    const toast = document.createElement('div');
                    toast.className = `text-editor-toast text-editor-toast-${type}`;
                    toast.textContent = message;
                    if (!this.toastContainer) {
                        this.toastContainer = document.createElement('div');
                        this.toastContainer.className = 'text-editor-toast-container';
                        this.container.appendChild(this.toastContainer);
                    }
                    this.toastContainer.appendChild(toast);
                    setTimeout(() => toast.classList.add('show'), 10);
                    setTimeout(() => {
                        toast.classList.remove('show');
                        setTimeout(() => toast.remove(), 300);
                    }, duration);
                },
                /**
                 * Show input modal dialog
                 * @param {string} title - Modal title
                 * @param {string} placeholder - Input placeholder
                 * @param {string} defaultValue - Default input value
                 * @returns {Promise<string|null>} Resolves with input value or null if cancelled
                 */
                showInputModal(title, defaultValue = '', placeholder = '') {
                    return new Promise(resolve => {
                        const modal = document.createElement('div');
                        modal.className = 'text-editor-modal-overlay';
                        modal.innerHTML = `
                    <div class="text-editor-modal">
                        <div class="text-editor-modal-header">
                            <h3>${title}</h3>
                        </div>
                        <div class="text-editor-modal-body">
                            <input type="text" class="text-editor-modal-input" placeholder="${placeholder}" value="${defaultValue}">
                        </div>
                        <div class="text-editor-modal-footer">
                            <button class="text-editor-modal-btn text-editor-modal-btn-cancel">Cancel</button>
                            <button class="text-editor-modal-btn text-editor-modal-btn-confirm">OK</button>
                        </div>
                    </div>
                `;
                        document.body.appendChild(modal);
                        const input = modal.querySelector('.text-editor-modal-input');
                        const cancelBtn = modal.querySelector('.text-editor-modal-btn-cancel');
                        const confirmBtn = modal.querySelector('.text-editor-modal-btn-confirm');
                        if (!input || !cancelBtn || !confirmBtn) {
                            modal.remove();
                            resolve(null);
                            return;
                        }
                        setTimeout(() => {
                            input == null ? void 0 : input.focus();
                            input == null ? void 0 : input.select();
                        }, 50);
                        const cleanup = () => {
                            modal.classList.add('closing');
                            setTimeout(() => modal.remove(), 200);
                        };
                        const handleConfirm = () => {
                            const value = input == null ? void 0 : input.value.trim();
                            cleanup();
                            resolve(value || '' || null);
                        };
                        const handleCancel = () => {
                            cleanup();
                            resolve(null);
                        };
                        confirmBtn.addEventListener('click', handleConfirm);
                        cancelBtn.addEventListener('click', handleCancel);
                        input.addEventListener('keydown', e => {
                            if (e.key === 'Enter') {
                                e.preventDefault();
                                handleConfirm();
                            } else if (e.key === 'Escape') {
                                e.preventDefault();
                                handleCancel();
                            }
                        });
                        modal.addEventListener('click', e => {
                            if (e.target === modal) {
                                handleCancel();
                            }
                        });
                        setTimeout(() => modal.classList.add('show'), 10);
                    });
                },
                /**
                 * Destroy text editor
                 */
                destroy() {
                    if (this.container) {
                        this.container.innerHTML = '';
                        this.container = null;
                    }
                    this.editor = null;
                    this.statusBar = null;
                    this.saveButton = null;
                    this.fileInput = null;
                    this.wordCountDisplay = null;
                    this.lineColDisplay = null;
                    this.findReplacePanel = null;
                    this.findInput = null;
                    this.replaceInput = null;
                    this.toastContainer = null;
                },
            };
            window.TextEditorSystem = TextEditorSystem;
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    const container = document.getElementById('text-editor-container');
                    if (container) {
                        TextEditorSystem.init(container);
                    }
                });
            } else {
                const container = document.getElementById('text-editor-container');
                if (container) {
                    TextEditorSystem.init(container);
                }
            }
        },
    });

    // src/ts/services/settings.ts
    var init_settings = __esm({
        'src/ts/services/settings.ts'() {
            'use strict';
            console.log('Settings Module loaded');
            (() => {
                'use strict';
                const SettingsSystem = {
                    currentSection: 'general',
                    container: null,
                    /**
                     * Initialize settings module in container
                     */
                    init(containerOrId) {
                        const container =
                            typeof containerOrId === 'string'
                                ? document.getElementById(containerOrId)
                                : containerOrId;
                        if (!container) {
                            console.error('Settings container not found:', containerOrId);
                            return;
                        }
                        this.container = container;
                        this.render();
                        this.attachListeners();
                        this.syncThemePreference();
                        this.syncLanguagePreference();
                        this.showSection('general');
                    },
                    /**
                     * Render settings UI
                     */
                    render() {
                        if (!this.container) return;
                        this.container.innerHTML = `
                <div class="flex dialog-content settings-panel rounded-b-xl overflow-hidden h-full">
                    <!-- Linke Seitenleiste -->
                    <div class="w-48 bg-gray-100 dark:bg-gray-700 p-4 space-y-1 overflow-auto">
                        <button type="button" class="w-full text-left cursor-pointer px-2 py-2 hover:bg-gray-200 dark:hover:bg-gray-600 rounded no-select"
                            data-action="settings:showSection"
                            data-section="general"
                            data-settings-page="general"
                            data-i18n="settingsPage.nav.general">
                            \u{1F464} Allgemein
                        </button>
                        <button type="button" class="w-full text-left cursor-pointer px-2 py-2 hover:bg-gray-200 dark:hover:bg-gray-600 rounded no-select"
                            data-action="settings:showSection"
                            data-section="display"
                            data-settings-page="display"
                            data-i18n="settingsPage.nav.display">
                            \u{1F5A5}\uFE0F Darstellung
                        </button>
                        <button type="button" class="w-full text-left cursor-pointer px-2 py-2 hover:bg-gray-200 dark:hover:bg-gray-600 rounded no-select"
                            data-action="settings:showSection"
                            data-section="language"
                            data-settings-page="language"
                            data-i18n="settingsPage.nav.language">
                            \u{1F310} Sprache
                        </button>
                    </div>
                    <!-- Rechte Hauptansicht -->
                    <div class="flex-1 p-6 overflow-auto text-gray-800 dark:text-gray-200">
                        <!-- Sektion: Allgemein -->
                        <div id="settings-general" class="">
                            <div class="flex flex-col items-start text-gray-700 dark:text-gray-200 mt-8 w-full space-y-4">
                                <img src="./img/profil.jpg" alt="Bild" class="w-24 h-24 object-contain mb-2">
                                <h2 class="text-xl font-semibold" data-i18n="settingsPage.general.name">Marvin Temmen</h2>
                                <p class="text-sm" data-i18n="settingsPage.general.birth">M\xE4rz 1999</p>
                                <div class="bg-gray-200 dark:bg-gray-700 rounded-lg p-4 w-full grid grid-cols-1 sm:grid-cols-2 gap-y-2 gap-x-8">
                                    <div class="text-gray-600 dark:text-gray-300" data-i18n="settingsPage.general.locationLabel">Wohnort</div>
                                    <div class="text-gray-800 dark:text-gray-100" data-i18n="settingsPage.general.locationValue">Deutschland</div>
                                    <div class="text-gray-600 dark:text-gray-300" data-i18n="settingsPage.general.jobLabel">Beruf</div>
                                    <div class="text-gray-800 dark:text-gray-100" data-i18n="settingsPage.general.jobValue">Softwareentwickler</div>
                                </div>
                            </div>
                        </div>
                        <!-- Sektion: Darstellung -->
                        <div id="settings-display" class="hidden">
                            <div class="flex flex-col gap-6 mt-4 w-full">
                                <div>
                                    <h2 class="text-lg font-semibold text-gray-800 dark:text-gray-100"
                                        data-i18n="settingsPage.display.title">Darstellung</h2>
                                    <p class="text-sm text-gray-600 dark:text-gray-300 mt-1"
                                        data-i18n="settingsPage.display.description">
                                        Passe das visuelle Erscheinungsbild der Oberfl\xE4che an.
                                    </p>
                                </div>
                                <fieldset class="bg-gray-100 dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-4 space-y-3">
                                    <legend class="text-sm font-medium text-gray-700 dark:text-gray-200 px-1"
                                        data-i18n="settingsPage.display.legend">Darkmode</legend>
                                    <label class="flex items-center gap-3 cursor-pointer select-none">
                                        <input type="radio" name="theme-mode" value="system" class="h-4 w-4 text-blue-600 focus:ring-blue-500">
                                        <div>
                                            <span class="block text-sm font-medium text-gray-800 dark:text-gray-100"
                                                data-i18n="settingsPage.display.options.system.label">System</span>
                                            <span class="block text-xs text-gray-600 dark:text-gray-300"
                                                data-i18n="settingsPage.display.options.system.description">Folgt den aktuellen Systemeinstellungen.</span>
                                        </div>
                                    </label>
                                    <label class="flex items-center gap-3 cursor-pointer select-none">
                                        <input type="radio" name="theme-mode" value="light" class="h-4 w-4 text-blue-600 focus:ring-blue-500">
                                        <div>
                                            <span class="block text-sm font-medium text-gray-800 dark:text-gray-100"
                                                data-i18n="settingsPage.display.options.light.label">Hell</span>
                                            <span class="block text-xs text-gray-600 dark:text-gray-300"
                                                data-i18n="settingsPage.display.options.light.description">Bleibt immer im hellen Erscheinungsbild.</span>
                                        </div>
                                    </label>
                                    <label class="flex items-center gap-3 cursor-pointer select-none">
                                        <input type="radio" name="theme-mode" value="dark" class="h-4 w-4 text-blue-600 focus:ring-blue-500">
                                        <div>
                                            <span class="block text-sm font-medium text-gray-800 dark:text-gray-100"
                                                data-i18n="settingsPage.display.options.dark.label">Dunkel</span>
                                            <span class="block text-xs text-gray-600 dark:text-gray-300"
                                                data-i18n="settingsPage.display.options.dark.description">Bleibt immer im dunklen Erscheinungsbild.</span>
                                        </div>
                                    </label>
                                </fieldset>
                            </div>
                        </div>
                        <!-- Sektion: Sprache -->
                        <div id="settings-language" class="hidden">
                            <div class="flex flex-col gap-6 mt-4 w-full">
                                <div>
                                    <h2 class="text-lg font-semibold text-gray-800 dark:text-gray-100"
                                        data-i18n="settingsPage.language.title">Sprache</h2>
                                    <p class="text-sm text-gray-600 dark:text-gray-300 mt-1"
                                        data-i18n="settingsPage.language.description">
                                        W\xE4hle, in welcher Sprache die Oberfl\xE4che angezeigt wird.
                                    </p>
                                </div>
                                <fieldset class="bg-gray-100 dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-4 space-y-3">
                                    <legend class="text-sm font-medium text-gray-700 dark:text-gray-200 px-1"
                                        data-i18n="settingsPage.language.legend">Bevorzugte Sprache</legend>
                                    <label class="flex items-center gap-3 cursor-pointer select-none">
                                        <input type="radio" name="language-preference" value="system"
                                            class="h-4 w-4 text-blue-600 focus:ring-blue-500">
                                        <div>
                                            <span class="block text-sm font-medium text-gray-800 dark:text-gray-100"
                                                data-i18n="settingsPage.language.options.system.label">System</span>
                                            <span class="block text-xs text-gray-600 dark:text-gray-300"
                                                data-i18n="settingsPage.language.options.system.description">Verwendet automatisch die Sprache deines Systems.</span>
                                        </div>
                                    </label>
                                    <label class="flex items-center gap-3 cursor-pointer select-none">
                                        <input type="radio" name="language-preference" value="de"
                                            class="h-4 w-4 text-blue-600 focus:ring-blue-500">
                                        <div>
                                            <span class="block text-sm font-medium text-gray-800 dark:text-gray-100"
                                                data-i18n="settingsPage.language.options.de.label">Deutsch</span>
                                            <span class="block text-xs text-gray-600 dark:text-gray-300"
                                                data-i18n="settingsPage.language.options.de.description">Zeigt Inhalte immer auf Deutsch.</span>
                                        </div>
                                    </label>
                                    <label class="flex items-center gap-3 cursor-pointer select-none">
                                        <input type="radio" name="language-preference" value="en"
                                            class="h-4 w-4 text-blue-600 focus:ring-blue-500">
                                        <div>
                                            <span class="block text-sm font-medium text-gray-800 dark:text-gray-100"
                                                data-i18n="settingsPage.language.options.en.label">Englisch</span>
                                            <span class="block text-xs text-gray-600 dark:text-gray-300"
                                                data-i18n="settingsPage.language.options.en.description">Zeigt Inhalte immer auf Englisch.</span>
                                        </div>
                                    </label>
                                </fieldset>
                            </div>
                        </div>
                    </div>
                </div>
            `;
                        const appI18n2 = window.appI18n;
                        if (appI18n2 == null ? void 0 : appI18n2.applyTranslations) {
                            appI18n2.applyTranslations(this.container);
                        }
                    },
                    /**
                     * Attach event listeners
                     */
                    attachListeners() {
                        if (!this.container) return;
                        const themeRadios = this.container.querySelectorAll(
                            'input[name="theme-mode"]'
                        );
                        themeRadios.forEach(radio => {
                            radio.addEventListener('change', () => {
                                var _a;
                                if (!radio.checked) return;
                                const theme = radio.value;
                                const API2 = window.API;
                                if (
                                    (_a = API2 == null ? void 0 : API2.theme) == null
                                        ? void 0
                                        : _a.setThemePreference
                                ) {
                                    API2.theme.setThemePreference(theme);
                                } else {
                                    const ThemeSystem = window.ThemeSystem;
                                    if (
                                        ThemeSystem == null
                                            ? void 0
                                            : ThemeSystem.setThemePreference
                                    ) {
                                        ThemeSystem.setThemePreference(theme);
                                    }
                                }
                            });
                        });
                        const languageRadios = this.container.querySelectorAll(
                            'input[name="language-preference"]'
                        );
                        languageRadios.forEach(radio => {
                            radio.addEventListener('change', () => {
                                var _a;
                                if (!radio.checked) return;
                                const lang = radio.value;
                                const API2 = window.API;
                                if (
                                    (_a = API2 == null ? void 0 : API2.i18n) == null
                                        ? void 0
                                        : _a.setLanguagePreference
                                ) {
                                    API2.i18n.setLanguagePreference(lang);
                                } else {
                                    const appI18n2 = window.appI18n;
                                    if (
                                        appI18n2 == null ? void 0 : appI18n2.setLanguagePreference
                                    ) {
                                        appI18n2.setLanguagePreference(lang);
                                    }
                                }
                            });
                        });
                    },
                    /**
                     * Sync theme preference from global state
                     */
                    syncThemePreference() {
                        var _a;
                        if (!this.container) return;
                        let preference = 'system';
                        const API2 = window.API;
                        const ThemeSystem = window.ThemeSystem;
                        if (
                            (_a = API2 == null ? void 0 : API2.theme) == null
                                ? void 0
                                : _a.getThemePreference
                        ) {
                            preference = API2.theme.getThemePreference();
                        } else if (ThemeSystem == null ? void 0 : ThemeSystem.getThemePreference) {
                            preference = ThemeSystem.getThemePreference();
                        }
                        const themeRadios = this.container.querySelectorAll(
                            'input[name="theme-mode"]'
                        );
                        themeRadios.forEach(radio => {
                            radio.checked = radio.value === preference;
                        });
                    },
                    /**
                     * Sync language preference from global state
                     */
                    syncLanguagePreference() {
                        var _a;
                        if (!this.container) return;
                        let preference = 'system';
                        const API2 = window.API;
                        const appI18n2 = window.appI18n;
                        if (
                            (_a = API2 == null ? void 0 : API2.i18n) == null
                                ? void 0
                                : _a.getLanguagePreference
                        ) {
                            preference = API2.i18n.getLanguagePreference();
                        } else if (appI18n2 == null ? void 0 : appI18n2.getLanguagePreference) {
                            preference = appI18n2.getLanguagePreference();
                        }
                        const languageRadios = this.container.querySelectorAll(
                            'input[name="language-preference"]'
                        );
                        languageRadios.forEach(radio => {
                            radio.checked = radio.value === preference;
                        });
                    },
                    /**
                     * Show specific settings section
                     */
                    showSection(section) {
                        if (!this.container) return;
                        this.currentSection = section;
                        const sections = ['general', 'display', 'language'];
                        sections.forEach(name => {
                            var _a;
                            const el =
                                (_a = this.container) == null
                                    ? void 0
                                    : _a.querySelector(`#settings-${name}`);
                            if (el) {
                                el.classList.add('hidden');
                            }
                        });
                        const target = this.container.querySelector(`#settings-${section}`);
                        if (target) {
                            target.classList.remove('hidden');
                        }
                        const navItems = this.container.querySelectorAll(
                            '[data-action="settings:showSection"]'
                        );
                        navItems.forEach(item => {
                            const itemSection = item.getAttribute('data-section');
                            if (itemSection === section) {
                                item.classList.add(
                                    'bg-white',
                                    'dark:bg-gray-600',
                                    'text-gray-900',
                                    'dark:text-gray-100',
                                    'font-medium'
                                );
                            } else {
                                item.classList.remove(
                                    'bg-white',
                                    'dark:bg-gray-600',
                                    'text-gray-900',
                                    'dark:text-gray-100',
                                    'font-medium'
                                );
                            }
                        });
                    },
                    /**
                     * Destroy settings module
                     */
                    destroy() {
                        if (this.container) {
                            this.container.innerHTML = '';
                            this.container = null;
                        }
                    },
                };
                window.SettingsSystem = SettingsSystem;
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => {
                        const container = document.getElementById('settings-container');
                        if (container) {
                            SettingsSystem.init(container);
                        }
                    });
                } else {
                    const container = document.getElementById('settings-container');
                    if (container) {
                        SettingsSystem.init(container);
                    }
                }
            })();
        },
    });

    // src/ts/apps/photos/image-viewer-utils.ts
    var require_image_viewer_utils = __commonJS({
        'src/ts/apps/photos/image-viewer-utils.ts'() {
            'use strict';
            (function () {
                'use strict';
                function getEl(id) {
                    return document.getElementById(id);
                }
                function applyTranslations2(el) {
                    const w2 = window;
                    if (el && w2.appI18n && typeof w2.appI18n.applyTranslations === 'function') {
                        w2.appI18n.applyTranslations(el);
                    }
                }
                function setPlaceholder(messageKey, params) {
                    const placeholder = getEl('image-placeholder');
                    if (!placeholder) return;
                    if (typeof messageKey !== 'string' || messageKey.length === 0) {
                        placeholder.removeAttribute('data-i18n');
                        placeholder.removeAttribute('data-i18n-params');
                        placeholder.textContent = '';
                        const domUtils = window.DOMUtils;
                        if (domUtils && typeof domUtils.hide === 'function') {
                            domUtils.hide(placeholder);
                        } else {
                            placeholder.classList.add('hidden');
                        }
                        state.placeholder = null;
                        return;
                    }
                    placeholder.setAttribute('data-i18n', messageKey);
                    if (params && Object.keys(params).length > 0) {
                        placeholder.setAttribute('data-i18n-params', JSON.stringify(params));
                    } else {
                        placeholder.removeAttribute('data-i18n-params');
                    }
                    state.placeholder = { key: messageKey, params };
                    applyTranslations2(placeholder);
                    {
                        const domUtils = window.DOMUtils;
                        if (domUtils && typeof domUtils.show === 'function') {
                            domUtils.show(placeholder);
                        } else {
                            placeholder.classList.remove('hidden');
                        }
                    }
                }
                function updateInfo(opts) {
                    const infoEl = getEl('image-info');
                    if (!infoEl) return;
                    const parts = [];
                    if (opts.repo) parts.push(opts.repo);
                    if (opts.path) parts.push(opts.path);
                    const meta = [];
                    if (opts.dimensions) meta.push(opts.dimensions);
                    if (typeof opts.size === 'number' && opts.size > 0) {
                        const kb = (opts.size / 1024).toFixed(1);
                        meta.push(`${kb} KB`);
                    }
                    const info = [parts.join(' / '), meta.join(' \u2022 ')]
                        .filter(Boolean)
                        .join(' \u2014 ');
                    if (info) {
                        infoEl.textContent = info;
                        const domUtils = window.DOMUtils;
                        if (domUtils && typeof domUtils.show === 'function') {
                            domUtils.show(infoEl);
                        } else {
                            infoEl.classList.remove('hidden');
                        }
                    } else {
                        infoEl.textContent = '';
                        const domUtils = window.DOMUtils;
                        if (domUtils && typeof domUtils.hide === 'function') {
                            domUtils.hide(infoEl);
                        } else {
                            infoEl.classList.add('hidden');
                        }
                    }
                }
                const state = { placeholder: null };
                const gw = window;
                if (!gw.__imageViewerUtilsWired) {
                    gw.__imageViewerUtilsWired = true;
                    window.addEventListener('languagePreferenceChange', () => {
                        if (state.placeholder) {
                            setPlaceholder(state.placeholder.key, state.placeholder.params);
                        }
                    });
                }
                const w = window;
                w.ImageViewerUtils = w.ImageViewerUtils || {};
                w.ImageViewerUtils.setPlaceholder = setPlaceholder;
                w.ImageViewerUtils.updateInfo = updateInfo;
                if (typeof w.setImagePlaceholder !== 'function')
                    w.setImagePlaceholder = setPlaceholder;
                if (typeof w.updateImageInfo !== 'function') w.updateImageInfo = updateInfo;
            })();
        },
    });

    // src/ts/ui/keyboard-shortcuts.ts
    var require_keyboard_shortcuts = __commonJS({
        'src/ts/ui/keyboard-shortcuts.ts'() {
            'use strict';
            (function () {
                'use strict';
                const state = {
                    bindings: [],
                    contextResolver: () => 'global',
                    globalListenerAttached: false,
                };
                function isEditable(target) {
                    var _a;
                    if (!(target instanceof Element)) return false;
                    const tag = (_a = target.tagName) == null ? void 0 : _a.toLowerCase();
                    if (tag === 'input' || tag === 'textarea' || tag === 'select') return true;
                    return target.isContentEditable;
                }
                function nextIndex(current, total) {
                    return (current + 1) % total;
                }
                function prevIndex(current, total) {
                    return (current - 1 + total) % total;
                }
                function isBinding(x) {
                    if (typeof x !== 'object' || x === null) return false;
                    const obj = x;
                    return typeof obj.key === 'string' && typeof obj.handler === 'function';
                }
                function register(arg1, arg2 = {}) {
                    if (isBinding(arg1)) {
                        const b = arg1;
                        state.bindings.push(b);
                        ensureGlobalListener();
                        return () => {
                            const idx = state.bindings.indexOf(b);
                            if (idx >= 0) state.bindings.splice(idx, 1);
                        };
                    }
                    const manager = arg1;
                    const scope = arg2.scope || document;
                    const handler = e => {
                        var _a;
                        const mod = e.metaKey || e.ctrlKey;
                        if (!mod) return;
                        if (isEditable(e.target)) return;
                        const key = e.key.toLowerCase();
                        if (key === 'n' || key === 't') {
                            e.preventDefault();
                            const title =
                                (_a = arg2.newTitleFactory) == null ? void 0 : _a.call(arg2);
                            manager.createInstance({ title });
                            return;
                        }
                        const active = manager.getActiveInstance();
                        const instances = manager.getAllInstances();
                        const total = instances.length;
                        if (total === 0) return;
                        if (key === 'w' && active) {
                            e.preventDefault();
                            manager.destroyInstance(active.instanceId);
                            return;
                        }
                        if (key === 'tab') {
                            e.preventDefault();
                            const currentIndex = active
                                ? instances.findIndex(i => i.instanceId === active.instanceId)
                                : -1;
                            const idx = e.shiftKey
                                ? prevIndex(currentIndex, total)
                                : nextIndex(currentIndex, total);
                            const target = instances[idx];
                            if (target) manager.setActiveInstance(target.instanceId);
                            return;
                        }
                        if (/^[1-9]$/.test(key)) {
                            e.preventDefault();
                            const n = parseInt(key, 10);
                            const idx = Math.min(n - 1, total - 1);
                            const target = instances[idx];
                            if (target) manager.setActiveInstance(target.instanceId);
                            return;
                        }
                    };
                    scope.addEventListener('keydown', handler);
                    return () => scope.removeEventListener('keydown', handler);
                }
                function ensureGlobalListener() {
                    if (state.globalListenerAttached) return;
                    const listener = e => {
                        var _a;
                        const mod = e.metaKey || e.ctrlKey;
                        if (!mod) return;
                        if (isEditable(e.target)) return;
                        const key = e.key.toLowerCase();
                        const context =
                            ((_a = state.contextResolver) == null ? void 0 : _a.call(state)) ||
                            'global';
                        const binding = state.bindings.find(b => {
                            if (b.key.toLowerCase() !== key) return false;
                            if (!!b.ctrl !== true) return false;
                            if (!!b.shift !== !!e.shiftKey && b.shift !== void 0) return false;
                            if (b.context && b.context !== context) return false;
                            return true;
                        });
                        if (binding) {
                            e.preventDefault();
                            try {
                                binding.handler();
                            } catch {}
                        }
                    };
                    document.addEventListener('keydown', listener);
                    state.globalListenerAttached = true;
                }
                function setContextResolver(resolver) {
                    state.contextResolver = resolver;
                    ensureGlobalListener();
                }
                const KeyboardShortcuts = { register, setContextResolver };
                window.KeyboardShortcuts = KeyboardShortcuts;
            })();
        },
    });

    // src/ts/services/github-api.ts
    var require_github_api = __commonJS({
        'src/ts/services/github-api.ts'() {
            'use strict';
            init_storage_utils();
            (function () {
                'use strict';
                const GITHUB_CACHE_NS = 'finderGithubCacheV1:';
                function getCacheTtl() {
                    const dflt = 5 * 60 * 1e3;
                    try {
                        const constants = window.APP_CONSTANTS || {};
                        const val = constants['GITHUB_CACHE_DURATION'];
                        return typeof val === 'number' ? val : dflt;
                    } catch {
                        return dflt;
                    }
                }
                function makeCacheKey(kind, repo = '', subPath = '') {
                    if (kind === 'repos') return GITHUB_CACHE_NS + 'repos';
                    return `${GITHUB_CACHE_NS}contents:${repo}:${subPath}`;
                }
                function writeCache(kind, repo, subPath, data) {
                    const key = makeCacheKey(kind, repo, subPath);
                    try {
                        const payload = { t: Date.now(), d: data };
                        setJSON(key, payload);
                    } catch {}
                }
                function readCache(kind, repo = '', subPath = '') {
                    var _a;
                    const key = makeCacheKey(kind, repo, subPath);
                    try {
                        const parsed = getJSON(key, null);
                        if (!parsed || typeof parsed !== 'object') return null;
                        const ttl = getCacheTtl();
                        if (typeof parsed.t !== 'number' || Date.now() - parsed.t > ttl)
                            return null;
                        return (_a = parsed.d) != null ? _a : null;
                    } catch {
                        return null;
                    }
                }
                function getHeaders() {
                    const headers = { Accept: 'application/vnd.github.v3+json' };
                    try {
                        const token = getString('githubToken');
                        if (token && token.trim()) {
                            headers['Authorization'] = `token ${token.trim()}`;
                        }
                    } catch {}
                    return headers;
                }
                async function fetchJSON(url) {
                    const res = await fetch(url, { headers: getHeaders() });
                    if (!res.ok) {
                        throw Object.assign(new Error(`GitHub API error: ${res.status}`), {
                            status: res.status,
                        });
                    }
                    return res.json();
                }
                async function fetchUserRepos(username, params) {
                    var _a, _b;
                    const search = new globalThis.URLSearchParams();
                    search.set(
                        'per_page',
                        String((_a = params == null ? void 0 : params.per_page) != null ? _a : 100)
                    );
                    search.set(
                        'sort',
                        (_b = params == null ? void 0 : params.sort) != null ? _b : 'updated'
                    );
                    const url = `https://api.github.com/users/${encodeURIComponent(username)}/repos?${search.toString()}`;
                    return fetchJSON(url);
                }
                async function fetchRepoContents(username, repo, subPath = '') {
                    const pathPart = subPath
                        ? `/${encodeURIComponent(subPath).replace(/%2F/g, '/')}`
                        : '';
                    const url = `https://api.github.com/repos/${encodeURIComponent(username)}/${encodeURIComponent(repo)}/contents${pathPart}`;
                    return fetchJSON(url);
                }
                window.GitHubAPI = {
                    getHeaders,
                    readCache,
                    writeCache,
                    fetchJSON,
                    fetchUserRepos,
                    fetchRepoContents,
                };
            })();
        },
    });

    // src/ts/apps/photos/photos-app.ts
    var require_photos_app = __commonJS({
        'src/ts/apps/photos/photos-app.ts'() {
            'use strict';
            var globalWindow = window;
            function t2(key, fallback, params) {
                var _a;
                const translate2 = (_a = globalWindow.appI18n) == null ? void 0 : _a.translate;
                if (typeof translate2 === 'function') {
                    return translate2(key, params, { fallback });
                }
                return fallback;
            }
            (function photosAppFactory() {
                const state = {
                    initialized: false,
                    photos: [],
                    filteredPhotos: [],
                    filteredIndexMap: /* @__PURE__ */ new Map(),
                    favorites: /* @__PURE__ */ new Set(),
                    activeFilter: 'all',
                    activeSegment: 'moments',
                    searchTerm: '',
                    isLoading: false,
                    currentPage: 1,
                    overlayVisible: false,
                    selectedIndex: -1,
                    activePhotoId: null,
                    externalPhoto: null,
                    pendingImageId: null,
                    orientationCounts: { landscape: 0, portrait: 0, square: 0 },
                };
                const elements = {
                    container: null,
                    sidebar: null,
                    gallery: null,
                    loading: null,
                    error: null,
                    errorRetry: null,
                    empty: null,
                    placeholder: null,
                    photoCount: null,
                    refreshButton: null,
                    searchInput: null,
                    searchClear: null,
                    sidebarButtons: [],
                    segmentButtons: [],
                    overlay: null,
                    detailTitle: null,
                    detailMeta: null,
                    detailDimensions: null,
                    detailCounter: null,
                    detailOpen: null,
                    detailDownload: null,
                    detailFavorite: null,
                    detailFavoriteLabel: null,
                    detailFavoriteIcon: null,
                    detailClose: null,
                    detailPrev: null,
                    detailNext: null,
                    image: null,
                    imageInfo: null,
                    loader: null,
                    countAll: null,
                    countFavorites: null,
                    countLandscape: null,
                    countPortrait: null,
                    countSquare: null,
                    titlebar: null,
                    statusbar: null,
                };
                function isExternalPhoto(photo) {
                    return photo.isExternal === true;
                }
                function renderWindow() {
                    const WindowChrome2 = globalWindow.WindowChrome;
                    if (!WindowChrome2) {
                        console.error('WindowChrome not available');
                        return null;
                    }
                    const { frame, titlebar, content, statusbar } = WindowChrome2.createWindowFrame(
                        {
                            title: t2('photos.title', 'Fotos'),
                            icon: './img/fotos.png',
                            showClose: true,
                            showMinimize: false,
                            showMaximize: false,
                            onClose: () => {
                                var _a, _b, _c;
                                (_c =
                                    (_b = (_a = globalWindow.API) == null ? void 0 : _a.window) ==
                                    null
                                        ? void 0
                                        : _b.close) == null
                                    ? void 0
                                    : _c.call(_b, 'photos-window');
                            },
                            toolbar: [
                                {
                                    label: '',
                                    icon: `<div class="relative flex-1 sm:flex-initial min-w-[200px]">
                        <input id="photos-search" type="search" placeholder="${t2('photos.search.placeholder', 'Nach Autor suchen')}" 
                            class="w-full rounded-2xl border border-gray-300 dark:border-gray-700 bg-white/70 dark:bg-gray-900/70 px-4 py-2 text-sm text-gray-700 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-400" />
                        <button id="photos-search-clear" type="button" class="absolute inset-y-0 right-2 flex items-center text-xl text-gray-400 hover:text-gray-600 dark:text-gray-500 dark:hover:text-gray-300 invisible pointer-events-none" 
                            title="${t2('photos.search.clear', 'Suche l\xF6schen')}">\xD7</button>
                    </div>`,
                                },
                                { type: 'separator' },
                                {
                                    label: '',
                                    icon: `<div class="flex bg-gray-200 dark:bg-gray-800 rounded-full p-1 text-sm font-medium text-gray-600 dark:text-gray-300 shadow-inner" role="group">
                        <button type="button" data-photos-segment="moments" class="photos-segment-button">${t2('photos.segments.moments', 'Momente')}</button>
                        <button type="button" data-photos-segment="collections" class="photos-segment-button">${t2('photos.segments.collections', 'Sammlungen')}</button>
                        <button type="button" data-photos-segment="years" class="photos-segment-button">${t2('photos.segments.years', 'Jahre')}</button>
                    </div>`,
                                },
                            ],
                            showStatusBar: true,
                            statusBarLeft: t2('photos.status.countPlaceholder', '\u2013 Fotos'),
                            statusBarRight: '',
                        }
                    );
                    elements.titlebar = titlebar;
                    elements.statusbar = statusbar;
                    const sidebar = document.createElement('aside');
                    sidebar.className =
                        'hidden md:flex flex-col w-56 border-r border-gray-200 dark:border-gray-800 bg-gray-50/80 dark:bg-gray-900/60';
                    sidebar.innerHTML = `
            <div class="px-5 pt-6 pb-4">
                <p class="text-xs uppercase tracking-[0.2em] text-gray-400 dark:text-gray-500">${t2('photos.sidebar.library', 'Bibliothek')}</p>
                <nav class="mt-4 space-y-1" id="photos-sidebar">
                    <button type="button" data-photos-filter="all" class="photos-sidebar-button">
                        <span>${t2('photos.sidebar.items.all', 'Alle Fotos')}</span>
                        <span id="photos-count-all" class="photos-sidebar-count">\u2013</span>
                    </button>
                    <button type="button" data-photos-filter="favorites" class="photos-sidebar-button">
                        <span>${t2('photos.sidebar.items.favorites', 'Favoriten')}</span>
                        <span id="photos-count-favorites" class="photos-sidebar-count">0</span>
                    </button>
                </nav>
                <p class="text-xs uppercase tracking-[0.2em] text-gray-400 dark:text-gray-500 mt-6">${t2('photos.sidebar.filters', 'Filter')}</p>
                <nav class="mt-4 space-y-1">
                    <button type="button" data-photos-filter="landscape" class="photos-sidebar-button">
                        <span>${t2('photos.sidebar.items.landscape', 'Querformat')}</span>
                        <span id="photos-count-landscape" class="photos-sidebar-count">\u2013</span>
                    </button>
                    <button type="button" data-photos-filter="portrait" class="photos-sidebar-button">
                        <span>${t2('photos.sidebar.items.portrait', 'Hochformat')}</span>
                        <span id="photos-count-portrait" class="photos-sidebar-count">\u2013</span>
                    </button>
                    <button type="button" data-photos-filter="square" class="photos-sidebar-button">
                        <span>${t2('photos.sidebar.items.square', 'Quadratisch')}</span>
                        <span id="photos-count-square" class="photos-sidebar-count">\u2013</span>
                    </button>
                </nav>
            </div>
            <div class="px-5 pb-6 mt-auto">
                <button id="photos-refresh" type="button" class="w-full inline-flex items-center justify-center gap-2 px-3 py-2 text-sm font-medium rounded-2xl bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 text-gray-700 dark:text-gray-200 transition hover:border-blue-400 hover:text-blue-600 dark:hover:border-blue-400 dark:hover:text-blue-300">
                    <span aria-hidden="true">\u21BB</span>
                    <span>${t2('photos.sidebar.refresh', 'Neu laden')}</span>
                </button>
                <p class="text-[11px] text-gray-400 dark:text-gray-500 mt-3 leading-relaxed">${t2('photos.sidebar.sourceNote', 'Quelle: Lorem Picsum \u2013 zuf\xE4llige kuratierte Fotokollektionen.')}</p>
            </div>
        `;
                    const mainArea = document.createElement('div');
                    mainArea.className = 'flex-1 flex flex-col min-h-0 relative';
                    mainArea.innerHTML = `
            <div class="flex-1 relative min-h-0">
                <div id="photos-loading" class="absolute inset-0 flex items-center justify-center bg-white/80 dark:bg-gray-900/80 z-20 hidden">
                    <div class="flex flex-col items-center gap-2 text-gray-600 dark:text-gray-300">
                        <span class="h-10 w-10 border-4 border-gray-300 dark:border-gray-700 border-t-blue-500 dark:border-t-blue-400 rounded-full animate-spin"></span>
                        <span class="text-sm font-medium">${t2('photos.status.loading', 'Lade Fotos\u2026')}</span>
                    </div>
                </div>
                <div id="photos-error" class="absolute inset-x-0 top-6 mx-auto max-w-lg bg-red-50 dark:bg-red-900/40 text-red-700 dark:text-red-200 rounded-2xl shadow px-5 py-4 hidden">
                    <p class="font-semibold mb-1">${t2('photos.errors.heading', 'Fehler beim Laden')}</p>
                    <p class="text-sm">${t2('photos.errors.description', 'Bitte \xFCberpr\xFCfe deine Verbindung und versuche es erneut.')}</p>
                    <button id="photos-error-retry" type="button" class="mt-3 inline-flex items-center gap-2 text-sm font-medium text-red-700 dark:text-red-100 underline decoration-dotted">${t2('photos.buttons.retry', 'Erneut versuchen')}</button>
                </div>
                <div id="photos-gallery" class="absolute inset-0 overflow-y-auto px-5 sm:px-6 py-6 space-y-8"></div>
                <div id="photos-empty" class="absolute inset-0 flex items-center justify-center text-center text-gray-500 dark:text-gray-400 hidden px-6">
                    <div>
                        <p class="text-lg font-semibold">${t2('photos.empty.title', 'Keine Fotos gefunden')}</p>
                        <p class="text-sm mt-1">${t2('photos.empty.description', 'Passe Suche oder Filter an, um weitere Ergebnisse zu sehen.')}</p>
                    </div>
                </div>
                <div id="image-placeholder" class="absolute inset-0 flex items-center justify-center text-gray-500 dark:text-gray-400 text-center px-6 hidden pointer-events-none">${t2('photos.placeholder', 'W\xE4hle ein Foto aus, um Details zu sehen.')}</div>
            </div>
        `;
                    const detailOverlay = document.createElement('div');
                    detailOverlay.id = 'photo-detail-overlay';
                    detailOverlay.className =
                        'absolute inset-0 hidden items-center justify-center px-4 py-10 bg-black/50 backdrop-blur-sm z-30';
                    detailOverlay.innerHTML = `
            <div class="bg-white dark:bg-gray-900 rounded-3xl shadow-2xl overflow-hidden max-w-5xl w-full h-full flex flex-col">
                <div class="flex items-center gap-4 px-6 py-4 border-b border-gray-200 dark:border-gray-800">
                    <div class="flex-1 min-w-0">
                        <p id="photo-detail-title" class="text-xl font-semibold text-gray-900 dark:text-gray-100 truncate">${t2('photos.detail.titleFallback', 'Foto')}</p>
                        <p id="photo-detail-meta" class="text-sm text-gray-500 dark:text-gray-400 mt-1 truncate"></p>
                    </div>
                    <div class="flex items-center gap-2">
                        <button id="photo-detail-favorite" type="button" class="inline-flex items-center gap-2 px-3 py-1.5 rounded-full bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-200 text-sm font-medium transition hover:bg-gray-200 dark:hover:bg-gray-700">
                            <span aria-hidden="true">\u2661</span>
                            <span>${t2('photos.detail.favoriteAdd', 'Zu Favoriten')}</span>
                        </button>
                        <a id="photo-detail-download" class="inline-flex items-center gap-2 px-3 py-1.5 rounded-full bg-blue-600 text-white text-sm font-medium transition hover:bg-blue-500" href="#" target="_blank" rel="noreferrer">${t2('photos.detail.download', 'Herunterladen')}</a>
                        <button id="photo-detail-close" type="button" class="inline-flex items-center justify-center w-9 h-9 rounded-full bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-200 text-lg leading-none transition hover:bg-gray-200 dark:hover:bg-gray-700" title="${t2('common.close', 'Schlie\xDFen')}">\xD7</button>
                    </div>
                </div>
                <div class="flex-1 flex overflow-hidden">
                    <button id="photo-detail-prev" type="button" class="hidden sm:flex items-center justify-center w-14 bg-transparent text-3xl text-gray-400 dark:text-gray-500 hover:text-gray-700 dark:hover:text-gray-200 transition" title="${t2('photos.detail.prev', 'Vorheriges Foto')}">\u2039</button>
                    <div class="flex-1 relative bg-gray-50 dark:bg-gray-950 flex items-center justify-center overflow-hidden">
                        <img id="image-viewer" class="max-w-full max-h-full object-contain" alt="${t2('photos.detail.imageAlt', 'Ausgew\xE4hltes Foto')}" />
                        <div id="photo-detail-loader" class="absolute inset-0 flex items-center justify-center bg-gray-900/40 text-white text-sm font-medium hidden">${t2('photos.detail.loader', 'Foto wird geladen\u2026')}</div>
                    </div>
                    <button id="photo-detail-next" type="button" class="hidden sm:flex items-center justify-center w-14 bg-transparent text-3xl text-gray-400 dark:text-gray-500 hover:text-gray-700 dark:hover:text-gray-200 transition" title="${t2('photos.detail.next', 'N\xE4chstes Foto')}">\u203A</button>
                </div>
                <div class="px-6 py-4 border-t border-gray-200 dark:border-gray-800 flex flex-wrap items-center gap-x-6 gap-y-2 text-sm text-gray-600 dark:text-gray-300">
                    <div class="flex-1 min-w-[200px]">
                        <p id="image-info" class="font-medium text-gray-700 dark:text-gray-200"></p>
                        <p id="photo-detail-dimensions" class="text-xs text-gray-500 dark:text-gray-400 mt-1"></p>
                    </div>
                    <div class="flex items-center gap-3">
                        <span id="photo-detail-counter" class="text-xs font-medium"></span>
                        <a id="photo-detail-open" href="#" target="_blank" rel="noreferrer" class="text-blue-600 dark:text-blue-400 hover:underline">${t2('photos.detail.openInBrowser', 'Im Browser \xF6ffnen')}</a>
                    </div>
                </div>
            </div>
        `;
                    const container = document.createElement('div');
                    container.className = 'flex h-full';
                    container.appendChild(sidebar);
                    container.appendChild(mainArea);
                    content.appendChild(container);
                    content.appendChild(detailOverlay);
                    return frame;
                }
                function init() {
                    var _a, _b, _c;
                    if (state.initialized) {
                        return;
                    }
                    state.initialized = true;
                    const photosWindow = document.getElementById('photos-window');
                    if (!photosWindow) {
                        const frame = renderWindow();
                        if (!frame) {
                            console.error('Failed to render photos window');
                            return;
                        }
                        let container = document.getElementById('photos-window');
                        if (!container) {
                            container = document.createElement('div');
                            container.id = 'photos-window';
                            container.className =
                                'fixed inset-0 flex items-center justify-center hidden modal relative';
                            container.style.zIndex = '1000';
                            document.body.appendChild(container);
                        }
                        const wrapper = document.createElement('div');
                        wrapper.className = 'w-[min(90vw,1100px)] h-[min(85vh,780px)]';
                        wrapper.appendChild(frame);
                        container.appendChild(wrapper);
                        elements.container = container;
                    } else {
                        elements.container = photosWindow;
                    }
                    cacheElements();
                    if (!elements.gallery) {
                        return;
                    }
                    wireSidebar();
                    wireSegments();
                    wireSearch();
                    wireGallery();
                    wireDetail();
                    (_c = (_a = globalWindow.appI18n) == null ? void 0 : _a.applyTranslations) ==
                    null
                        ? void 0
                        : _c.call(_a, (_b = elements.container) != null ? _b : void 0);
                    void fetchPhotos();
                }
                function cacheElements() {
                    var _a,
                        _b,
                        _c,
                        _d,
                        _e,
                        _f,
                        _g,
                        _h,
                        _i,
                        _j,
                        _k,
                        _l,
                        _m,
                        _n,
                        _o,
                        _p,
                        _q,
                        _r,
                        _s,
                        _t,
                        _u,
                        _v,
                        _w,
                        _x,
                        _y,
                        _z;
                    if (!elements.container) {
                        return;
                    }
                    elements.sidebar =
                        (_a = elements.container.querySelector('#photos-sidebar')) != null
                            ? _a
                            : null;
                    elements.gallery =
                        (_b = elements.container.querySelector('#photos-gallery')) != null
                            ? _b
                            : null;
                    elements.loading =
                        (_c = elements.container.querySelector('#photos-loading')) != null
                            ? _c
                            : null;
                    elements.error =
                        (_d = elements.container.querySelector('#photos-error')) != null
                            ? _d
                            : null;
                    elements.errorRetry = elements.container.querySelector('#photos-error-retry');
                    elements.empty =
                        (_e = elements.container.querySelector('#photos-empty')) != null
                            ? _e
                            : null;
                    elements.placeholder =
                        (_f = elements.container.querySelector('#image-placeholder')) != null
                            ? _f
                            : null;
                    elements.photoCount =
                        (_h =
                            (_g = elements.statusbar) == null
                                ? void 0
                                : _g.querySelector('.statusbar-left')) != null
                            ? _h
                            : null;
                    elements.refreshButton = elements.container.querySelector('#photos-refresh');
                    elements.searchInput = elements.container.querySelector('#photos-search');
                    elements.searchClear = elements.container.querySelector('#photos-search-clear');
                    elements.overlay =
                        (_i = elements.container.querySelector('#photo-detail-overlay')) != null
                            ? _i
                            : null;
                    elements.detailTitle =
                        (_j = elements.container.querySelector('#photo-detail-title')) != null
                            ? _j
                            : null;
                    elements.detailMeta =
                        (_k = elements.container.querySelector('#photo-detail-meta')) != null
                            ? _k
                            : null;
                    elements.detailDimensions =
                        (_l = elements.container.querySelector('#photo-detail-dimensions')) != null
                            ? _l
                            : null;
                    elements.detailCounter =
                        (_m = elements.container.querySelector('#photo-detail-counter')) != null
                            ? _m
                            : null;
                    elements.detailOpen = elements.container.querySelector('#photo-detail-open');
                    elements.detailDownload =
                        elements.container.querySelector('#photo-detail-download');
                    elements.detailFavorite =
                        elements.container.querySelector('#photo-detail-favorite');
                    elements.detailFavoriteLabel =
                        (_o =
                            (_n = elements.detailFavorite) == null
                                ? void 0
                                : _n.querySelector('span:last-child')) != null
                            ? _o
                            : null;
                    elements.detailFavoriteIcon =
                        (_q =
                            (_p = elements.detailFavorite) == null
                                ? void 0
                                : _p.querySelector('span[aria-hidden="true"]')) != null
                            ? _q
                            : null;
                    elements.detailClose = elements.container.querySelector('#photo-detail-close');
                    elements.detailPrev = elements.container.querySelector('#photo-detail-prev');
                    elements.detailNext = elements.container.querySelector('#photo-detail-next');
                    elements.image = elements.container.querySelector('#image-viewer');
                    elements.imageInfo =
                        (_r = elements.container.querySelector('#image-info')) != null ? _r : null;
                    elements.loader =
                        (_s = elements.container.querySelector('#photo-detail-loader')) != null
                            ? _s
                            : null;
                    elements.countAll =
                        (_t = elements.container.querySelector('#photos-count-all')) != null
                            ? _t
                            : null;
                    elements.countFavorites =
                        (_u = elements.container.querySelector('#photos-count-favorites')) != null
                            ? _u
                            : null;
                    elements.countLandscape =
                        (_v = elements.container.querySelector('#photos-count-landscape')) != null
                            ? _v
                            : null;
                    elements.countPortrait =
                        (_w = elements.container.querySelector('#photos-count-portrait')) != null
                            ? _w
                            : null;
                    elements.countSquare =
                        (_x = elements.container.querySelector('#photos-count-square')) != null
                            ? _x
                            : null;
                    const sidebarButtons =
                        (_z =
                            (_y = elements.sidebar) == null
                                ? void 0
                                : _y.querySelectorAll('button[data-photos-filter]')) != null
                            ? _z
                            : [];
                    elements.sidebarButtons = Array.from(sidebarButtons);
                    const segmentButtons = elements.container.querySelectorAll(
                        'button[data-photos-segment]'
                    );
                    elements.segmentButtons = Array.from(segmentButtons);
                }
                function wireSidebar() {
                    var _a;
                    elements.sidebarButtons.forEach(button => {
                        button.addEventListener('click', () => {
                            const filter = button.getAttribute('data-photos-filter');
                            if (!filter || state.activeFilter === filter) {
                                return;
                            }
                            state.activeFilter = filter;
                            syncSidebarSelection();
                            applyFilters();
                        });
                    });
                    syncSidebarSelection();
                    (_a = elements.refreshButton) == null
                        ? void 0
                        : _a.addEventListener('click', () => {
                              void fetchPhotos({ refresh: true });
                          });
                }
                function wireSegments() {
                    elements.segmentButtons.forEach(button => {
                        button.addEventListener('click', () => {
                            const segment = button.getAttribute('data-photos-segment');
                            if (!segment || state.activeSegment === segment) {
                                return;
                            }
                            state.activeSegment = segment;
                            syncSegmentSelection();
                            renderGallery();
                        });
                    });
                    syncSegmentSelection();
                }
                function wireSearch() {
                    var _a, _b;
                    (_a = elements.searchInput) == null
                        ? void 0
                        : _a.addEventListener('input', event => {
                              const target = event.currentTarget;
                              state.searchTerm = target.value;
                              toggleSearchClear();
                              applyFilters();
                          });
                    (_b = elements.searchClear) == null
                        ? void 0
                        : _b.addEventListener('click', () => {
                              if (!elements.searchInput) {
                                  return;
                              }
                              elements.searchInput.value = '';
                              state.searchTerm = '';
                              toggleSearchClear();
                              applyFilters();
                          });
                    toggleSearchClear();
                }
                function wireGallery() {
                    var _a;
                    (_a = elements.gallery) == null
                        ? void 0
                        : _a.addEventListener('click', event => {
                              const target = event.target;
                              if (!target) {
                                  return;
                              }
                              const card = target.closest('[data-photo-index]');
                              if (!card) {
                                  return;
                              }
                              const rawIndex = card.getAttribute('data-photo-index');
                              const index = rawIndex ? Number(rawIndex) : NaN;
                              if (Number.isNaN(index) || index < 0) {
                                  return;
                              }
                              openDetail(index);
                          });
                }
                function wireDetail() {
                    var _a, _b, _c, _d, _e, _f;
                    (_a = elements.detailClose) == null
                        ? void 0
                        : _a.addEventListener('click', closeDetail);
                    (_b = elements.overlay) == null
                        ? void 0
                        : _b.addEventListener('click', event => {
                              if (event.target === elements.overlay) {
                                  closeDetail();
                              }
                          });
                    (_c = elements.detailPrev) == null
                        ? void 0
                        : _c.addEventListener('click', () => moveSelection(-1));
                    (_d = elements.detailNext) == null
                        ? void 0
                        : _d.addEventListener('click', () => moveSelection(1));
                    (_e = elements.detailFavorite) == null
                        ? void 0
                        : _e.addEventListener('click', toggleFavorite);
                    document.addEventListener('keydown', handleKeyNavigation);
                    (_f = elements.errorRetry) == null
                        ? void 0
                        : _f.addEventListener('click', () => {
                              void fetchPhotos({ refresh: true });
                          });
                    if (elements.image) {
                        elements.image.addEventListener('load', handleImageLoaded);
                        elements.image.addEventListener('error', handleImageError);
                    }
                }
                function handleImageLoaded() {
                    setDetailLoading(false);
                    if (!elements.image) {
                        return;
                    }
                    if (state.pendingImageId) {
                        const width = elements.image.naturalWidth;
                        const height = elements.image.naturalHeight;
                        const orientation =
                            width === height ? 'square' : width > height ? 'landscape' : 'portrait';
                        if (
                            state.externalPhoto &&
                            state.externalPhoto.id === state.pendingImageId
                        ) {
                            state.externalPhoto.width = width;
                            state.externalPhoto.height = height;
                            state.externalPhoto.orientation = orientation;
                        }
                        if (state.overlayVisible) {
                            const current = getCurrentDetailPhoto();
                            if (current) {
                                updateDetailMetadata(current);
                            }
                        }
                    }
                    state.pendingImageId = null;
                }
                function handleImageError() {
                    setDetailLoading(false);
                    if (elements.detailMeta) {
                        elements.detailMeta.textContent = t2(
                            'photos.errors.detailImage',
                            'The photo could not be loaded.'
                        );
                    }
                }
                async function fetchPhotos(options = {}) {
                    if (state.isLoading) {
                        return;
                    }
                    setError(false);
                    setLoading(true);
                    try {
                        const shouldRandomize = options.refresh || state.photos.length === 0;
                        const page = shouldRandomize ? getRandomPage() : state.currentPage;
                        const limit = 60;
                        const response = await fetch(
                            `https://picsum.photos/v2/list?page=${page}&limit=${limit}`
                        );
                        if (!response.ok) {
                            throw new Error('Picsum request failed');
                        }
                        const data = await response.json();
                        const mapped = data.map(mapPhotoItem);
                        state.photos = mapped;
                        state.currentPage = page;
                        state.favorites.clear();
                        state.externalPhoto = null;
                        state.orientationCounts = calculateOrientationCounts(mapped);
                        applyFilters();
                        updateSidebarCounts();
                    } catch (error) {
                        console.warn('Photos app: failed to load', error);
                        setError(true);
                    } finally {
                        setLoading(false);
                    }
                }
                function mapPhotoItem(item, index) {
                    const width = Number(item.width) || 0;
                    const height = Number(item.height) || 0;
                    const orientation =
                        width === height ? 'square' : width > height ? 'landscape' : 'portrait';
                    const numericId = Number.parseInt(item.id, 10);
                    const yearBase = Number.isFinite(numericId) ? numericId : index;
                    const year = 2014 + ((yearBase % 10) + 1);
                    const sanitizedAuthor =
                        item.author && item.author.trim().length > 0
                            ? item.author.trim()
                            : t2('photos.detail.unknownPhotographer', 'Unknown photographer');
                    const id = String(item.id);
                    return {
                        id,
                        author: sanitizedAuthor,
                        width,
                        height,
                        orientation,
                        year,
                        url: item.url,
                        downloadUrl: item.download_url,
                        thumbUrl: `https://picsum.photos/id/${id}/600/400`,
                        largeUrl: `https://picsum.photos/id/${id}/1600/1200`,
                    };
                }
                function calculateOrientationCounts(photos) {
                    return photos.reduce(
                        (acc, photo) => {
                            acc[photo.orientation] += 1;
                            return acc;
                        },
                        { landscape: 0, portrait: 0, square: 0 }
                    );
                }
                function applyFilters() {
                    const search = state.searchTerm.trim().toLowerCase();
                    const previousActiveId = state.overlayVisible ? state.activePhotoId : null;
                    const filtered = state.photos.filter(photo => {
                        if (state.activeFilter === 'favorites' && !state.favorites.has(photo.id)) {
                            return false;
                        }
                        if (
                            state.activeFilter === 'landscape' &&
                            photo.orientation !== 'landscape'
                        ) {
                            return false;
                        }
                        if (state.activeFilter === 'portrait' && photo.orientation !== 'portrait') {
                            return false;
                        }
                        if (state.activeFilter === 'square' && photo.orientation !== 'square') {
                            return false;
                        }
                        if (search && !photo.author.toLowerCase().includes(search)) {
                            return false;
                        }
                        return true;
                    });
                    state.filteredPhotos = filtered;
                    state.filteredIndexMap = new Map(
                        filtered.map((photo, index) => [photo.id, index])
                    );
                    renderGallery();
                    updateEmptyState();
                    updatePhotoCount();
                    updateSidebarCounts();
                    if (previousActiveId) {
                        const newIndex = state.filteredIndexMap.get(previousActiveId);
                        if (typeof newIndex === 'number') {
                            state.selectedIndex = newIndex;
                            updateNavigationButtons();
                            updateCounter();
                            setActiveCard(previousActiveId);
                        } else if (!state.externalPhoto) {
                            closeDetail();
                        }
                    }
                }
                function renderGallery() {
                    if (!elements.gallery) {
                        return;
                    }
                    elements.gallery.innerHTML = '';
                    if (!state.filteredPhotos.length) {
                        return;
                    }
                    const groups = buildGroups(state.filteredPhotos, state.activeSegment);
                    groups.forEach(group => {
                        var _a;
                        const section = document.createElement('section');
                        section.className = 'space-y-3';
                        const heading = document.createElement('div');
                        heading.className = 'flex items-baseline justify-between px-2';
                        const title = document.createElement('h3');
                        title.className =
                            'text-base font-semibold text-gray-800 dark:text-gray-100 tracking-wide';
                        title.textContent = group.title;
                        const count = document.createElement('span');
                        count.className = 'text-xs text-gray-500 dark:text-gray-400';
                        const countKey =
                            group.photos.length === 1
                                ? 'photos.labels.photoSingular'
                                : 'photos.labels.photoPlural';
                        const countLabel = t2(
                            countKey,
                            group.photos.length === 1 ? 'Photo' : 'Photos'
                        );
                        count.textContent = `${group.photos.length} ${countLabel}`;
                        heading.append(title, count);
                        section.append(heading);
                        const grid = document.createElement('div');
                        grid.className =
                            'grid gap-4 sm:grid-cols-2 lg:grid-cols-3 2xl:grid-cols-4 auto-rows-[minmax(140px,_auto)]';
                        group.photos.forEach(photo => {
                            var _a2;
                            const index =
                                (_a2 = state.filteredIndexMap.get(photo.id)) != null ? _a2 : -1;
                            const card = document.createElement('button');
                            card.type = 'button';
                            card.className =
                                'photos-card relative group overflow-hidden rounded-2xl bg-gray-200 dark:bg-gray-800 shadow-md hover:-translate-y-0.5 hover:shadow-xl focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-400';
                            card.dataset.photoId = photo.id;
                            card.dataset.photoIndex = String(index);
                            if (state.favorites.has(photo.id)) {
                                card.dataset.favorite = 'true';
                            }
                            if (state.activePhotoId === photo.id && state.overlayVisible) {
                                card.dataset.selected = 'true';
                            }
                            const image = document.createElement('img');
                            image.src = photo.thumbUrl;
                            image.alt = t2('photos.gallery.alt', 'Photo by {author}', {
                                author: photo.author,
                            });
                            image.loading = 'lazy';
                            image.className =
                                'w-full h-full object-cover transition duration-300 group-hover:scale-105';
                            const overlay = document.createElement('div');
                            overlay.className =
                                'absolute inset-x-0 bottom-0 bg-gradient-to-t from-black/70 via-black/20 to-transparent px-3 py-2 text-left';
                            const author = document.createElement('p');
                            author.className = 'text-white text-sm font-medium truncate';
                            author.textContent = photo.author;
                            const meta = document.createElement('p');
                            meta.className = 'text-white/80 text-[11px] uppercase tracking-[0.3em]';
                            meta.textContent = `${photo.year} \u0393\xC7\xF3 ${formatOrientation(photo.orientation)}`;
                            overlay.append(author, meta);
                            card.append(image, overlay);
                            grid.append(card);
                        });
                        section.append(grid);
                        (_a = elements.gallery) == null ? void 0 : _a.append(section);
                    });
                }
                function buildGroups(photos, segment) {
                    if (segment === 'collections') {
                        const orientations = [
                            {
                                title: t2('photos.collections.landscape', 'Landscapes'),
                                key: 'landscape',
                            },
                            {
                                title: t2('photos.collections.portrait', 'Portraits'),
                                key: 'portrait',
                            },
                            { title: t2('photos.collections.square', 'Squares'), key: 'square' },
                        ];
                        return orientations
                            .map(item => ({
                                title: item.title,
                                photos: photos.filter(photo => photo.orientation === item.key),
                            }))
                            .filter(group => group.photos.length > 0);
                    }
                    if (segment === 'years') {
                        const byYear = /* @__PURE__ */ new Map();
                        photos.forEach(photo => {
                            var _a;
                            const collection = (_a = byYear.get(photo.year)) != null ? _a : [];
                            collection.push(photo);
                            byYear.set(photo.year, collection);
                        });
                        return Array.from(byYear.entries())
                            .sort((a, b) => b[0] - a[0])
                            .map(([year, group]) => ({ title: String(year), photos: group }));
                    }
                    const byAuthor = /* @__PURE__ */ new Map();
                    photos.forEach(photo => {
                        var _a;
                        const key = photo.author;
                        const collection = (_a = byAuthor.get(key)) != null ? _a : [];
                        collection.push(photo);
                        byAuthor.set(key, collection);
                    });
                    return Array.from(byAuthor.entries())
                        .sort((a, b) => {
                            const latestA = Math.max(...a[1].map(item => item.year));
                            const latestB = Math.max(...b[1].map(item => item.year));
                            return latestB - latestA;
                        })
                        .map(([author, group]) => ({ title: author, photos: group }));
                }
                function formatOrientation(orientation) {
                    if (orientation === 'portrait') {
                        return t2('photos.orientations.portrait', 'Portrait');
                    }
                    if (orientation === 'square') {
                        return t2('photos.orientations.square', 'Square');
                    }
                    return t2('photos.orientations.landscape', 'Landscape');
                }
                function setActiveCard(photoId) {
                    if (!elements.gallery) {
                        return;
                    }
                    const current = elements.gallery.querySelector(
                        '.photos-card[data-selected="true"]'
                    );
                    if (current) {
                        current.removeAttribute('data-selected');
                    }
                    const next = elements.gallery.querySelector(
                        `.photos-card[data-photo-id="${photoId}"]`
                    );
                    if (next) {
                        next.dataset.selected = 'true';
                    }
                }
                function clearActiveCard() {
                    if (!elements.gallery) {
                        return;
                    }
                    const current = elements.gallery.querySelector(
                        '.photos-card[data-selected="true"]'
                    );
                    current == null ? void 0 : current.removeAttribute('data-selected');
                }
                function updateEmptyState() {
                    var _a;
                    const shouldShow = state.filteredPhotos.length === 0;
                    (_a = elements.empty) == null
                        ? void 0
                        : _a.classList.toggle('hidden', !shouldShow);
                }
                function updatePhotoCount() {
                    const total = state.filteredPhotos.length;
                    const labelKey =
                        total === 1 ? 'photos.labels.photoSingular' : 'photos.labels.photoPlural';
                    const label = t2(labelKey, total === 1 ? 'Photo' : 'Photos');
                    const segmentKey =
                        state.activeSegment === 'collections'
                            ? 'photos.segments.collections'
                            : state.activeSegment === 'years'
                              ? 'photos.segments.years'
                              : 'photos.segments.moments';
                    const segmentFallback =
                        state.activeSegment === 'collections'
                            ? 'Collections'
                            : state.activeSegment === 'years'
                              ? 'Years'
                              : 'Moments';
                    const segmentLabel = t2(segmentKey, segmentFallback);
                    const statusText = t2(
                        'photos.status.count',
                        `${total} ${label} \u0393\xC7\xF3 ${segmentLabel}`,
                        { count: total, label, segment: segmentLabel }
                    );
                    if (elements.statusbar && globalWindow.WindowChrome) {
                        globalWindow.WindowChrome.updateStatusBar(
                            elements.statusbar,
                            'left',
                            statusText
                        );
                    }
                    if (elements.photoCount) {
                        elements.photoCount.textContent = statusText;
                    }
                }
                function updateSidebarCounts() {
                    if (elements.countAll) {
                        elements.countAll.textContent = String(state.photos.length);
                    }
                    if (elements.countFavorites) {
                        elements.countFavorites.textContent = String(state.favorites.size);
                    }
                    if (elements.countLandscape) {
                        elements.countLandscape.textContent = String(
                            state.orientationCounts.landscape
                        );
                    }
                    if (elements.countPortrait) {
                        elements.countPortrait.textContent = String(
                            state.orientationCounts.portrait
                        );
                    }
                    if (elements.countSquare) {
                        elements.countSquare.textContent = String(state.orientationCounts.square);
                    }
                }
                function syncSidebarSelection() {
                    elements.sidebarButtons.forEach(button => {
                        const filter = button.getAttribute('data-photos-filter');
                        button.dataset.active = filter === state.activeFilter ? 'true' : 'false';
                    });
                }
                function syncSegmentSelection() {
                    elements.segmentButtons.forEach(button => {
                        const segment = button.getAttribute('data-photos-segment');
                        button.dataset.active = segment === state.activeSegment ? 'true' : 'false';
                    });
                }
                function toggleSearchClear() {
                    if (!elements.searchClear) {
                        return;
                    }
                    const hasValue = Boolean(state.searchTerm.trim());
                    elements.searchClear.classList.toggle('invisible', !hasValue);
                    elements.searchClear.classList.toggle('pointer-events-none', !hasValue);
                }
                function setLoading(isLoading) {
                    var _a;
                    state.isLoading = isLoading;
                    (_a = elements.loading) == null
                        ? void 0
                        : _a.classList.toggle('hidden', !isLoading);
                }
                function setError(hasError) {
                    var _a;
                    (_a = elements.error) == null
                        ? void 0
                        : _a.classList.toggle('hidden', !hasError);
                }
                function openDetail(index, options = {}) {
                    const overlay = elements.overlay;
                    if (!overlay || !elements.image) {
                        return;
                    }
                    let photo = null;
                    if (options.external && options.photo) {
                        photo = options.photo;
                        state.externalPhoto = options.photo;
                        state.selectedIndex = -1;
                        state.activePhotoId = options.photo.id;
                    } else {
                        const selected = state.filteredPhotos[index];
                        if (!selected) {
                            return;
                        }
                        photo = selected;
                        state.selectedIndex = index;
                        state.activePhotoId = selected.id;
                        state.externalPhoto = null;
                    }
                    state.overlayVisible = true;
                    overlay.classList.remove('hidden');
                    overlay.classList.add('flex');
                    if (!photo) {
                        return;
                    }
                    setDetailLoading(true);
                    state.pendingImageId = photo.id;
                    if ('largeUrl' in photo && photo.largeUrl) {
                        elements.image.src = photo.largeUrl;
                    } else {
                        elements.image.src = photo.downloadUrl;
                    }
                    updateDetailMetadata(photo);
                    updateNavigationButtons();
                    updateCounter();
                    if (!options.external) {
                        setActiveCard(photo.id);
                    } else {
                        clearActiveCard();
                    }
                }
                function getCurrentDetailPhoto() {
                    var _a;
                    if (state.externalPhoto) {
                        return state.externalPhoto;
                    }
                    if (state.selectedIndex >= 0) {
                        return (_a = state.filteredPhotos[state.selectedIndex]) != null ? _a : null;
                    }
                    return null;
                }
                function updateDetailMetadata(photo) {
                    var _a;
                    if (elements.detailTitle) {
                        const fallbackTitle = t2('photos.detail.unknownPhoto', 'Unknown photo');
                        elements.detailTitle.textContent = photo.author || fallbackTitle;
                    }
                    if (elements.imageInfo) {
                        const label =
                            isExternalPhoto(photo) && photo.sourceName
                                ? photo.sourceName
                                : photo.author;
                        elements.imageInfo.textContent = label;
                    }
                    const orientationLabel = formatOrientation(photo.orientation);
                    const metaParts = [];
                    if (isExternalPhoto(photo)) {
                        metaParts.push(t2('photos.detail.externalLabel', 'External photo'));
                        if (photo.sourceName) {
                            metaParts.push(photo.sourceName);
                        }
                    } else {
                        metaParts.push(String(photo.year));
                        metaParts.push(orientationLabel);
                    }
                    if (elements.detailMeta) {
                        elements.detailMeta.textContent = metaParts.join(' \u0393\xC7\xF3 ');
                    }
                    if (elements.detailDimensions) {
                        if (photo.width && photo.height) {
                            elements.detailDimensions.textContent = t2(
                                'photos.detail.dimensions',
                                `Resolution: ${photo.width} \u251C\xF9 ${photo.height}px`,
                                { width: photo.width, height: photo.height }
                            );
                        } else {
                            elements.detailDimensions.textContent = '';
                        }
                    }
                    if (elements.detailOpen) {
                        elements.detailOpen.href =
                            (_a = photo.url) != null ? _a : photo.downloadUrl;
                    }
                    if (elements.detailDownload) {
                        elements.detailDownload.href = photo.downloadUrl;
                        elements.detailDownload.download = t2(
                            'photos.detail.downloadFilename',
                            `photo-${photo.id}.jpg`,
                            { id: photo.id }
                        );
                    }
                    updateFavoriteButton(photo);
                }
                function updateFavoriteButton(photo) {
                    if (
                        !elements.detailFavorite ||
                        !elements.detailFavoriteLabel ||
                        !elements.detailFavoriteIcon
                    ) {
                        return;
                    }
                    if (isExternalPhoto(photo)) {
                        elements.detailFavorite.setAttribute('disabled', 'true');
                        elements.detailFavorite.classList.add('opacity-40', 'pointer-events-none');
                        elements.detailFavoriteLabel.textContent = t2(
                            'photos.detail.favoriteUnavailable',
                            'Unavailable'
                        );
                        elements.detailFavoriteIcon.textContent = '\u0393\xC7\xF4';
                        return;
                    }
                    const isFavorite = state.favorites.has(photo.id);
                    elements.detailFavorite.removeAttribute('disabled');
                    elements.detailFavorite.classList.remove('opacity-40', 'pointer-events-none');
                    const removeLabel = t2('photos.detail.favoriteRemove', 'Remove favorite');
                    const addLabel = t2('photos.detail.favoriteAdd', 'Add to favorites');
                    elements.detailFavoriteLabel.textContent = isFavorite ? removeLabel : addLabel;
                    elements.detailFavoriteIcon.textContent = isFavorite
                        ? '\u0393\xD6\xD1'
                        : '\u0393\xD6\xED';
                }
                function closeDetail() {
                    if (!elements.overlay) {
                        return;
                    }
                    elements.overlay.classList.add('hidden');
                    elements.overlay.classList.remove('flex');
                    state.overlayVisible = false;
                    state.selectedIndex = -1;
                    state.activePhotoId = null;
                    state.externalPhoto = null;
                    state.pendingImageId = null;
                    clearActiveCard();
                    setDetailLoading(false);
                }
                function moveSelection(delta) {
                    if (state.externalPhoto) {
                        return;
                    }
                    const nextIndex = state.selectedIndex + delta;
                    if (nextIndex < 0 || nextIndex >= state.filteredPhotos.length) {
                        return;
                    }
                    openDetail(nextIndex);
                }
                function toggleFavorite() {
                    if (state.externalPhoto) {
                        return;
                    }
                    const photo = state.filteredPhotos[state.selectedIndex];
                    if (!photo) {
                        return;
                    }
                    if (state.favorites.has(photo.id)) {
                        state.favorites.delete(photo.id);
                    } else {
                        state.favorites.add(photo.id);
                    }
                    updateFavoriteButton(photo);
                    updateSidebarCounts();
                    updateCardFavoriteState(photo.id);
                }
                function updateCardFavoriteState(photoId) {
                    if (!elements.gallery) {
                        return;
                    }
                    const card = elements.gallery.querySelector(
                        `.photos-card[data-photo-id="${photoId}"]`
                    );
                    if (!card) {
                        return;
                    }
                    if (state.favorites.has(photoId)) {
                        card.dataset.favorite = 'true';
                    } else {
                        card.removeAttribute('data-favorite');
                    }
                }
                function updateNavigationButtons() {
                    const hasPrev = state.selectedIndex > 0 && !state.externalPhoto;
                    const hasNext =
                        state.selectedIndex >= 0 &&
                        state.selectedIndex < state.filteredPhotos.length - 1 &&
                        !state.externalPhoto;
                    if (elements.detailPrev) {
                        elements.detailPrev.classList.toggle('opacity-30', !hasPrev);
                        elements.detailPrev.classList.toggle('pointer-events-none', !hasPrev);
                    }
                    if (elements.detailNext) {
                        elements.detailNext.classList.toggle('opacity-30', !hasNext);
                        elements.detailNext.classList.toggle('pointer-events-none', !hasNext);
                    }
                }
                function updateCounter() {
                    if (!elements.detailCounter) {
                        return;
                    }
                    if (state.externalPhoto) {
                        elements.detailCounter.textContent = t2(
                            'photos.detail.externalCounter',
                            'External image'
                        );
                        return;
                    }
                    if (state.selectedIndex >= 0) {
                        elements.detailCounter.textContent = t2(
                            'photos.detail.counter',
                            `${state.selectedIndex + 1} of ${state.filteredPhotos.length}`,
                            { index: state.selectedIndex + 1, total: state.filteredPhotos.length }
                        );
                    } else {
                        elements.detailCounter.textContent = '';
                    }
                }
                function setDetailLoading(isLoading) {
                    var _a;
                    (_a = elements.loader) == null
                        ? void 0
                        : _a.classList.toggle('hidden', !isLoading);
                }
                function handleKeyNavigation(event) {
                    if (!state.overlayVisible) {
                        return;
                    }
                    if (event.key === 'Escape') {
                        closeDetail();
                    } else if (event.key === 'ArrowLeft') {
                        moveSelection(-1);
                    } else if (event.key === 'ArrowRight') {
                        moveSelection(1);
                    }
                }
                function getRandomPage() {
                    return Math.floor(Math.random() * 10) + 1;
                }
                function showExternalImage(payload) {
                    if (!payload || !payload.src) {
                        return;
                    }
                    if (!state.initialized) {
                        init();
                    }
                    const name =
                        payload.name && payload.name.trim().length > 0
                            ? payload.name.trim()
                            : t2('photos.detail.externalFile', 'External file');
                    const externalPhoto = {
                        id: `external-${Date.now()}`,
                        author: name,
                        downloadUrl: payload.src,
                        largeUrl: payload.src,
                        url: payload.src,
                        sourceName: name,
                        isExternal: true,
                    };
                    openDetail(-1, { external: true, photo: externalPhoto });
                }
                function handleLanguageChange() {
                    var _a, _b, _c;
                    if (!state.initialized) {
                        return;
                    }
                    renderGallery();
                    updateEmptyState();
                    updatePhotoCount();
                    if (state.overlayVisible) {
                        const current = getCurrentDetailPhoto();
                        if (current) {
                            updateDetailMetadata(current);
                        }
                        updateNavigationButtons();
                        updateCounter();
                    } else {
                        updateCounter();
                    }
                    (_c = (_a = globalWindow.appI18n) == null ? void 0 : _a.applyTranslations) ==
                    null
                        ? void 0
                        : _c.call(_a, (_b = elements.container) != null ? _b : void 0);
                }
                const api = {
                    init,
                    showExternalImage,
                };
                globalWindow.PhotosApp = api;
                window.addEventListener('languagePreferenceChange', handleLanguageChange);
            })();
        },
    });

    // src/ts/windows/window-configs.ts
    var windowConfigurations;
    var init_window_configs = __esm({
        'src/ts/windows/window-configs.ts'() {
            'use strict';
            windowConfigurations = [
                {
                    id: 'launchpad-modal',
                    type: 'persistent',
                    programKey: 'programs.launchpad',
                    icon: './img/launchpad.png',
                    closeButtonId: 'close-launchpad-modal',
                    metadata: {
                        // Launchpad darf seinen initHandler auch whrend der Session-Restore-Phase ausfhren,
                        // damit das Grid direkt verfgbar ist (Tests klicken oft sehr frh).
                        runInitDuringRestore: true,
                        skipMenubarUpdate: true,
                        initHandler: function () {
                            var _a, _b;
                            if (
                                window.LaunchpadSystem &&
                                !((_a = window.LaunchpadSystem) == null ? void 0 : _a.container)
                            ) {
                                const container = document.getElementById('launchpad-container');
                                if (container) window.LaunchpadSystem.init(container);
                            }
                            if ((_b = window.LaunchpadSystem) == null ? void 0 : _b.refresh)
                                window.LaunchpadSystem.refresh();
                        },
                    },
                },
                {
                    id: 'projects-modal',
                    type: 'persistent',
                    programKey: 'programs.projects',
                    icon: './img/sucher.png',
                    closeButtonId: 'close-projects-modal',
                },
                {
                    id: 'about-modal',
                    type: 'persistent',
                    programKey: 'programs.about',
                    icon: './img/profil.jpg',
                    closeButtonId: 'close-about-modal',
                },
                {
                    id: 'settings-modal',
                    type: 'persistent',
                    programKey: 'programs.settings',
                    icon: './img/settings.png',
                    closeButtonId: 'close-settings-modal',
                    metadata: {
                        initHandler: function () {
                            var _a;
                            if (
                                window.SettingsSystem &&
                                !((_a = window.SettingsSystem) == null ? void 0 : _a.container)
                            ) {
                                const container = document.getElementById('settings-container');
                                if (container) window.SettingsSystem.init(container);
                            }
                        },
                    },
                },
                {
                    id: 'text-modal',
                    type: 'persistent',
                    programKey: 'programs.text',
                    icon: './img/notepad.png',
                    closeButtonId: 'close-text-modal',
                    metadata: {
                        initHandler: function () {
                            var _a;
                            if (
                                window.TextEditorInstanceManager &&
                                !window.TextEditorInstanceManager.hasInstances()
                            ) {
                                window.TextEditorInstanceManager.createInstance({
                                    title: 'Editor',
                                });
                            } else if (
                                !window.TextEditorInstanceManager &&
                                window.TextEditorSystem &&
                                !((_a = window.TextEditorSystem) == null ? void 0 : _a.container)
                            ) {
                                const container = document.getElementById('text-editor-container');
                                if (container) window.TextEditorSystem.init(container);
                            }
                        },
                    },
                },
                {
                    id: 'image-modal',
                    type: 'persistent',
                    programKey: 'programs.photos',
                    icon: './img/photos-app-icon.svg',
                    closeButtonId: 'close-image-modal',
                    metadata: {
                        initHandler: function () {
                            var _a;
                            if ((_a = window.PhotosApp) == null ? void 0 : _a.init)
                                window.PhotosApp.init();
                        },
                    },
                },
                {
                    id: 'program-info-modal',
                    type: 'transient',
                    programKey: 'programs.default',
                    icon: './img/sucher.png',
                    closeButtonId: 'close-program-info-modal',
                },
                {
                    id: 'terminal-modal',
                    type: 'persistent',
                    programKey: 'programs.terminal',
                    icon: './img/terminal.png',
                    closeButtonId: 'close-terminal-modal',
                    metadata: {
                        initHandler: function () {
                            var _a;
                            if (
                                window.TerminalInstanceManager &&
                                !window.TerminalInstanceManager.hasInstances()
                            ) {
                                window.TerminalInstanceManager.createInstance({
                                    title: 'Terminal',
                                });
                            } else if (
                                !window.TerminalInstanceManager &&
                                window.TerminalSystem &&
                                !((_a = window.TerminalSystem) == null ? void 0 : _a.container)
                            ) {
                                const container = document.getElementById('terminal-container');
                                if (container) window.TerminalSystem.init(container);
                            }
                        },
                    },
                },
            ];
            if (window.WindowManager) {
                window.WindowManager.registerAll(windowConfigurations);
                console.log(`[WindowConfigs] Registered ${windowConfigurations.length} windows`);
            } else {
                document.addEventListener('DOMContentLoaded', () => {
                    if (window.WindowManager) {
                        window.WindowManager.registerAll(windowConfigurations);
                        console.log(
                            `[WindowConfigs] Registered ${windowConfigurations.length} windows (delayed)`
                        );
                    }
                });
            }
            window.windowConfigurations = windowConfigurations;
        },
    });

    // src/ts/apps/finder/finder-instance.ts
    var init_finder_instance = __esm({
        'src/ts/apps/finder/finder-instance.ts'() {
            'use strict';
        },
    });

    // src/ts/ui/launchpad.ts
    var require_launchpad = __commonJS({
        'src/ts/ui/launchpad.ts'() {
            'use strict';
            init_i18n();
            console.log('Launchpad (TS) loaded');
            (() => {
                'use strict';
                let container = null;
                let searchInput = null;
                let appsGrid = null;
                let allApps = [];
                let filteredApps = [];
                function init(containerElement) {
                    if (!containerElement) {
                        console.warn('LaunchpadSystem: No container element provided');
                        return;
                    }
                    if (container) {
                        console.warn('LaunchpadSystem: Already initialized');
                        return;
                    }
                    container = containerElement;
                    render();
                    loadApps();
                }
                function render() {
                    if (!container) return;
                    container.innerHTML = `
            <div class="launchpad-container">
                <div class="launchpad-search">
                    <input
                        id="launchpad-search-input"
                        type="text"
                        placeholder="${translate('modals.launchpad.searchPlaceholder') || 'Search apps'}"
                        class="launchpad-search-input"
                    />
                </div>
                <div id="launchpad-apps-grid" class="launchpad-apps-grid"></div>
            </div>
        `;
                    searchInput = container.querySelector('#launchpad-search-input');
                    appsGrid = container.querySelector('#launchpad-apps-grid');
                    if (searchInput) searchInput.addEventListener('input', handleSearch);
                }
                function loadApps() {
                    const WM = window.WindowManager;
                    if (!WM) {
                        console.warn('LaunchpadSystem: WindowManager not available');
                        return;
                    }
                    const windowIds = WM.getAllWindowIds();
                    allApps = [];
                    windowIds.forEach(id => {
                        const cfg = WM.getConfig(id);
                        const info = WM.getProgramInfo(id);
                        if (cfg && cfg.type === 'transient') return;
                        if (id === 'launchpad-modal') return;
                        if (info) {
                            allApps.push({
                                id,
                                name:
                                    info.programLabel ||
                                    translate('programs.default.label') ||
                                    'App',
                                icon: info.icon || './img/sucher.png',
                                programKey: cfg ? cfg.programKey : null,
                            });
                        }
                    });
                    filteredApps = [...allApps];
                    renderApps();
                }
                function handleSearch(e) {
                    const q = e.target.value.toLowerCase().trim();
                    filteredApps = q
                        ? allApps.filter(a => a.name.toLowerCase().includes(q))
                        : [...allApps];
                    renderApps();
                }
                function renderApps() {
                    if (!appsGrid) return;
                    appsGrid.innerHTML = '';
                    if (filteredApps.length === 0) {
                        appsGrid.innerHTML = `
                <div class="launchpad-empty">
                    <p>${translate('finder.empty') || 'No apps found'}</p>
                </div>
            `;
                        return;
                    }
                    const grid = appsGrid;
                    if (!grid) return;
                    filteredApps.forEach(app => {
                        const btn = document.createElement('button');
                        btn.className = 'launchpad-app-button';
                        btn.setAttribute('data-window-id', app.id);
                        btn.setAttribute('data-action', 'launchpadOpenWindow');
                        btn.title = app.name;
                        const iconWrap = document.createElement('div');
                        iconWrap.className = 'launchpad-app-icon';
                        const icon = app.icon;
                        const isImg =
                            typeof icon === 'string' &&
                            /\.(png|jpg|jpeg|gif|svg|webp)$/i.test(icon);
                        if (
                            isImg ||
                            (typeof icon === 'string' &&
                                (icon.startsWith('./') || icon.startsWith('http')))
                        ) {
                            const img = document.createElement('img');
                            img.src = icon;
                            img.alt = app.name;
                            img.draggable = false;
                            iconWrap.appendChild(img);
                        } else if (typeof icon === 'string' && icon.trim().length) {
                            const emoji = document.createElement('div');
                            emoji.className = 'launchpad-app-emoji';
                            emoji.textContent = icon;
                            iconWrap.appendChild(emoji);
                        } else {
                            const fallback = document.createElement('img');
                            fallback.src = './img/sucher.png';
                            fallback.alt = app.name;
                            fallback.draggable = false;
                            iconWrap.appendChild(fallback);
                        }
                        const label = document.createElement('span');
                        label.className = 'launchpad-app-label';
                        label.textContent = app.name;
                        btn.appendChild(iconWrap);
                        btn.appendChild(label);
                        grid.appendChild(btn);
                    });
                }
                function openApp(windowId) {
                    var _a, _b, _c, _d;
                    if (!windowId) return;
                    const w = window;
                    const launchpadModal = document.getElementById('launchpad-modal');
                    if (launchpadModal && w.dialogs && w.dialogs['launchpad-modal']) {
                        (_b = (_a = w.dialogs['launchpad-modal']).close) == null
                            ? void 0
                            : _b.call(_a);
                    } else if (launchpadModal) {
                        launchpadModal.classList.add('hidden');
                    }
                    const WM = w.WindowManager;
                    if (WM == null ? void 0 : WM.open) {
                        WM.open(windowId);
                        return;
                    }
                    const dialog = w.dialogs && w.dialogs[windowId];
                    if (dialog == null ? void 0 : dialog.open) dialog.open();
                    else {
                        const modalElement = document.getElementById(windowId);
                        if (modalElement) {
                            const domUtils = window.DOMUtils;
                            if (domUtils && typeof domUtils.show === 'function') {
                                domUtils.show(modalElement);
                            } else {
                                modalElement.classList.remove('hidden');
                            }
                            (_c = w.bringDialogToFront) == null ? void 0 : _c.call(w, windowId);
                            (_d = w.updateProgramLabelByTopModal) == null ? void 0 : _d.call(w);
                        }
                    }
                }
                function refresh() {
                    loadApps();
                }
                function clearSearch() {
                    if (searchInput) searchInput.value = '';
                    filteredApps = [...allApps];
                    renderApps();
                }
                window.addEventListener('languagePreferenceChange', () => {
                    if (container) loadApps();
                });
                const AB = window.ActionBus;
                if (typeof (AB == null ? void 0 : AB.register) === 'function') {
                    AB.register('launchpadOpenWindow', params => {
                        const id =
                            (params == null ? void 0 : params.windowId) ||
                            (params == null ? void 0 : params.windowid) ||
                            (params == null ? void 0 : params.window) ||
                            (params == null ? void 0 : params.id);
                        if (id) openApp(id);
                    });
                }
                window.LaunchpadSystem = {
                    init,
                    refresh,
                    clearSearch,
                    get container() {
                        return container;
                    },
                };
            })();
        },
    });

    // src/ts/windows/multi-instance-integration.ts
    var require_multi_instance_integration = __commonJS({
        'src/ts/windows/multi-instance-integration.ts'() {
            'use strict';
            init_storage_utils();
            (() => {
                'use strict';
                class MultiInstanceIntegration {
                    constructor() {
                        this.integrations = /* @__PURE__ */ new Map();
                        this.isInitialized = false;
                    }
                    init() {
                        if (this.isInitialized) return;
                        if (document.readyState === 'loading') {
                            document.addEventListener('DOMContentLoaded', () => this.setup());
                        } else {
                            this.setup();
                        }
                    }
                    setup() {
                        const W = window;
                        if (!W.InstanceManager || !W.WindowTabs || !W.KeyboardShortcuts) {
                            console.error(
                                'MultiInstanceIntegration: Required dependencies not loaded'
                            );
                            return;
                        }
                        if (W.TerminalInstanceManager)
                            this.wireManager({
                                type: 'terminal',
                                manager: W.TerminalInstanceManager,
                                modalId: 'terminal-modal',
                                tabMountId: 'terminal-tabs-container',
                                containerId: 'terminal-container',
                                addButton: true,
                                titleFactory: manager => {
                                    var _a;
                                    return `Terminal ${(((_a = manager.getInstanceCount) == null ? void 0 : _a.call(manager)) || manager.getAllInstances().length) + 1}`;
                                },
                                onEmpty: () => this.closeModalOrHide('terminal-modal'),
                            });
                        if (W.TextEditorInstanceManager)
                            this.wireManager({
                                type: 'text-editor',
                                manager: W.TextEditorInstanceManager,
                                modalId: 'text-modal',
                                tabMountId: 'text-editor-tabs-container',
                                containerId: 'text-editor-container',
                                addButton: true,
                                titleFactory: manager => {
                                    var _a;
                                    return `Editor ${(((_a = manager.getInstanceCount) == null ? void 0 : _a.call(manager)) || manager.getAllInstances().length) + 1}`;
                                },
                                onEmpty: () => this.closeModalOrHide('text-modal'),
                            });
                        if (W.FinderInstanceManager)
                            this.wireManager({
                                type: 'finder',
                                manager: W.FinderInstanceManager,
                                modalId: null,
                                // legacy finder-modal removed
                                tabMountId: 'finder-tabs-container',
                                containerId: 'finder-container',
                                addButton: true,
                                titleFactory: manager => {
                                    var _a;
                                    return `Finder ${(((_a = manager.getInstanceCount) == null ? void 0 : _a.call(manager)) || manager.getAllInstances().length) + 1}`;
                                },
                                // onEmpty intentionally no-op for Finder
                            });
                        this.integrations.forEach((integration2, type) => {
                            var _a;
                            const { manager, tabManager } = integration2;
                            try {
                                const maybe = tabManager;
                                const refreshFn =
                                    typeof (maybe == null ? void 0 : maybe.refresh) === 'function'
                                        ? maybe.refresh.bind(maybe)
                                        : typeof ((_a =
                                                maybe == null ? void 0 : maybe.controller) == null
                                                ? void 0
                                                : _a.refresh) === 'function'
                                          ? maybe.controller.refresh.bind(maybe.controller)
                                          : null;
                                if (refreshFn) refreshFn();
                            } catch {}
                            try {
                                const map = getJSON('windowActiveInstances', {});
                                const wanted = (map == null ? void 0 : map[type]) || null;
                                if (wanted && typeof manager.setActiveInstance === 'function') {
                                    const exists = manager
                                        .getAllInstances()
                                        .some(i => i.instanceId === wanted);
                                    if (exists) manager.setActiveInstance(wanted);
                                }
                            } catch {}
                            const active = manager.getActiveInstance();
                            if (active) this.showInstance(type, active.instanceId);
                        });
                        if (
                            W.KeyboardShortcuts &&
                            typeof W.KeyboardShortcuts.setContextResolver === 'function'
                        ) {
                            W.KeyboardShortcuts.setContextResolver(() => {
                                try {
                                    const wm = W.WindowManager;
                                    const top =
                                        wm && typeof wm.getTopWindow === 'function'
                                            ? wm.getTopWindow()
                                            : null;
                                    const topId = (top == null ? void 0 : top.id) || '';
                                    let match = 'global';
                                    this.integrations.forEach((val, key) => {
                                        if (val && val.modalId === topId) match = key;
                                    });
                                    return match;
                                } catch {
                                    return 'global';
                                }
                            });
                        }
                        this.isInitialized = true;
                    }
                    /**
                     * Generic wiring for an InstanceManager + WindowTabs + keyboard shortcuts
                     */
                    wireManager(options) {
                        const {
                            type,
                            manager,
                            modalId,
                            tabMountId,
                            containerId,
                            addButton = true,
                            titleFactory,
                            onEmpty,
                        } = options;
                        const W = window;
                        const mount = document.getElementById(tabMountId);
                        if (!mount) return;
                        const controller = W.WindowTabs.create(manager, mount, {
                            addButton,
                            onCreateInstanceTitle: () => {
                                var _a;
                                return (
                                    (titleFactory == null ? void 0 : titleFactory(manager)) ||
                                    `${type} ${(((_a = manager.getInstanceCount) == null ? void 0 : _a.call(manager)) || manager.getAllInstances().length) + 1}`
                                );
                            },
                        });
                        const origSetActive = manager.setActiveInstance.bind(manager);
                        manager.setActiveInstance = id => {
                            origSetActive(id);
                            this.showInstance(type, id);
                        };
                        const origDestroy = manager.destroyInstance.bind(manager);
                        manager.destroyInstance = id => {
                            origDestroy(id);
                            const remaining = manager.getAllInstances().length;
                            if (remaining === 0) {
                                onEmpty == null ? void 0 : onEmpty();
                            } else {
                                const active = manager.getActiveInstance();
                                if (active) this.showInstance(type, active.instanceId);
                            }
                        };
                        this.integrations.set(type, {
                            manager,
                            tabManager: controller,
                            modalId: modalId || '',
                            containerId,
                        });
                        this.registerShortcutsForType(type, manager, modalId || void 0);
                        this.updateInstanceVisibility(type);
                        this.setupInstanceListeners(type);
                    }
                    /** Close modal via API.window.close or DOM hide fallback */
                    closeModalOrHide(modalId) {
                        var _a;
                        try {
                            const API2 = window.API;
                            if (
                                (_a = API2 == null ? void 0 : API2.window) == null
                                    ? void 0
                                    : _a.close
                            ) {
                                API2.window.close(modalId);
                                return;
                            }
                            const modal = document.getElementById(modalId);
                            if (!modal) return;
                            const domUtils = window.DOMUtils;
                            if (domUtils && typeof domUtils.hide === 'function') {
                                domUtils.hide(modal);
                            } else {
                                modal.classList.add('hidden');
                            }
                        } catch {}
                    }
                    setupInstanceListeners(type) {
                        const integration2 = this.integrations.get(type);
                        if (!integration2) return;
                        const { manager } = integration2;
                        const originalCreate = manager.createInstance.bind(manager);
                        manager.createInstance = config => {
                            const instance = originalCreate(config);
                            const active = manager.getActiveInstance();
                            if (active) {
                                this.showInstance(type, active.instanceId);
                            } else if (instance) {
                                this.showInstance(type, instance.instanceId);
                            }
                            return instance;
                        };
                    }
                    showInstance(type, instanceId) {
                        const integration2 = this.integrations.get(type);
                        if (!integration2) return;
                        const instances = integration2.manager.getAllInstances();
                        instances.forEach(inst => {
                            var _a, _b;
                            if (inst.instanceId === instanceId)
                                (_a = inst.show) == null ? void 0 : _a.call(inst);
                            else (_b = inst.hide) == null ? void 0 : _b.call(inst);
                        });
                    }
                    updateInstanceVisibility(type) {
                        var _a;
                        const integration2 = this.integrations.get(type);
                        if (!integration2) return;
                        const active = integration2.manager.getActiveInstance();
                        if (active) {
                            this.showInstance(type, active.instanceId);
                        } else {
                            const all = integration2.manager.getAllInstances();
                            if (all.length > 0) {
                                const firstId = (_a = all[0]) == null ? void 0 : _a.instanceId;
                                if (firstId) {
                                    integration2.manager.setActiveInstance(firstId);
                                    this.showInstance(type, firstId);
                                }
                            }
                        }
                    }
                    registerShortcutsForType(type, manager, modalId) {
                        const W = window;
                        if (modalId) {
                            const modalEl = document.getElementById(modalId);
                            if (!modalEl) {
                                console.error(
                                    `Cannot register shortcuts for ${type}: modal ${modalId} not found`
                                );
                                return;
                            }
                        }
                        const unregister = W.KeyboardShortcuts.register(manager, {
                            scope: document,
                            newTitleFactory: () => `${type} ${manager.getInstanceCount() + 1}`,
                        });
                        const rec = this.integrations.get(type);
                        if (rec) rec.unregisterShortcuts = unregister;
                    }
                }
                const integration = new MultiInstanceIntegration();
                window.MultiInstanceIntegration = integration;
                window.multiInstanceIntegration = integration;
                integration.init();
            })();
        },
    });

    // src/ts/services/system.ts
    var init_system = __esm({
        'src/ts/services/system.ts'() {
            'use strict';
            console.log('\u2705 SystemUI loaded');
            (() => {
                'use strict';
                const appI18n2 = window.appI18n || {
                    translate: key => key,
                    applyTranslations: () => {},
                    getActiveLanguage: () => 'en',
                };
                const IconSystem = window.IconSystem || {};
                const SYSTEM_ICONS = IconSystem.SYSTEM_ICONS || {};
                const ensureSvgNamespace = IconSystem.ensureSvgNamespace || (svg => svg);
                const renderIconIntoElement = IconSystem.renderIconIntoElement || (() => {});
                const ThemeSystem = window.ThemeSystem || {};
                const setThemePreference = ThemeSystem.setThemePreference || (() => {});
                const hideMenuDropdowns =
                    window.hideMenuDropdowns ||
                    (() => {
                        const domUtils = window.DOMUtils;
                        document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
                            if (!dropdown.classList.contains('hidden')) {
                                if (domUtils && typeof domUtils.hide === 'function') {
                                    domUtils.hide(dropdown);
                                } else {
                                    dropdown.classList.add('hidden');
                                }
                            }
                        });
                        document
                            .querySelectorAll('[data-menubar-trigger-button="true"]')
                            .forEach(button => {
                                button.setAttribute('aria-expanded', 'false');
                            });
                        document.querySelectorAll('[data-system-menu-trigger]').forEach(button => {
                            button.setAttribute('aria-expanded', 'false');
                        });
                    });
                const systemStatus = {
                    wifi: true,
                    bluetooth: true,
                    focus: false,
                    darkMode: document.documentElement.classList.contains('dark'),
                    brightness: 80,
                    volume: 65,
                    audioDevice: 'speakers',
                    network: 'HomeLAN',
                    battery: 100,
                    connectedBluetoothDevice: 'AirPods',
                };
                function applySystemIcon(iconToken, iconKey) {
                    const svg = SYSTEM_ICONS[iconKey];
                    const markup = svg ? ensureSvgNamespace(svg) : '';
                    document.querySelectorAll(`[data-icon="${iconToken}"]`).forEach(el => {
                        renderIconIntoElement(el, markup, iconToken);
                    });
                }
                function updateSystemStateText(stateKey, text) {
                    document.querySelectorAll(`[data-state="${stateKey}"]`).forEach(el => {
                        el.textContent = text !== null && text !== void 0 ? String(text) : '';
                    });
                }
                function updateSystemToggleState(toggleKey, active) {
                    const toggle2 = document.querySelector(`[data-system-toggle="${toggleKey}"]`);
                    if (toggle2) {
                        toggle2.classList.toggle('is-active', !!active);
                        toggle2.setAttribute('aria-pressed', active ? 'true' : 'false');
                    }
                }
                function updateSystemMenuCheckbox(actionKey, checked) {
                    const checkbox = document.querySelector(`[data-system-action="${actionKey}"]`);
                    if (checkbox) {
                        checkbox.setAttribute('aria-pressed', checked ? 'true' : 'false');
                        checkbox.classList.toggle('is-active', !!checked);
                    }
                }
                function updateSystemSliderValue(type, value) {
                    document.querySelectorAll(`[data-system-slider="${type}"]`).forEach(slider => {
                        if (Number(slider.value) !== value) {
                            slider.value = String(value);
                        }
                    });
                    document.querySelectorAll(`[data-state="${type}"]`).forEach(label => {
                        label.textContent = `${value}%`;
                    });
                }
                function updateWifiUI() {
                    const iconKey = systemStatus.wifi ? 'wifiOn' : 'wifiOff';
                    applySystemIcon('wifi', iconKey);
                    updateSystemStateText(
                        'wifi',
                        appI18n2.translate(
                            systemStatus.wifi ? 'menubar.state.on' : 'menubar.state.off'
                        )
                    );
                    updateSystemToggleState('wifi', systemStatus.wifi);
                    updateSystemMenuCheckbox('toggle-wifi', systemStatus.wifi);
                    document.querySelectorAll('#wifi-menu [data-network]').forEach(btn => {
                        const disabled = !systemStatus.wifi;
                        if (disabled) {
                            btn.setAttribute('aria-disabled', 'true');
                        } else {
                            btn.removeAttribute('aria-disabled');
                        }
                    });
                    setConnectedNetwork(systemStatus.network, { silent: true });
                }
                function updateBluetoothUI() {
                    const iconKey = systemStatus.bluetooth ? 'bluetoothOn' : 'bluetoothOff';
                    applySystemIcon('bluetooth', iconKey);
                    updateSystemStateText(
                        'bluetooth',
                        appI18n2.translate(
                            systemStatus.bluetooth ? 'menubar.state.on' : 'menubar.state.off'
                        )
                    );
                    updateSystemToggleState('bluetooth', systemStatus.bluetooth);
                    updateSystemMenuCheckbox('toggle-bluetooth', systemStatus.bluetooth);
                    const devices = document.querySelectorAll('#bluetooth-menu [data-device]');
                    devices.forEach(btn => {
                        const indicator = btn.querySelector('.system-network-indicator');
                        if (indicator && !indicator.getAttribute('data-default')) {
                            indicator.setAttribute('data-default', indicator.textContent || '');
                        }
                        const disabled = !systemStatus.bluetooth;
                        if (disabled) {
                            btn.setAttribute('aria-disabled', 'true');
                        } else {
                            btn.removeAttribute('aria-disabled');
                        }
                    });
                    setBluetoothDevice(systemStatus.connectedBluetoothDevice, {
                        silent: true,
                        syncAudio: false,
                    });
                }
                function updateFocusUI() {
                    updateSystemToggleState('focus', systemStatus.focus);
                    updateSystemStateText(
                        'focus',
                        appI18n2.translate(
                            systemStatus.focus ? 'menubar.state.active' : 'menubar.state.off'
                        )
                    );
                }
                function updateDarkModeUI() {
                    const isDark = systemStatus.darkMode;
                    updateSystemToggleState('dark-mode', isDark);
                    updateSystemStateText(
                        'dark-mode',
                        appI18n2.translate(isDark ? 'menubar.state.active' : 'menubar.state.off')
                    );
                    applySystemIcon('appearance', isDark ? 'appearanceDark' : 'appearanceLight');
                }
                function updateVolumeUI() {
                    const value = Math.max(0, Math.min(100, Number(systemStatus.volume) || 0));
                    systemStatus.volume = value;
                    let iconKey = 'volumeMute';
                    if (value === 0) {
                        iconKey = 'volumeMute';
                    } else if (value <= 33) {
                        iconKey = 'volumeLow';
                    } else if (value <= 66) {
                        iconKey = 'volumeMedium';
                    } else {
                        iconKey = 'volumeHigh';
                    }
                    applySystemIcon('volume', iconKey);
                    updateSystemSliderValue('volume', value);
                }
                function updateBrightnessUI() {
                    const value = Math.max(0, Math.min(100, Number(systemStatus.brightness) || 0));
                    systemStatus.brightness = value;
                    updateSystemSliderValue('brightness', value);
                }
                function updateBatteryUI() {
                    applySystemIcon('battery', 'batteryFull');
                    updateSystemStateText('battery', `${systemStatus.battery}%`);
                }
                function updateAudioDeviceUI() {
                    const active = systemStatus.audioDevice;
                    document.querySelectorAll('[data-audio-device]').forEach(btn => {
                        const isActive = btn.getAttribute('data-audio-device') === active;
                        btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
                        btn.classList.toggle('is-active', isActive);
                    });
                }
                function setConnectedNetwork(network, options = {}) {
                    if (network) {
                        systemStatus.network = network;
                    }
                    const activeNetwork = systemStatus.network;
                    document.querySelectorAll('#wifi-menu [data-network]').forEach(btn => {
                        const indicator = btn.querySelector('.system-network-indicator');
                        if (indicator && !indicator.getAttribute('data-default')) {
                            indicator.setAttribute('data-default', indicator.textContent || '');
                        }
                        const isActive =
                            !btn.hasAttribute('aria-disabled') &&
                            btn.getAttribute('data-network') === activeNetwork &&
                            systemStatus.wifi;
                        btn.classList.toggle('is-active', isActive);
                        btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
                        if (indicator) {
                            if (!systemStatus.wifi) {
                                indicator.textContent =
                                    indicator.getAttribute('data-default') || '';
                            } else if (isActive) {
                                indicator.textContent =
                                    appI18n2.translate('menubar.state.connected');
                            } else {
                                indicator.textContent =
                                    indicator.getAttribute('data-default') || '';
                            }
                        }
                    });
                    if (!options.silent) {
                        hideMenuDropdowns();
                    }
                }
                function setBluetoothDevice(deviceName, options = {}) {
                    const syncAudio = options.syncAudio !== false;
                    if (deviceName) {
                        systemStatus.connectedBluetoothDevice = deviceName;
                        if (syncAudio && deviceName === 'AirPods') {
                            systemStatus.audioDevice = 'airpods';
                        }
                    }
                    const activeDevice = systemStatus.connectedBluetoothDevice;
                    document.querySelectorAll('#bluetooth-menu [data-device]').forEach(btn => {
                        const indicator = btn.querySelector('.system-network-indicator');
                        if (indicator && !indicator.getAttribute('data-default')) {
                            indicator.setAttribute('data-default', indicator.textContent || '');
                        }
                        const isActive =
                            systemStatus.bluetooth &&
                            btn.getAttribute('data-device') === activeDevice;
                        btn.classList.toggle('is-active', isActive);
                        btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
                        if (indicator) {
                            if (!systemStatus.bluetooth) {
                                indicator.textContent =
                                    indicator.getAttribute('data-default') || '';
                            } else if (isActive) {
                                indicator.textContent =
                                    appI18n2.translate('menubar.state.connected');
                            } else {
                                indicator.textContent =
                                    indicator.getAttribute('data-default') || '';
                            }
                        }
                    });
                    updateAudioDeviceUI();
                    if (!options.silent) {
                        hideMenuDropdowns();
                    }
                }
                function setAudioDevice(deviceKey, options = {}) {
                    if (!deviceKey) return;
                    systemStatus.audioDevice = deviceKey;
                    if (deviceKey === 'airpods') {
                        systemStatus.connectedBluetoothDevice = 'AirPods';
                    }
                    updateAudioDeviceUI();
                    updateBluetoothUI();
                    if (!options.silent) {
                        hideMenuDropdowns();
                    }
                }
                function handleSystemToggle(toggleKey) {
                    switch (toggleKey) {
                        case 'wifi':
                            systemStatus.wifi = !systemStatus.wifi;
                            updateWifiUI();
                            break;
                        case 'bluetooth':
                            systemStatus.bluetooth = !systemStatus.bluetooth;
                            updateBluetoothUI();
                            break;
                        case 'focus':
                            systemStatus.focus = !systemStatus.focus;
                            updateFocusUI();
                            break;
                        case 'dark-mode': {
                            const next = !document.documentElement.classList.contains('dark');
                            systemStatus.darkMode = next;
                            if (typeof setThemePreference === 'function') {
                                setThemePreference(next ? 'dark' : 'light');
                            } else {
                                document.documentElement.classList.toggle('dark', next);
                            }
                            updateDarkModeUI();
                            break;
                        }
                        default:
                            break;
                    }
                }
                function handleSystemAction(actionKey) {
                    switch (actionKey) {
                        case 'toggle-wifi':
                            handleSystemToggle('wifi');
                            break;
                        case 'toggle-bluetooth':
                            handleSystemToggle('bluetooth');
                            break;
                        case 'open-network':
                        case 'open-bluetooth':
                        case 'open-sound':
                            {
                                const dialogs = window.dialogs;
                                if (dialogs == null ? void 0 : dialogs['settings-modal']) {
                                    dialogs['settings-modal'].open();
                                } else {
                                    console.info(
                                        `Aktion "${actionKey}" w\xFCrde Einstellungen \xF6ffnen.`
                                    );
                                }
                                hideMenuDropdowns();
                            }
                            break;
                        case 'open-spotlight':
                        case 'open-siri':
                            console.info(`Aktion "${actionKey}" ausgel\xF6st.`);
                            hideMenuDropdowns();
                            break;
                        default:
                            break;
                    }
                }
                function handleSystemSliderInput(type, value) {
                    if (!Number.isFinite(value)) return;
                    if (type === 'volume') {
                        systemStatus.volume = value;
                        updateVolumeUI();
                    } else if (type === 'brightness') {
                        systemStatus.brightness = value;
                        updateBrightnessUI();
                    }
                }
                function updateAllSystemStatusUI() {
                    applySystemIcon('sun', 'sun');
                    applySystemIcon('moon', 'moon');
                    updateWifiUI();
                    updateBluetoothUI();
                    updateFocusUI();
                    updateDarkModeUI();
                    updateVolumeUI();
                    updateBrightnessUI();
                    updateBatteryUI();
                    updateAudioDeviceUI();
                }
                function initSystemStatusControls() {
                    document.querySelectorAll('.system-network-indicator').forEach(indicator => {
                        indicator.setAttribute('data-default', indicator.textContent || '');
                    });
                    document.querySelectorAll('[data-system-menu-trigger]').forEach(trigger => {
                        const bindFunc = window.bindDropdownTrigger;
                        if (typeof bindFunc === 'function') {
                            bindFunc(trigger, {
                                hoverRequiresOpen: true,
                            });
                        }
                    });
                    document.querySelectorAll('[data-system-toggle]').forEach(toggle2 => {
                        toggle2.setAttribute('data-action', 'system:toggle');
                    });
                    document.querySelectorAll('[data-system-slider]').forEach(slider => {
                        ['pointerdown', 'mousedown', 'touchstart'].forEach(evt => {
                            slider.addEventListener(evt, e => e.stopPropagation());
                        });
                        slider.addEventListener('input', event => {
                            event.stopPropagation();
                            const target = event.target;
                            const value = Number(target.value);
                            const type = target.getAttribute('data-system-slider');
                            if (type) {
                                handleSystemSliderInput(type, value);
                            }
                        });
                    });
                    document.querySelectorAll('[data-system-action]').forEach(btn => {
                        btn.setAttribute('data-action', 'system:action');
                    });
                    document.querySelectorAll('[data-audio-device]').forEach(btn => {
                        btn.setAttribute('data-action', 'system:setAudioDevice');
                    });
                    document.querySelectorAll('[data-network]').forEach(btn => {
                        btn.setAttribute('data-action', 'system:setNetwork');
                    });
                    document.querySelectorAll('[data-device]').forEach(btn => {
                        btn.setAttribute('data-action', 'system:setBluetoothDevice');
                    });
                    updateAllSystemStatusUI();
                }
                const SystemUIInstance = {
                    initSystemStatusControls,
                    updateAllSystemStatusUI,
                    handleSystemToggle,
                    handleSystemAction,
                    handleSystemSliderInput,
                    setConnectedNetwork,
                    setBluetoothDevice,
                    setAudioDevice,
                    getSystemStatus: () => Object.assign({}, systemStatus),
                };
                window.SystemUI = SystemUIInstance;
            })();
        },
    });

    // src/ts/ui/window-menu.ts
    function t(key, fallback) {
        var _a, _b, _c;
        const api = window.API;
        return (_c =
            (_b = (_a = api == null ? void 0 : api.i18n) == null ? void 0 : _a.translate) == null
                ? void 0
                : _b.call(_a, key, fallback)) != null
            ? _c
            : fallback;
    }
    function rebuildWindowMenu() {
        var _a, _b;
        try {
            const container = document.getElementById('window-menu-container');
            const dropdown = document.getElementById('window-menu-dropdown');
            if (!container || !dropdown) {
                logger_default.warn(CATEGORY, 'Window menu container not found in DOM');
                return;
            }
            const windowsByApp = /* @__PURE__ */ new Map();
            const registry2 = window.WindowRegistry;
            const allWindows =
                ((_a = registry2 == null ? void 0 : registry2.getAllWindows) == null
                    ? void 0
                    : _a.call(registry2)) || [];
            allWindows.forEach(win => {
                const type = win == null ? void 0 : win.type;
                if (!type) return;
                if (!windowsByApp.has(type)) {
                    windowsByApp.set(type, []);
                }
                windowsByApp.get(type).push(win);
            });
            if (windowsByApp.size === 0) {
                container.style.display = 'none';
                return;
            }
            container.style.display = 'block';
            dropdown.innerHTML = '';
            const activeWindow =
                (_b = registry2 == null ? void 0 : registry2.getActiveWindow) == null
                    ? void 0
                    : _b.call(registry2);
            const appConfigs = [
                {
                    appType: 'finder',
                    label: t('apps.finder.label', 'Finder'),
                },
                {
                    appType: 'terminal',
                    label: t('apps.terminal.label', 'Terminal'),
                },
                {
                    appType: 'text-editor',
                    label: t('apps.text-editor.label', 'Schreibprogramm'),
                },
                {
                    appType: 'photos',
                    label: t('apps.photos.label', 'Fotos'),
                },
            ];
            appConfigs.forEach((config, index) => {
                const instances = windowsByApp.get(config.appType) || [];
                if (instances.length === 0) return;
                if (index > 0) {
                    const separator = document.createElement('li');
                    separator.className = 'menu-separator';
                    separator.setAttribute('role', 'separator');
                    separator.setAttribute('aria-hidden', 'true');
                    dropdown.appendChild(separator);
                }
                const sorted = [...instances].sort(
                    (a, b) =>
                        ((a == null ? void 0 : a.zIndex) || 0) -
                        ((b == null ? void 0 : b.zIndex) || 0)
                );
                sorted.forEach((instance, instanceIndex) => {
                    const isActive = !!activeWindow && activeWindow.id === instance.id;
                    const li = document.createElement('li');
                    li.setAttribute('role', 'none');
                    const button = document.createElement('button');
                    button.type = 'button';
                    button.className = 'menu-item';
                    button.setAttribute('role', 'menuitem');
                    button.setAttribute('tabindex', '-1');
                    button.dataset.windowId = instance.id;
                    button.dataset.action = 'switchToWindow';
                    button.dataset.param = instance.id;
                    const labelSpan = document.createElement('span');
                    labelSpan.className = 'menu-item-label';
                    labelSpan.textContent = `${config.label} ${instanceIndex + 1}`;
                    button.appendChild(labelSpan);
                    if (isActive) {
                        const checkmark = document.createElement('span');
                        checkmark.className = 'menu-item-checkmark';
                        checkmark.textContent = '\u2713';
                        checkmark.style.marginLeft = '12px';
                        button.appendChild(checkmark);
                    }
                    li.appendChild(button);
                    dropdown.appendChild(li);
                });
            });
            const sep = document.createElement('li');
            sep.className = 'menu-separator';
            sep.setAttribute('role', 'separator');
            sep.setAttribute('aria-hidden', 'true');
            dropdown.appendChild(sep);
            const newWindowLi = document.createElement('li');
            newWindowLi.setAttribute('role', 'none');
            const newWindowButton = document.createElement('button');
            newWindowButton.type = 'button';
            newWindowButton.className = 'menu-item';
            newWindowButton.setAttribute('role', 'menuitem');
            newWindowButton.setAttribute('tabindex', '-1');
            newWindowButton.dataset.action = 'newFinderWindow';
            const newWindowLabel = document.createElement('span');
            newWindowLabel.className = 'menu-item-label';
            newWindowLabel.dataset.i18n = 'menubar.window.newFinder';
            newWindowLabel.textContent = t('menubar.window.newFinder', 'Neuer Finder');
            newWindowButton.appendChild(newWindowLabel);
            newWindowLi.appendChild(newWindowButton);
            dropdown.appendChild(newWindowLi);
            const totalInstances = Array.from(windowsByApp.values()).reduce(
                (sum, arr) => sum + arr.length,
                0
            );
            if (totalInstances > 1) {
                const closeAllLi = document.createElement('li');
                closeAllLi.setAttribute('role', 'none');
                const closeAllButton = document.createElement('button');
                closeAllButton.type = 'button';
                closeAllButton.className = 'menu-item';
                closeAllButton.setAttribute('role', 'menuitem');
                closeAllButton.setAttribute('tabindex', '-1');
                closeAllButton.dataset.action = 'closeAllWindows';
                const closeAllLabel = document.createElement('span');
                closeAllLabel.className = 'menu-item-label';
                closeAllLabel.dataset.i18n = 'menubar.window.closeAll';
                closeAllLabel.textContent = t('menubar.window.closeAll', 'Alle schlie\xDFen');
                closeAllButton.appendChild(closeAllLabel);
                closeAllLi.appendChild(closeAllButton);
                dropdown.appendChild(closeAllLi);
            }
            logger_default.info(
                CATEGORY,
                `Window menu rebuilt with ${allWindows.length} instances`
            );
        } catch (err) {
            logger_default.warn(CATEGORY, 'rebuildWindowMenu failed:', err);
        }
    }
    function initializeWindowMenu() {
        var _a, _b, _c;
        try {
            const actionBus = window.ActionBus;
            if (!actionBus) {
                logger_default.warn(CATEGORY, 'ActionBus not available, delaying initialization');
                setTimeout(initializeWindowMenu, 100);
                return;
            }
            const W = window;
            const bindTriggerWithRetry = () => {
                const trigger2 = document.getElementById('window-menu-trigger');
                if (!trigger2) return;
                if (trigger2.getAttribute('data-window-menu-trigger-bound') === '1') return;
                const binder = window;
                if (typeof binder.bindDropdownTrigger === 'function') {
                    binder.bindDropdownTrigger(trigger2, { hoverRequiresOpen: true });
                    trigger2.setAttribute('data-window-menu-trigger-bound', '1');
                    return;
                }
                W.__windowMenuTriggerRetry = window.setTimeout(bindTriggerWithRetry, 150);
            };
            bindTriggerWithRetry();
            const trigger = document.getElementById('window-menu-trigger');
            if (trigger && trigger.getAttribute('data-window-menu-hooked') !== '1') {
                trigger.setAttribute('data-window-menu-hooked', '1');
                trigger.addEventListener(
                    'click',
                    () => {
                        rebuildWindowMenu();
                    },
                    true
                );
            }
            actionBus.register('switchToWindow', params => {
                var _a2;
                try {
                    const windowId =
                        (params == null ? void 0 : params.param) ||
                        (params == null ? void 0 : params.windowId);
                    if (!windowId) return;
                    const registry2 = window.WindowRegistry;
                    const win =
                        (_a2 = registry2 == null ? void 0 : registry2.getWindow) == null
                            ? void 0
                            : _a2.call(registry2, windowId);
                    if (!win) return;
                    if (typeof win.bringToFront === 'function') {
                        win.bringToFront();
                    }
                    logger_default.info(CATEGORY, `Switched to window ${windowId}`);
                    rebuildWindowMenu();
                } catch (err) {
                    logger_default.warn(CATEGORY, 'switchToWindow action failed:', err);
                }
            });
            actionBus.register('newFinderWindow', () => {
                try {
                    const FW = window.FinderWindow;
                    if (FW && typeof FW.create === 'function') {
                        FW.create();
                        logger_default.info(CATEGORY, 'Created new Finder window');
                        setTimeout(rebuildWindowMenu, 50);
                        return;
                    }
                    logger_default.warn(
                        CATEGORY,
                        'FinderWindow.create() not available; cannot create new Finder window'
                    );
                } catch (err) {
                    logger_default.warn(CATEGORY, 'newFinderWindow action failed:', err);
                }
            });
            actionBus.register('closeAllWindows', () => {
                try {
                    const confirmed = confirm(
                        t('menubar.window.closeAllConfirm', 'Wirklich alle Fenster schlie\xDFen?')
                    );
                    if (!confirmed) return;
                    const registry2 = window.WindowRegistry;
                    if (registry2 && typeof registry2.closeAllWindows === 'function') {
                        registry2.closeAllWindows();
                    }
                    logger_default.info(CATEGORY, 'Closed all windows');
                    rebuildWindowMenu();
                } catch (err) {
                    logger_default.warn(CATEGORY, 'closeAllWindows action failed:', err);
                }
            });
            rebuildWindowMenu();
            if (W.WindowRegistry && !W.__windowMenuPatched) {
                W.__windowMenuPatched = true;
                let scheduled = false;
                const schedule = () => {
                    if (scheduled) return;
                    scheduled = true;
                    setTimeout(() => {
                        scheduled = false;
                        rebuildWindowMenu();
                    }, 50);
                };
                try {
                    const origRegisterWindow =
                        (_a = W.WindowRegistry.registerWindow) == null
                            ? void 0
                            : _a.bind(W.WindowRegistry);
                    if (origRegisterWindow) {
                        W.WindowRegistry.registerWindow = win => {
                            origRegisterWindow(win);
                            schedule();
                        };
                    }
                } catch (err) {
                    logger_default.debug(
                        CATEGORY,
                        'Could not patch WindowRegistry.registerWindow:',
                        err
                    );
                }
                try {
                    const origRemoveWindow =
                        (_b = W.WindowRegistry.removeWindow) == null
                            ? void 0
                            : _b.bind(W.WindowRegistry);
                    if (origRemoveWindow) {
                        W.WindowRegistry.removeWindow = windowId => {
                            origRemoveWindow(windowId);
                            schedule();
                        };
                    }
                } catch (err) {
                    logger_default.debug(
                        CATEGORY,
                        'Could not patch WindowRegistry.removeWindow:',
                        err
                    );
                }
                try {
                    const origSetActive =
                        (_c = W.WindowRegistry.setActiveWindow) == null
                            ? void 0
                            : _c.bind(W.WindowRegistry);
                    if (origSetActive) {
                        W.WindowRegistry.setActiveWindow = windowId => {
                            origSetActive(windowId);
                            schedule();
                        };
                    }
                } catch (err) {
                    logger_default.debug(
                        CATEGORY,
                        'Could not patch WindowRegistry.setActiveWindow:',
                        err
                    );
                }
            }
            logger_default.info(CATEGORY, 'Window menu initialized');
        } catch (err) {
            logger_default.error(CATEGORY, 'Window menu initialization failed:', err);
        }
    }
    var CATEGORY;
    var init_window_menu = __esm({
        'src/ts/ui/window-menu.ts'() {
            'use strict';
            init_logger();
            CATEGORY = 'WindowMenu';
        },
    });

    // src/ts/services/session-guard.ts
    function validateMultiWindowSession(storage = localStorage) {
        var _a;
        const raw = storage.getItem(MULTI_KEY);
        if (!raw) return { parsed: null, shouldClear: false };
        try {
            const session = JSON.parse(raw);
            logFound(
                'multi-window',
                ((_a = session == null ? void 0 : session.windows) == null ? void 0 : _a.length) ||
                    0,
                session == null ? void 0 : session.windows
            );
            if (isCountTooHigh(session == null ? void 0 : session.windows)) {
                warnTooMany('multi-window');
                return { parsed: session, shouldClear: true, reason: 'too-many-windows' };
            }
            if (hasTypeOverflow(session == null ? void 0 : session.windows)) {
                warnTypeOverflow('multi-window');
                return { parsed: session, shouldClear: true, reason: 'type-overflow' };
            }
            return { parsed: session, shouldClear: false };
        } catch (err) {
            console.warn('[SESSION-GUARD] Multi-window session invalid JSON:', err);
            return { parsed: null, shouldClear: true, reason: 'invalid-json' };
        }
    }
    function validateLegacySession(storage = localStorage) {
        var _a;
        const raw = storage.getItem(LEGACY_KEY);
        if (!raw) {
            console.log('[SESSION-GUARD] Legacy session exists? false');
            return { parsed: null, shouldClear: false };
        }
        try {
            const session = JSON.parse(raw);
            logFound(
                'legacy',
                ((_a = session == null ? void 0 : session.instances) == null
                    ? void 0
                    : _a.length) || 0,
                session == null ? void 0 : session.instances
            );
            if (isCountTooHigh(session == null ? void 0 : session.instances)) {
                warnTooMany('legacy');
                return { parsed: session, shouldClear: true, reason: 'too-many-instances' };
            }
            if (hasTypeOverflow(session == null ? void 0 : session.instances)) {
                warnTypeOverflow('legacy');
                return { parsed: session, shouldClear: true, reason: 'type-overflow' };
            }
            return { parsed: session, shouldClear: false };
        } catch (err) {
            console.warn('[SESSION-GUARD] Legacy session invalid JSON:', err);
            return { parsed: null, shouldClear: true, reason: 'invalid-json' };
        }
    }
    function clearSessionKey(key, storage = localStorage) {
        try {
            storage.removeItem(key);
        } catch (err) {
            console.warn(`[SESSION-GUARD] Failed to clear ${key}:`, err);
        }
    }
    function isCountTooHigh(items) {
        if (!Array.isArray(items)) return false;
        return items.length > 10;
    }
    function hasTypeOverflow(items) {
        if (!Array.isArray(items)) return false;
        const typeCount = /* @__PURE__ */ new Map();
        for (const item of items) {
            const t2 = (item == null ? void 0 : item.type) || '';
            if (!t2) continue;
            const count = (typeCount.get(t2) || 0) + 1;
            typeCount.set(t2, count);
            if (count > 3) return true;
        }
        return false;
    }
    function logFound(label, count, items) {
        const plural = label === 'legacy' ? 'instances' : 'windows';
        console.log(`[SESSION-GUARD] Found ${label} session:`, {
            [`${label}Count`]: count,
            items:
                (items == null
                    ? void 0
                    : items.map(i => ({
                          type: i == null ? void 0 : i.type,
                          id: i == null ? void 0 : i.id,
                      }))) || [],
            label,
            plural,
        });
    }
    function warnTooMany(label) {
        const noun = label === 'legacy' ? 'instances' : 'windows';
        console.warn(`[SESSION-GUARD] ${label} session corrupted (too many ${noun})`);
    }
    function warnTypeOverflow(label) {
        const noun = label === 'legacy' ? 'instances' : 'windows';
        console.warn(`[SESSION-GUARD] ${label} session has too many ${noun} per type (>3)`);
    }
    var MULTI_KEY, LEGACY_KEY;
    var init_session_guard = __esm({
        'src/ts/services/session-guard.ts'() {
            'use strict';
            MULTI_KEY = 'multi-window-session';
            LEGACY_KEY = 'windowInstancesSession';
        },
    });

    // src/ts/compat/instance-shims.ts
    function installShim(opts, win) {
        if (typeof win[opts.legacyName] !== 'undefined') return;
        try {
            win[opts.legacyName] = {
                createInstance: opts.createInstance,
                getInstanceCount: opts.getInstanceCount,
                getAllInstances: opts.getAllInstances,
                getActiveInstance: opts.getActiveInstance,
                setActiveInstance: opts.setActiveInstance,
            };
            console.info(`[COMPAT] ${opts.legacyName} shim installed`);
        } catch (err) {
            console.warn(`[COMPAT] ${opts.legacyName} shim failed:`, err);
        }
    }
    var init_instance_shims = __esm({
        'src/ts/compat/instance-shims.ts'() {
            'use strict';
        },
    });

    // src/ts/core/app-init.ts
    function initModalIds() {
        var _a, _b, _c, _d, _e, _f;
        const win = window;
        if (win.WindowManager) {
            const modalIds =
                ((_b = (_a = win.WindowManager).getAllWindowIds) == null ? void 0 : _b.call(_a)) ||
                [];
            const transientIds =
                ((_d = (_c = win.WindowManager).getTransientWindowIds) == null
                    ? void 0
                    : _d.call(_c)) || [];
            return {
                modalIds,
                transientModalIds: new Set(transientIds),
            };
        } else {
            const modalIds = ((_e = win.APP_CONSTANTS) == null ? void 0 : _e.MODAL_IDS) || [
                'projects-modal',
                'about-modal',
                'settings-modal',
                'text-modal',
                'terminal-modal',
                'image-modal',
                'program-info-modal',
            ];
            const transientModalIds =
                ((_f = win.APP_CONSTANTS) == null ? void 0 : _f.TRANSIENT_MODAL_IDS) ||
                /* @__PURE__ */ new Set(['program-info-modal']);
            return { modalIds, transientModalIds };
        }
    }
    function initApp() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u;
        const win = window;
        const funcs = window;
        const { modalIds } = initModalIds();
        if (win.ActionBus) {
            (_b = (_a = win.ActionBus).init) == null ? void 0 : _b.call(_a);
        }
        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('click', function (e) {
                var _a2, _b2, _c2;
                const target = e.target;
                if (e.target === modal || modal.contains(target)) {
                    (_a2 = funcs.hideMenuDropdowns) == null ? void 0 : _a2.call(funcs);
                    (_b2 = funcs.bringDialogToFront) == null ? void 0 : _b2.call(funcs, modal.id);
                    (_c2 = funcs.updateProgramLabelByTopModal) == null ? void 0 : _c2.call(funcs);
                }
            });
        });
        const dialogs = window.dialogs || {};
        window.dialogs = dialogs;
        if (modalIds && Array.isArray(modalIds)) {
            modalIds.forEach(id => {
                var _a2, _b2;
                const modal = document.getElementById(id);
                if (!modal || !win.Dialog) return;
                try {
                    const dialogInstance = new win.Dialog(id);
                    dialogs[id] = dialogInstance;
                    if (win.WindowManager) {
                        (_b2 = (_a2 = win.WindowManager).setDialogInstance) == null
                            ? void 0
                            : _b2.call(_a2, id, dialogInstance);
                    }
                } catch (err) {
                    console.error(`Failed to create dialog instance for "${id}":`, err);
                }
            });
        }
        const launchpadModal = document.getElementById('launchpad-modal');
        if (launchpadModal) {
            launchpadModal.addEventListener('click', function (e) {
                var _a2;
                try {
                    const inner = launchpadModal.querySelector('.launchpad-modal-inner');
                    const target = e.target;
                    if (inner ? !inner.contains(target) : target === launchpadModal) {
                        const launchpadDialog = dialogs['launchpad-modal'];
                        (_a2 = launchpadDialog == null ? void 0 : launchpadDialog.close) == null
                            ? void 0
                            : _a2.call(launchpadDialog);
                    }
                } catch {}
            });
            document.addEventListener(
                'click',
                function (e) {
                    var _a2;
                    try {
                        if (launchpadModal.classList.contains('hidden')) return;
                        const inner = launchpadModal.querySelector('.launchpad-modal-inner');
                        const target = e.target;
                        if (inner && inner.contains(target)) return;
                        const launchpadDialog = dialogs['launchpad-modal'];
                        (_a2 = launchpadDialog == null ? void 0 : launchpadDialog.close) == null
                            ? void 0
                            : _a2.call(launchpadDialog);
                    } catch {}
                },
                true
            );
        }
        (_c = funcs.syncTopZIndexWithDOM) == null ? void 0 : _c.call(funcs);
        (_d = funcs.restoreWindowPositions) == null ? void 0 : _d.call(funcs);
        window.__SESSION_RESTORE_IN_PROGRESS = true;
        (_e = funcs.restoreOpenModals) == null ? void 0 : _e.call(funcs);
        (_f = funcs.initSystemStatusControls) == null ? void 0 : _f.call(funcs);
        if (win.DesktopSystem) {
            (_h = (_g = win.DesktopSystem).initDesktop) == null ? void 0 : _h.call(_g);
        }
        if (win.SettingsSystem) {
            const settingsContainer = document.getElementById('settings-container');
            if (settingsContainer) {
                (_j = (_i = win.SettingsSystem).init) == null
                    ? void 0
                    : _j.call(_i, settingsContainer);
            }
        }
        if (win.TextEditorSystem) {
            const textEditorContainer = document.getElementById('text-editor-container');
            if (textEditorContainer) {
                (_l = (_k = win.TextEditorSystem).init) == null
                    ? void 0
                    : _l.call(_k, textEditorContainer);
            }
        }
        if (!win.TerminalInstanceManager && win.TerminalSystem) {
            const terminalContainer = document.getElementById('terminal-container');
            if (terminalContainer) {
                (_n = (_m = win.TerminalSystem).init) == null
                    ? void 0
                    : _n.call(_m, terminalContainer);
            }
        }
        (_o = funcs.initDockMagnification) == null ? void 0 : _o.call(funcs);
        if (win.DockSystem && typeof win.DockSystem.initDockDragDrop === 'function') {
            win.DockSystem.initDockDragDrop();
        }
        if (win.WindowRegistry) {
            (_q = (_p = win.WindowRegistry).init) == null ? void 0 : _q.call(_p);
        }
        try {
            initializeWindowMenu();
        } catch (err) {
            console.warn('[APP-INIT] Window menu initialization failed:', err);
        }
        let sessionRestoreComplete = () => {};
        const sessionRestorePromise = new Promise(resolve => {
            sessionRestoreComplete = resolve;
        });
        window.__sessionRestorePromise = sessionRestorePromise;
        if (win.MultiWindowSessionManager) {
            try {
                const multiCheck = validateMultiWindowSession();
                const legacyCheck = validateLegacySession();
                if (legacyCheck.shouldClear) {
                    console.warn('[APP-INIT] Clearing ONLY legacy session (corrupted)');
                    clearSessionKey('windowInstancesSession');
                }
                if (multiCheck.shouldClear) {
                    console.warn('[APP-INIT] Clearing multi-window session (corrupted)');
                    clearSessionKey('multi-window-session');
                }
                (_s = (_r = win.MultiWindowSessionManager).init) == null ? void 0 : _s.call(_r);
                console.log('[APP-INIT] MultiWindowSessionManager initialized');
                setTimeout(async () => {
                    var _a2;
                    try {
                        if (
                            (_a2 = win.MultiWindowSessionManager) == null
                                ? void 0
                                : _a2.restoreSession
                        ) {
                            const restored = await win.MultiWindowSessionManager.restoreSession();
                            if (restored) {
                                console.log('[APP-INIT] Multi-window session restored');
                            }
                        }
                    } catch (err) {
                        console.warn('[APP-INIT] Multi-window session restore failed:', err);
                    } finally {
                        sessionRestoreComplete();
                    }
                }, 150);
            } catch (err) {
                console.warn('[APP-INIT] MultiWindowSessionManager initialization failed:', err);
                sessionRestoreComplete();
            }
        } else {
            sessionRestoreComplete();
        }
        if (win.SessionManager) {
            try {
                (_u = (_t = win.SessionManager).init) == null ? void 0 : _u.call(_t);
                setTimeout(() => {
                    var _a2;
                    try {
                        if ((_a2 = win.SessionManager) == null ? void 0 : _a2.restoreSession) {
                            win.SessionManager.restoreSession();
                        }
                    } finally {
                        window.__SESSION_RESTORE_IN_PROGRESS = false;
                        window.__SESSION_RESTORE_DONE = true;
                    }
                }, 100);
            } catch (err) {
                console.warn('SessionManager initialization failed:', err);
            }
        }
        try {
            const dockEl = document.getElementById('dock');
            if (dockEl) {
                if (dockEl.classList.contains('hidden')) dockEl.classList.remove('hidden');
                dockEl.style.display = dockEl.style.display || '';
                dockEl.style.visibility = dockEl.style.visibility || 'visible';
            }
        } catch {}
        try {
            const dockEl = document.getElementById('dock');
            if (dockEl && dockEl.parentElement && dockEl.parentElement !== document.body) {
                document.body.appendChild(dockEl);
                console.info('[APP-INIT] moved #dock to document.body to avoid hidden ancestor(s)');
            }
        } catch {}
        try {
            const ensureModalsInBody = () => {
                try {
                    const modals = Array.from(document.querySelectorAll('.modal'));
                    let moved = false;
                    modals.forEach(m => {
                        if (m.parentElement && m.parentElement !== document.body) {
                            document.body.appendChild(m);
                            moved = true;
                        }
                    });
                    if (moved)
                        console.info(
                            '[APP-INIT] reparented misplaced .modal elements to document.body'
                        );
                    return moved;
                } catch {
                    return false;
                }
            };
            ensureModalsInBody();
            setTimeout(ensureModalsInBody, 50);
            setTimeout(ensureModalsInBody, 200);
            setTimeout(ensureModalsInBody, 500);
        } catch {}
        try {
            const dockEl = document.getElementById('dock');
            if (dockEl) {
                const rect = dockEl.getBoundingClientRect();
                const cs = window.getComputedStyle(dockEl);
                console.info('[APP-INIT] Dock debug:', {
                    className: dockEl.className,
                    display: cs.display,
                    visibility: cs.visibility,
                    opacity: cs.opacity,
                    width: rect.width,
                    height: rect.height,
                    top: rect.top,
                    left: rect.left,
                    inViewport: rect.top < (window.innerHeight || 0) && rect.bottom > 0,
                });
                try {
                    const dbg = JSON.stringify({
                        className: dockEl.className,
                        display: cs.display,
                        visibility: cs.visibility,
                        opacity: cs.opacity,
                        width: Math.round(rect.width),
                        height: Math.round(rect.height),
                        top: Math.round(rect.top),
                        left: Math.round(rect.left),
                        inViewport: rect.top < (window.innerHeight || 0) && rect.bottom > 0,
                    });
                    dockEl.setAttribute('data-dock-debug', dbg);
                } catch {}
            } else {
                console.info('[APP-INIT] Dock debug: element not found');
            }
        } catch (e) {
            console.warn('[APP-INIT] Dock debug failed', e);
        }
        const gw = window;
        async function markReady() {
            try {
                const sessionRestorePromise2 = window.__sessionRestorePromise;
                if (sessionRestorePromise2) {
                    try {
                        await sessionRestorePromise2;
                        console.log('[APP-INIT] Waited for session restore before marking ready');
                    } catch (e) {
                        console.warn('[APP-INIT] Session restore wait failed:', e);
                    }
                }
                const ensureDockInBody = () => {
                    try {
                        const dockEl = document.getElementById('dock');
                        if (
                            dockEl &&
                            dockEl.parentElement &&
                            dockEl.parentElement !== document.body
                        ) {
                            document.body.appendChild(dockEl);
                            console.info(
                                '[APP-INIT] moved #dock to document.body (ensured at load)'
                            );
                            return true;
                        }
                    } catch {}
                    return false;
                };
                ensureDockInBody();
                setTimeout(ensureDockInBody, 50);
                setTimeout(ensureDockInBody, 200);
                setTimeout(ensureDockInBody, 500);
                const gw2 = window;
                if (typeof gw2.VirtualFS === 'undefined' && gw2.__VirtualFS === void 0) {
                    try {
                        const getVFS = () => {
                            var _a2, _b2;
                            if (
                                (_b2 =
                                    (_a2 = gw2.TerminalInstanceManager) == null
                                        ? void 0
                                        : _a2.getActiveSession) == null
                                    ? void 0
                                    : _b2.call(_a2)
                            ) {
                                return true;
                            }
                            return false;
                        };
                        gw2.__VirtualFS_Ready = getVFS();
                        console.info('[APP-INIT] VirtualFS state made queryable');
                    } catch (e) {
                        console.debug('[APP-INIT] VirtualFS exposure skipped:', e.message);
                    }
                }
                if (gw2.WindowRegistry) {
                    gw2.__WindowRegistry = gw2.WindowRegistry;
                    console.info('[APP-INIT] WindowRegistry exposed as __WindowRegistry');
                }
                if (gw2.FinderSystem) {
                    gw2.__FinderSystem = gw2.FinderSystem;
                    console.info('[APP-INIT] FinderSystem exposed as __FinderSystem');
                }
                if (gw2.TerminalSystem) {
                    gw2.__TerminalSystem = gw2.TerminalSystem;
                    console.info('[APP-INIT] TerminalSystem exposed as __TerminalSystem');
                }
                if (gw2.LaunchpadSystem) {
                    gw2.__LaunchpadSystem = gw2.LaunchpadSystem;
                    console.info('[APP-INIT] LaunchpadSystem exposed as __LaunchpadSystem');
                }
                if (gw2.SettingsSystem) {
                    gw2.__SettingsSystem = gw2.SettingsSystem;
                    console.info('[APP-INIT] SettingsSystem exposed as __SettingsSystem');
                }
                if (gw2.SessionManager) {
                    console.info('[APP-INIT] SessionManager available (legacy)');
                }
                if (gw2.DockSystem) {
                    gw2.__DockSystem = gw2.DockSystem;
                    console.info('[APP-INIT] DockSystem exposed as __DockSystem');
                }
                if (gw2.ActionBus) {
                    gw2.__ActionBus = gw2.ActionBus;
                    console.info('[APP-INIT] ActionBus exposed as __ActionBus');
                }
                if (typeof gw2.FinderInstanceManager === 'undefined') {
                    try {
                        const registry2 = gw2.WindowRegistry;
                        installShim(
                            {
                                legacyName: 'FinderInstanceManager',
                                registryType: 'finder',
                                createInstance(opts) {
                                    try {
                                        const windows = registry2.getAllWindows('finder') || [];
                                        const firstWindow = windows[0];
                                        if (
                                            firstWindow &&
                                            typeof firstWindow.addTab === 'function'
                                        ) {
                                            const tabView = gw2.FinderView
                                                ? new gw2.FinderView({
                                                      title:
                                                          (opts == null ? void 0 : opts.title) ||
                                                          'Computer',
                                                      source: 'computer',
                                                  })
                                                : null;
                                            if (tabView) {
                                                firstWindow.addTab(tabView);
                                                return {
                                                    instanceId: tabView.id,
                                                    type: 'finder',
                                                    title: tabView.title,
                                                };
                                            }
                                        }
                                        return null;
                                    } catch (e) {
                                        console.warn(
                                            '[FinderInstanceManager shim] createInstance failed:',
                                            e
                                        );
                                        return null;
                                    }
                                },
                                getInstanceCount() {
                                    try {
                                        const windows = registry2.getAllWindows('finder') || [];
                                        let totalTabs = 0;
                                        windows.forEach(win2 => {
                                            if (win2.tabs && typeof win2.tabs.size === 'number') {
                                                totalTabs += win2.tabs.size;
                                            }
                                        });
                                        return totalTabs;
                                    } catch {
                                        return 0;
                                    }
                                },
                                getAllInstances() {
                                    try {
                                        const windows = registry2.getAllWindows('finder') || [];
                                        const allTabs = [];
                                        windows.forEach(win2 => {
                                            if (
                                                win2.tabs &&
                                                typeof win2.tabs.values === 'function'
                                            ) {
                                                const tabs = Array.from(win2.tabs.values());
                                                tabs.forEach(tab => {
                                                    allTabs.push({
                                                        instanceId: tab.id,
                                                        type: 'finder',
                                                        title: tab.title || 'Finder',
                                                        show: () => {
                                                            var _a2;
                                                            return (_a2 = tab.show) == null
                                                                ? void 0
                                                                : _a2.call(tab);
                                                        },
                                                        hide: () => {
                                                            var _a2;
                                                            return (_a2 = tab.hide) == null
                                                                ? void 0
                                                                : _a2.call(tab);
                                                        },
                                                    });
                                                });
                                            }
                                        });
                                        return allTabs;
                                    } catch {
                                        return [];
                                    }
                                },
                                getActiveInstance() {
                                    try {
                                        const activeWindow = registry2.getActiveWindow();
                                        if (activeWindow && activeWindow.type === 'finder') {
                                            const finderWindow = activeWindow;
                                            if (finderWindow.activeTabId && finderWindow.tabs) {
                                                const activeTab = finderWindow.tabs.get(
                                                    finderWindow.activeTabId
                                                );
                                                if (activeTab) {
                                                    return {
                                                        instanceId: activeTab.id,
                                                        type: 'finder',
                                                        title: activeTab.title || 'Finder',
                                                    };
                                                }
                                            }
                                        }
                                        const windows = registry2.getAllWindows('finder') || [];
                                        for (const win2 of windows) {
                                            const w = win2;
                                            if (w.isVisible && w.isVisible()) {
                                                if (w.activeTabId && w.tabs) {
                                                    const activeTab = w.tabs.get(w.activeTabId);
                                                    if (activeTab) {
                                                        return {
                                                            instanceId: activeTab.id,
                                                            type: 'finder',
                                                            title: activeTab.title || 'Finder',
                                                        };
                                                    }
                                                }
                                            }
                                        }
                                        if (windows.length > 0) {
                                            const firstWindow = windows[0];
                                            if (firstWindow.activeTabId && firstWindow.tabs) {
                                                const activeTab = firstWindow.tabs.get(
                                                    firstWindow.activeTabId
                                                );
                                                if (activeTab) {
                                                    return {
                                                        instanceId: activeTab.id,
                                                        type: 'finder',
                                                        title: activeTab.title || 'Finder',
                                                    };
                                                }
                                            }
                                        }
                                        return null;
                                    } catch (e) {
                                        console.warn(
                                            '[FinderInstanceManager shim] getActiveInstance failed:',
                                            e
                                        );
                                        return null;
                                    }
                                },
                                setActiveInstance(instanceId) {
                                    var _a2, _b2;
                                    try {
                                        const windows = registry2.getAllWindows('finder') || [];
                                        for (const win2 of windows) {
                                            if (
                                                (_a2 = win2.tabs) == null
                                                    ? void 0
                                                    : _a2.has(instanceId)
                                            ) {
                                                (_b2 = win2.setActiveTab) == null
                                                    ? void 0
                                                    : _b2.call(win2, instanceId);
                                                registry2.setActiveWindow(win2.id);
                                                return;
                                            }
                                        }
                                    } catch (e) {
                                        console.warn(
                                            '[FinderInstanceManager shim] setActiveInstance failed:',
                                            e
                                        );
                                    }
                                },
                            },
                            gw2
                        );
                    } catch (e) {
                        console.warn('[APP-INIT] FinderInstanceManager shim failed:', e);
                    }
                }
                gw.__APP_READY = true;
                console.info('[APP-INIT] __APP_READY=true');
                (function scheduleExposureRetries() {
                    const attempts = [50, 200, 500, 1e3, 2e3];
                    const exposeOnce = () => {
                        try {
                            const g = window;
                            const ensureAlias = (name, legacyName) => {
                                try {
                                    const real = g[name] || g[legacyName || name];
                                    if (real) {
                                        if (typeof g[legacyName || name] === 'undefined') {
                                            g[legacyName || name] = real;
                                        }
                                        const alias = `__${name}`;
                                        if (typeof g[alias] === 'undefined') {
                                            g[alias] = real;
                                        }
                                    }
                                } catch {}
                            };
                            [
                                'WindowRegistry',
                                'FinderSystem',
                                'TerminalSystem',
                                'LaunchpadSystem',
                                'SettingsSystem',
                                'DockSystem',
                                'ActionBus',
                                'SessionManager',
                            ].forEach(n => ensureAlias(n));
                        } catch {}
                    };
                    exposeOnce();
                    attempts.forEach(t2 => setTimeout(exposeOnce, t2));
                })();
            } catch {}
        }
        if (document.readyState === 'complete') {
            markReady();
        } else {
            window.addEventListener('load', markReady, { once: true });
            setTimeout(() => {
                if (!gw.__APP_READY) {
                    console.warn(
                        '[APP-INIT] load event not observed within timeout; forcing __APP_READY'
                    );
                    markReady();
                }
            }, 4e3);
        }
    }
    var init_app_init = __esm({
        'src/ts/core/app-init.ts'() {
            'use strict';
            init_window_menu();
            init_session_guard();
            init_instance_shims();
            (() => {
                if (typeof window.initApp !== 'function') {
                    window.initApp = initApp;
                }
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', initApp);
                } else {
                    initApp();
                }
            })();
        },
    });

    // src/ts/compat/expose-globals.ts
    var require_expose_globals = __commonJS({
        'src/ts/compat/expose-globals.ts'() {
            init_i18n();
            init_dom_utils();
            init_constants();
            init_logger();
            init_error_handler();
            init_perf_monitor();
            var import_api = __toESM(require_api());
            var import_window_manager = __toESM(require_window_manager());
            var import_action_bus = __toESM(require_action_bus());
            init_dialog_utils();
            var import_snap_utils = __toESM(require_snap_utils());
            var import_program_actions = __toESM(require_program_actions());
            var import_program_menu_sync = __toESM(require_program_menu_sync());
            init_menu();
            init_dock();
            init_dialog();
            var import_menubar_utils = __toESM(require_menubar_utils());
            init_context_menu();
            var import_storage = __toESM(require_storage());
            var import_theme = __toESM(require_theme());
            init_base_window_instance();
            var import_instance_manager = __toESM(require_instance_manager());
            var import_window_chrome = __toESM(require_window_chrome());
            init_base_tab();
            init_base_window();
            init_window_registry();
            init_terminal_session();
            init_terminal_window();
            init_text_editor_document();
            init_text_editor_window();
            var import_text_editor_instance = __toESM(require_text_editor_instance());
            init_finder_view();
            init_finder_window();
            init_multi_window_session();
            var import_session_manager = __toESM(require_session_manager());
            var import_window_tabs = __toESM(require_window_tabs());
            var import_terminal_instance = __toESM(require_terminal_instance());
            var import_text_editor = __toESM(require_text_editor());
            init_settings();
            var import_image_viewer_utils = __toESM(require_image_viewer_utils());
            init_logger();
            var import_keyboard_shortcuts = __toESM(require_keyboard_shortcuts());
            var import_github_api = __toESM(require_github_api());
            var import_photos_app = __toESM(require_photos_app());
            init_window_configs();
            init_finder_instance();
            var import_launchpad = __toESM(require_launchpad());
            var import_multi_instance_integration = __toESM(require_multi_instance_integration());
            init_desktop();
            init_system();
            init_app_init();
            console.log('[BUNDLE] expose-globals.ts loading...');
            var w = window;
            if (!('DOMUtils' in w)) {
                w['DOMUtils'] = dom_utils_exports;
            }
            try {
                if (!w.FinderView) w.FinderView = FinderView;
                if (!w.FinderWindow) w.FinderWindow = FinderWindow;
                if (!w.TerminalWindow) w.TerminalWindow = TerminalWindow;
            } catch {}
            try {
                console.log('[BUNDLE] Globals present:', {
                    FinderView: !!w.FinderView,
                    FinderWindow: !!w.FinderWindow,
                    TerminalWindow: !!w.TerminalWindow,
                    WindowRegistry: !!w.WindowRegistry,
                    ActionBus: !!w.ActionBus,
                });
            } catch {}
            if (typeof w.initApp === 'function') {
                console.log('[BUNDLE] Triggering initApp; readyState:', document.readyState);
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', w.initApp);
                } else {
                    w.initApp();
                }
            } else {
                console.error('[BUNDLE] window.initApp is not defined; app initialization failed');
            }
            w.__BUNDLE_READY__ = true;
        },
    });
    return require_expose_globals();
})();
//# sourceMappingURL=app.bundle.js.map

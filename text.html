<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="textEditor.title">Texteditor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        window.tailwind = window.tailwind || {};
        window.tailwind.config = Object.assign({}, window.tailwind.config, { darkMode: 'class' });
    </script>
    <script src="i18n.js"></script>
    <style>
        :root {
            color-scheme: light;
            --editor-body-bg: #fafafa;
            --editor-text: #111827;
            --editor-toolbar-bg: #f5f5f5;
            --editor-toolbar-border: #d1d5db;
            --editor-toolbar-button-bg: #ffffff;
            --editor-toolbar-button-hover: #e5e7eb;
            --editor-toolbar-button-border: #d1d5db;
            --editor-surface-bg: #ffffff;
        }

        .dark {
            color-scheme: dark;
            --editor-body-bg: #0f172a;
            --editor-text: #e5e7eb;
            --editor-toolbar-bg: #1f2937;
            --editor-toolbar-border: #374151;
            --editor-toolbar-button-bg: #111827;
            --editor-toolbar-button-hover: #1f2937;
            --editor-toolbar-button-border: #475569;
            --editor-surface-bg: #111827;
        }

        * {
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        body {
            display: flex;
            flex-direction: column;
            font-family: sans-serif;
            background: var(--editor-body-bg);
            color: var(--editor-text);
        }
        #toolbar {
            flex: 0 0 auto;
            background: var(--editor-toolbar-bg);
            padding: 8px 12px;
            border-bottom: 1px solid var(--editor-toolbar-border);
            display: flex;
            gap: 8px;
            align-items: center;
        }
        #toolbar button {
            margin: 0;
            padding: 6px 12px;
            font-size: 14px;
            border: 1px solid var(--editor-toolbar-button-border);
            background: var(--editor-toolbar-button-bg);
            cursor: pointer;
            color: inherit;
            border-radius: 6px;
        }
        #toolbar button:hover {
            background: var(--editor-toolbar-button-hover);
        }
        #toolbar button:disabled {
            opacity: 0.5;
            cursor: default;
        }
        #file-status {
            flex: 0 0 auto;
            padding: 8px 16px;
            border-bottom: 1px solid var(--editor-toolbar-border);
            background: var(--editor-body-bg);
            color: var(--editor-text);
            font-size: 14px;
            opacity: 0.75;
            display: none;
        }
        #file-status.active {
            display: block;
        }
        #editor {
            flex: 1 1 auto;
            width: 100%;
            resize: none;
            padding: 16px;
            border: none;
            outline: none;
            background: var(--editor-surface-bg);
            color: inherit;
            font-family: "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 14px;
            line-height: 1.6;
            tab-size: 4;
        }
    </style>
</head>

<body class="dialog-content" onclick="onClick()">
    <div id="toolbar">
        <button type="button" onclick="clearEditor()" data-i18n="textEditor.toolbar.clear" data-i18n-title="textEditor.toolbar.clear">Neu</button>
        <button type="button" onclick="openFile()" data-i18n="textEditor.toolbar.open" data-i18n-title="textEditor.toolbar.open">Öffnen</button>
        <button type="button" onclick="saveFile()" data-i18n="textEditor.toolbar.save" data-i18n-title="textEditor.toolbar.save" id="save-button">Speichern</button>
        <!-- Hidden file input for opening files -->
        <input type="file" id="file-input"
            accept=".txt,.md,.markdown,.html,.htm,.css,.scss,.js,.jsx,.ts,.tsx,.json,.yml,.yaml,.xml,.csv,.tsv,.ini,.cfg,.conf,.env,.gitignore,.log,.c,.h,.cpp,.hpp,.java,.kt,.swift,.cs,.py,.rb,.php,.rs,.go,.sh,.bash,.zsh,.fish,.ps1,.bat"
            style="display:none">
    </div>
    <div id="file-status"></div>
    <textarea id="editor" spellcheck="false" wrap="off"></textarea>
    <script>
        function applyTheme(isDark) {
            document.documentElement.classList.toggle('dark', !!isDark);
        }
        (function initThemeSync() {
            try {
                const parentRoot = window.parent.document.documentElement;
                const updateFromParent = () => applyTheme(parentRoot.classList.contains('dark'));
                updateFromParent();
                const observer = new MutationObserver(updateFromParent);
                observer.observe(parentRoot, { attributes: true, attributeFilter: ['class'] });
            } catch (err) {
                const mediaQuery = window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)') : null;
                applyTheme(mediaQuery ? mediaQuery.matches : false);
                if (mediaQuery) {
                    const listener = (event) => applyTheme(event.matches);
                    if (typeof mediaQuery.addEventListener === 'function') {
                        mediaQuery.addEventListener('change', listener);
                    } else if (typeof mediaQuery.addListener === 'function') {
                        mediaQuery.addListener(listener);
                    }
                }
            }
        })();
        // Den übergeordneten Dialog identifizieren, damit das Fenster im Fokus bleibt
        const dialog = window.parent.loaded(window.frameElement);
        // Bring the editor window to the front whenever this iframe gains focus (e.g. click or tab inside editor).
        window.addEventListener('focus', () => {
            try {
                dialog.refocus();
            } catch (e) {
                console.error('Error refocusing dialog from text editor:', e);
            }
        });
        function onClick() {
            dialog.refocus();
        }
        const appI18n = window.appI18n || {
            translate: (key) => key,
            applyTranslations: () => { },
            getLanguagePreference: () => 'system',
            getActiveLanguage: () => 'en',
            setLanguagePreference: () => { }
        };
        const fallbackMessages = {
            'textEditor.documentTitle': () => 'Texteditor',
            'textEditor.documentTitleWithFile': (params) => {
                const fileName = params && params.fileName ? params.fileName : '';
                return fileName ? `Texteditor – ${fileName}` : 'Texteditor';
            },
            'textEditor.status.loading': () => 'Lade Datei …',
            'textEditor.status.loadingWithLabel': (params) => {
                const label = params && params.label ? params.label : '';
                return label ? `${label} (lädt …)` : 'Lade Datei …';
            },
            'textEditor.status.loadError': () => 'Datei konnte nicht geladen werden.',
            'textEditor.status.rateLimit': () => 'GitHub Rate Limit erreicht. Bitte versuche es später erneut.'
        };
        function resolveTranslation(key, params) {
            if (!key) return { text: '', translated: false };
            try {
                const translated = appI18n.translate(key, params);
                if (translated && translated !== key) {
                    return { text: translated, translated: true };
                }
            } catch (err) {
                console.warn('Translation failed, falling back to default text:', err);
            }
            const fallbackFn = fallbackMessages[key];
            if (typeof fallbackFn === 'function') {
                return { text: fallbackFn(params || {}), translated: false };
            }
            return { text: key, translated: false };
        }
        const statusBar = document.getElementById('file-status');
        let statusState = null;
        let currentRemoteFile = null;
        function applyStatusState() {
            if (!statusBar) {
                return;
            }
            if (!statusState) {
                statusBar.textContent = '';
                statusBar.classList.remove('active');
                statusBar.removeAttribute('data-i18n');
                statusBar.removeAttribute('data-i18n-params');
                return;
            }
            if (statusState.type === 'i18n') {
                const { text, translated } = resolveTranslation(statusState.key, statusState.params);
                statusBar.textContent = text;
                if (translated) {
                    statusBar.setAttribute('data-i18n', statusState.key);
                    if (statusState.params) {
                        statusBar.setAttribute('data-i18n-params', JSON.stringify(statusState.params));
                    } else {
                        statusBar.removeAttribute('data-i18n-params');
                    }
                    try {
                        appI18n.applyTranslations(statusBar);
                    } catch (err) {
                        console.warn('Could not apply translations for status bar:', err);
                    }
                } else {
                    statusBar.removeAttribute('data-i18n');
                    statusBar.removeAttribute('data-i18n-params');
                }
            } else {
                statusBar.removeAttribute('data-i18n');
                statusBar.removeAttribute('data-i18n-params');
                statusBar.textContent = statusState.text;
            }
            statusBar.classList.add('active');
        }
        function setStatusPlain(text) {
            if (!text) {
                clearStatus();
                return;
            }
            statusState = { type: 'plain', text };
            applyStatusState();
        }
        function setStatusLocalized(key, params) {
            statusState = { type: 'i18n', key, params: params || undefined };
            applyStatusState();
        }
        function clearStatus() {
            statusState = null;
            applyStatusState();
        }
        function updateDocumentTitle() {
            if (currentRemoteFile && currentRemoteFile.fileName) {
                const { text } = resolveTranslation('textEditor.documentTitleWithFile', { fileName: currentRemoteFile.fileName });
                document.title = text;
            } else {
                const { text } = resolveTranslation('textEditor.documentTitle');
                document.title = text;
            }
        }
        updateDocumentTitle();
        function formatFileLabel(meta = {}) {
            const parts = [];
            if (meta.repo) {
                parts.push(meta.repo);
            }
            if (meta.path) {
                parts.push(meta.path);
            } else if (meta.fileName) {
                parts.push(meta.fileName);
            }
            return parts.join(' / ');
        }
        const editor = document.getElementById('editor');
        const saveButton = document.getElementById('save-button');

        function syncSaveButtonState() {
            if (!saveButton) return;
            saveButton.disabled = editor.value.length === 0;
        }

        function clearEditor() {
            editor.value = '';
            localStorage.removeItem('textEditorContent');
            currentRemoteFile = null;
            updateDocumentTitle();
            clearStatus();
            syncSaveButtonState();
            editor.focus();
        }
        function saveFile() {
            const content = editor.value;
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const firstLine = content.split('\n')[0] || 'text';
            const sanitized = firstLine.trim().substring(0, 20).replace(/[^a-zA-Z0-9-_]/g, '') || 'text';
            a.download = `${sanitized}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        function openFile() {
            const input = document.getElementById('file-input');
            input.click();
        }
        // Listener um Datei einzulesen
        document.getElementById('file-input').addEventListener('change', function (event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function (e) {
                const content = e.target.result;
                editor.value = content;
                currentRemoteFile = { fileName: file.name };
                updateDocumentTitle();
                setStatusPlain(file.name);
                syncSaveButtonState();
                editor.focus();
            };
            reader.readAsText(file);
            // Zurücksetzen der Eingabe für zukünftige Öffnungen derselben Datei
            event.target.value = '';
        });
        editor.addEventListener('input', () => {
            localStorage.setItem('textEditorContent', editor.value);
            syncSaveButtonState();
        });
        editor.addEventListener('focus', () => {
            try {
                dialog.refocus();
            } catch (err) {
                console.error('Error refocusing dialog from textarea:', err);
            }
        });

        window.addEventListener('DOMContentLoaded', () => {
            const saved = localStorage.getItem('textEditorContent');
            if (saved) {
                editor.value = saved;
                syncSaveButtonState();
            }
        });
        syncSaveButtonState();
        function loadRemoteFileIntoEditor(payload = {}) {
            if (typeof payload.content !== 'string') {
                return;
            }
            editor.value = payload.content;
            currentRemoteFile = payload;
            const label = formatFileLabel(payload);
            updateDocumentTitle();
            setStatusPlain(label);
            localStorage.setItem('textEditorContent', editor.value);
            syncSaveButtonState();
            editor.focus();
        }
        window.addEventListener('message', (event) => {
            const data = event.data;
            if (!data || typeof data !== 'object') {
                return;
            }
            switch (data.type) {
                case 'textEditor:showLoading': {
                    const label = formatFileLabel(data.payload);
                    if (label) {
                        setStatusLocalized('textEditor.status.loadingWithLabel', { label });
                    } else {
                        setStatusLocalized('textEditor.status.loading');
                    }
                    break;
                }
                case 'textEditor:loadRemoteFile':
                    loadRemoteFileIntoEditor(data.payload);
                    break;
                case 'textEditor:loadError': {
                    const label = formatFileLabel(data.payload);
                    const fallback = resolveTranslation('textEditor.status.loadError');
                    const message = data.payload && data.payload.message ? data.payload.message : fallback.text;
                    if (label) {
                        setStatusPlain(`${label} — ${message}`);
                    } else {
                        setStatusPlain(message);
                    }
                    break;
                }
                default:
                    break;
            }
        });
        window.addEventListener('languagePreferenceChange', () => {
            updateDocumentTitle();
            applyStatusState();
        });
    </script>
</body>

</html>
